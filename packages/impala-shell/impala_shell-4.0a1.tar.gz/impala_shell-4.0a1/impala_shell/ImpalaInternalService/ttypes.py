#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Status.ttypes
import ErrorCodes.ttypes
import Types.ttypes
import Exprs.ttypes
import CatalogObjects.ttypes
import Descriptors.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import DataSinks.ttypes
import Results.ttypes
import RuntimeProfile.ttypes
import ImpalaService.ttypes
import Data.ttypes

from thrift.transport import TTransport
all_structs = []


class TParquetFallbackSchemaResolution(object):
    POSITION = 0
    NAME = 1

    _VALUES_TO_NAMES = {
        0: "POSITION",
        1: "NAME",
    }

    _NAMES_TO_VALUES = {
        "POSITION": 0,
        "NAME": 1,
    }


class TParquetArrayResolution(object):
    THREE_LEVEL = 0
    TWO_LEVEL = 1
    TWO_LEVEL_THEN_THREE_LEVEL = 2

    _VALUES_TO_NAMES = {
        0: "THREE_LEVEL",
        1: "TWO_LEVEL",
        2: "TWO_LEVEL_THEN_THREE_LEVEL",
    }

    _NAMES_TO_VALUES = {
        "THREE_LEVEL": 0,
        "TWO_LEVEL": 1,
        "TWO_LEVEL_THEN_THREE_LEVEL": 2,
    }


class TJoinDistributionMode(object):
    BROADCAST = 0
    SHUFFLE = 1

    _VALUES_TO_NAMES = {
        0: "BROADCAST",
        1: "SHUFFLE",
    }

    _NAMES_TO_VALUES = {
        "BROADCAST": 0,
        "SHUFFLE": 1,
    }


class TKuduReadMode(object):
    DEFAULT = 0
    READ_LATEST = 1
    READ_AT_SNAPSHOT = 2

    _VALUES_TO_NAMES = {
        0: "DEFAULT",
        1: "READ_LATEST",
        2: "READ_AT_SNAPSHOT",
    }

    _NAMES_TO_VALUES = {
        "DEFAULT": 0,
        "READ_LATEST": 1,
        "READ_AT_SNAPSHOT": 2,
    }


class TParquetTimestampType(object):
    INT96_NANOS = 0
    INT64_MILLIS = 1
    INT64_MICROS = 2
    INT64_NANOS = 3

    _VALUES_TO_NAMES = {
        0: "INT96_NANOS",
        1: "INT64_MILLIS",
        2: "INT64_MICROS",
        3: "INT64_NANOS",
    }

    _NAMES_TO_VALUES = {
        "INT96_NANOS": 0,
        "INT64_MILLIS": 1,
        "INT64_MICROS": 2,
        "INT64_NANOS": 3,
    }


class TTransactionalType(object):
    NONE = 0
    INSERT_ONLY = 1

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "INSERT_ONLY",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "INSERT_ONLY": 1,
    }


class TSessionType(object):
    BEESWAX = 0
    HIVESERVER2 = 1

    _VALUES_TO_NAMES = {
        0: "BEESWAX",
        1: "HIVESERVER2",
    }

    _NAMES_TO_VALUES = {
        "BEESWAX": 0,
        "HIVESERVER2": 1,
    }


class ImpalaInternalServiceVersion(object):
    V1 = 0

    _VALUES_TO_NAMES = {
        0: "V1",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
    }


class TQueryOptions(object):
    """
    Attributes:
     - abort_on_error
     - max_errors
     - disable_codegen
     - batch_size
     - num_nodes
     - max_scan_range_length
     - num_scanner_threads
     - debug_action
     - mem_limit
     - compression_codec
     - hbase_caching
     - hbase_cache_blocks
     - parquet_file_size
     - explain_level
     - sync_ddl
     - request_pool
     - disable_outermost_topn
     - query_timeout_s
     - buffer_pool_limit
     - appx_count_distinct
     - disable_unsafe_spills
     - exec_single_node_rows_threshold
     - optimize_partition_key_scans
     - replica_preference
     - schedule_random_replica
     - disable_streaming_preaggregations
     - runtime_filter_mode
     - runtime_bloom_filter_size
     - runtime_filter_wait_time_ms
     - disable_row_runtime_filtering
     - max_num_runtime_filters
     - parquet_annotate_strings_utf8
     - parquet_fallback_schema_resolution
     - mt_dop
     - s3_skip_insert_staging
     - runtime_filter_min_size
     - runtime_filter_max_size
     - prefetch_mode
     - strict_mode
     - scratch_limit
     - enable_expr_rewrites
     - decimal_v2
     - parquet_dictionary_filtering
     - parquet_array_resolution
     - parquet_read_statistics
     - default_join_distribution_mode
     - disable_codegen_rows_threshold
     - default_spillable_buffer_size
     - min_spillable_buffer_size
     - max_row_size
     - idle_session_timeout
     - compute_stats_min_sample_size
     - exec_time_limit_s
     - shuffle_distinct_exprs
     - max_mem_estimate_for_admission
     - thread_reservation_limit
     - thread_reservation_aggregate_limit
     - kudu_read_mode
     - allow_erasure_coded_files
     - timezone
     - scan_bytes_limit
     - cpu_limit_s
     - topn_bytes_limit
     - client_identifier
     - resource_trace_ratio
     - num_remote_executor_candidates
     - num_rows_produced_limit
     - planner_testcase_mode
     - default_file_format
     - parquet_timestamp_type
     - parquet_read_page_index
     - parquet_write_page_index
     - parquet_page_row_count_limit
     - disable_hdfs_num_rows_estimate
     - default_hints_insert_statement
     - spool_query_results
     - default_transactional_type
     - statement_expression_limit
     - max_statement_length_bytes
     - disable_data_cache
     - max_result_spooling_mem
     - max_spilled_result_spooling_mem
     - disable_hbase_num_rows_estimate
     - fetch_rows_timeout_ms
     - now_string
     - parquet_object_store_split_size
     - mem_limit_executors
     - broadcast_bytes_limit
     - preagg_bytes_limit
     - enable_cnf_rewrites
     - max_cnf_exprs
     - kudu_snapshot_read_timestamp_micros
    """


    def __init__(self, abort_on_error=False, max_errors=100, disable_codegen=False, batch_size=0, num_nodes=0, max_scan_range_length=0, num_scanner_threads=0, debug_action="", mem_limit=0, compression_codec=None, hbase_caching=0, hbase_cache_blocks=False, parquet_file_size=0, explain_level=1, sync_ddl=False, request_pool=None, disable_outermost_topn=False, query_timeout_s=0, buffer_pool_limit=None, appx_count_distinct=False, disable_unsafe_spills=False, exec_single_node_rows_threshold=100, optimize_partition_key_scans=False, replica_preference=0, schedule_random_replica=False, disable_streaming_preaggregations=False, runtime_filter_mode=2, runtime_bloom_filter_size=1048576, runtime_filter_wait_time_ms=0, disable_row_runtime_filtering=False, max_num_runtime_filters=10, parquet_annotate_strings_utf8=False, parquet_fallback_schema_resolution=0, mt_dop=None, s3_skip_insert_staging=True, runtime_filter_min_size=1048576, runtime_filter_max_size=16777216, prefetch_mode=1, strict_mode=False, scratch_limit=-1, enable_expr_rewrites=True, decimal_v2=True, parquet_dictionary_filtering=True, parquet_array_resolution=0, parquet_read_statistics=True, default_join_distribution_mode=0, disable_codegen_rows_threshold=50000, default_spillable_buffer_size=2097152, min_spillable_buffer_size=65536, max_row_size=524288, idle_session_timeout=None, compute_stats_min_sample_size=1073741824, exec_time_limit_s=0, shuffle_distinct_exprs=True, max_mem_estimate_for_admission=0, thread_reservation_limit=3000, thread_reservation_aggregate_limit=0, kudu_read_mode=0, allow_erasure_coded_files=False, timezone="", scan_bytes_limit=0, cpu_limit_s=0, topn_bytes_limit=536870912, client_identifier=None, resource_trace_ratio=0, num_remote_executor_candidates=3, num_rows_produced_limit=0, planner_testcase_mode=False, default_file_format=0, parquet_timestamp_type=0, parquet_read_page_index=True, parquet_write_page_index=True, parquet_page_row_count_limit=None, disable_hdfs_num_rows_estimate=False, default_hints_insert_statement=None, spool_query_results=False, default_transactional_type=0, statement_expression_limit=250000, max_statement_length_bytes=16777216, disable_data_cache=False, max_result_spooling_mem=104857600, max_spilled_result_spooling_mem=1073741824, disable_hbase_num_rows_estimate=False, fetch_rows_timeout_ms=10000, now_string="", parquet_object_store_split_size=268435456, mem_limit_executors=0, broadcast_bytes_limit=34359738368, preagg_bytes_limit=-1, enable_cnf_rewrites=True, max_cnf_exprs=0, kudu_snapshot_read_timestamp_micros=0,):
        self.abort_on_error = abort_on_error
        self.max_errors = max_errors
        self.disable_codegen = disable_codegen
        self.batch_size = batch_size
        self.num_nodes = num_nodes
        self.max_scan_range_length = max_scan_range_length
        self.num_scanner_threads = num_scanner_threads
        self.debug_action = debug_action
        self.mem_limit = mem_limit
        self.compression_codec = compression_codec
        self.hbase_caching = hbase_caching
        self.hbase_cache_blocks = hbase_cache_blocks
        self.parquet_file_size = parquet_file_size
        self.explain_level = explain_level
        self.sync_ddl = sync_ddl
        self.request_pool = request_pool
        self.disable_outermost_topn = disable_outermost_topn
        self.query_timeout_s = query_timeout_s
        self.buffer_pool_limit = buffer_pool_limit
        self.appx_count_distinct = appx_count_distinct
        self.disable_unsafe_spills = disable_unsafe_spills
        self.exec_single_node_rows_threshold = exec_single_node_rows_threshold
        self.optimize_partition_key_scans = optimize_partition_key_scans
        self.replica_preference = replica_preference
        self.schedule_random_replica = schedule_random_replica
        self.disable_streaming_preaggregations = disable_streaming_preaggregations
        self.runtime_filter_mode = runtime_filter_mode
        self.runtime_bloom_filter_size = runtime_bloom_filter_size
        self.runtime_filter_wait_time_ms = runtime_filter_wait_time_ms
        self.disable_row_runtime_filtering = disable_row_runtime_filtering
        self.max_num_runtime_filters = max_num_runtime_filters
        self.parquet_annotate_strings_utf8 = parquet_annotate_strings_utf8
        self.parquet_fallback_schema_resolution = parquet_fallback_schema_resolution
        self.mt_dop = mt_dop
        self.s3_skip_insert_staging = s3_skip_insert_staging
        self.runtime_filter_min_size = runtime_filter_min_size
        self.runtime_filter_max_size = runtime_filter_max_size
        self.prefetch_mode = prefetch_mode
        self.strict_mode = strict_mode
        self.scratch_limit = scratch_limit
        self.enable_expr_rewrites = enable_expr_rewrites
        self.decimal_v2 = decimal_v2
        self.parquet_dictionary_filtering = parquet_dictionary_filtering
        self.parquet_array_resolution = parquet_array_resolution
        self.parquet_read_statistics = parquet_read_statistics
        self.default_join_distribution_mode = default_join_distribution_mode
        self.disable_codegen_rows_threshold = disable_codegen_rows_threshold
        self.default_spillable_buffer_size = default_spillable_buffer_size
        self.min_spillable_buffer_size = min_spillable_buffer_size
        self.max_row_size = max_row_size
        self.idle_session_timeout = idle_session_timeout
        self.compute_stats_min_sample_size = compute_stats_min_sample_size
        self.exec_time_limit_s = exec_time_limit_s
        self.shuffle_distinct_exprs = shuffle_distinct_exprs
        self.max_mem_estimate_for_admission = max_mem_estimate_for_admission
        self.thread_reservation_limit = thread_reservation_limit
        self.thread_reservation_aggregate_limit = thread_reservation_aggregate_limit
        self.kudu_read_mode = kudu_read_mode
        self.allow_erasure_coded_files = allow_erasure_coded_files
        self.timezone = timezone
        self.scan_bytes_limit = scan_bytes_limit
        self.cpu_limit_s = cpu_limit_s
        self.topn_bytes_limit = topn_bytes_limit
        self.client_identifier = client_identifier
        self.resource_trace_ratio = resource_trace_ratio
        self.num_remote_executor_candidates = num_remote_executor_candidates
        self.num_rows_produced_limit = num_rows_produced_limit
        self.planner_testcase_mode = planner_testcase_mode
        self.default_file_format = default_file_format
        self.parquet_timestamp_type = parquet_timestamp_type
        self.parquet_read_page_index = parquet_read_page_index
        self.parquet_write_page_index = parquet_write_page_index
        self.parquet_page_row_count_limit = parquet_page_row_count_limit
        self.disable_hdfs_num_rows_estimate = disable_hdfs_num_rows_estimate
        self.default_hints_insert_statement = default_hints_insert_statement
        self.spool_query_results = spool_query_results
        self.default_transactional_type = default_transactional_type
        self.statement_expression_limit = statement_expression_limit
        self.max_statement_length_bytes = max_statement_length_bytes
        self.disable_data_cache = disable_data_cache
        self.max_result_spooling_mem = max_result_spooling_mem
        self.max_spilled_result_spooling_mem = max_spilled_result_spooling_mem
        self.disable_hbase_num_rows_estimate = disable_hbase_num_rows_estimate
        self.fetch_rows_timeout_ms = fetch_rows_timeout_ms
        self.now_string = now_string
        self.parquet_object_store_split_size = parquet_object_store_split_size
        self.mem_limit_executors = mem_limit_executors
        self.broadcast_bytes_limit = broadcast_bytes_limit
        self.preagg_bytes_limit = preagg_bytes_limit
        self.enable_cnf_rewrites = enable_cnf_rewrites
        self.max_cnf_exprs = max_cnf_exprs
        self.kudu_snapshot_read_timestamp_micros = kudu_snapshot_read_timestamp_micros

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.abort_on_error = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.max_errors = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.disable_codegen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.batch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.num_nodes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_scan_range_length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.num_scanner_threads = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.debug_action = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.compression_codec = CatalogObjects.ttypes.TCompressionCodec()
                    self.compression_codec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.hbase_caching = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.hbase_cache_blocks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.parquet_file_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.explain_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.request_pool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.BOOL:
                    self.disable_outermost_topn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I32:
                    self.query_timeout_s = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I64:
                    self.buffer_pool_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.BOOL:
                    self.appx_count_distinct = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.BOOL:
                    self.disable_unsafe_spills = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.exec_single_node_rows_threshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.BOOL:
                    self.optimize_partition_key_scans = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I32:
                    self.replica_preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.BOOL:
                    self.schedule_random_replica = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.BOOL:
                    self.disable_streaming_preaggregations = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 37:
                if ftype == TType.I32:
                    self.runtime_filter_mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 38:
                if ftype == TType.I32:
                    self.runtime_bloom_filter_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 39:
                if ftype == TType.I32:
                    self.runtime_filter_wait_time_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 40:
                if ftype == TType.BOOL:
                    self.disable_row_runtime_filtering = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 41:
                if ftype == TType.I32:
                    self.max_num_runtime_filters = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 42:
                if ftype == TType.BOOL:
                    self.parquet_annotate_strings_utf8 = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 43:
                if ftype == TType.I32:
                    self.parquet_fallback_schema_resolution = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 44:
                if ftype == TType.I32:
                    self.mt_dop = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 45:
                if ftype == TType.BOOL:
                    self.s3_skip_insert_staging = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 46:
                if ftype == TType.I32:
                    self.runtime_filter_min_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 47:
                if ftype == TType.I32:
                    self.runtime_filter_max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 48:
                if ftype == TType.I32:
                    self.prefetch_mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 49:
                if ftype == TType.BOOL:
                    self.strict_mode = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 50:
                if ftype == TType.I64:
                    self.scratch_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 51:
                if ftype == TType.BOOL:
                    self.enable_expr_rewrites = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 52:
                if ftype == TType.BOOL:
                    self.decimal_v2 = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 53:
                if ftype == TType.BOOL:
                    self.parquet_dictionary_filtering = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 54:
                if ftype == TType.I32:
                    self.parquet_array_resolution = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 55:
                if ftype == TType.BOOL:
                    self.parquet_read_statistics = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 56:
                if ftype == TType.I32:
                    self.default_join_distribution_mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 57:
                if ftype == TType.I32:
                    self.disable_codegen_rows_threshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 58:
                if ftype == TType.I64:
                    self.default_spillable_buffer_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 59:
                if ftype == TType.I64:
                    self.min_spillable_buffer_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 60:
                if ftype == TType.I64:
                    self.max_row_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 61:
                if ftype == TType.I32:
                    self.idle_session_timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 62:
                if ftype == TType.I64:
                    self.compute_stats_min_sample_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 63:
                if ftype == TType.I32:
                    self.exec_time_limit_s = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 64:
                if ftype == TType.BOOL:
                    self.shuffle_distinct_exprs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 65:
                if ftype == TType.I64:
                    self.max_mem_estimate_for_admission = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 66:
                if ftype == TType.I32:
                    self.thread_reservation_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 67:
                if ftype == TType.I32:
                    self.thread_reservation_aggregate_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 68:
                if ftype == TType.I32:
                    self.kudu_read_mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 69:
                if ftype == TType.BOOL:
                    self.allow_erasure_coded_files = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 70:
                if ftype == TType.STRING:
                    self.timezone = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 71:
                if ftype == TType.I64:
                    self.scan_bytes_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 72:
                if ftype == TType.I64:
                    self.cpu_limit_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 73:
                if ftype == TType.I64:
                    self.topn_bytes_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 74:
                if ftype == TType.STRING:
                    self.client_identifier = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 75:
                if ftype == TType.DOUBLE:
                    self.resource_trace_ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 76:
                if ftype == TType.I32:
                    self.num_remote_executor_candidates = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 77:
                if ftype == TType.I64:
                    self.num_rows_produced_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 78:
                if ftype == TType.BOOL:
                    self.planner_testcase_mode = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 79:
                if ftype == TType.I32:
                    self.default_file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 80:
                if ftype == TType.I32:
                    self.parquet_timestamp_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 81:
                if ftype == TType.BOOL:
                    self.parquet_read_page_index = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 82:
                if ftype == TType.BOOL:
                    self.parquet_write_page_index = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 83:
                if ftype == TType.I32:
                    self.parquet_page_row_count_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 84:
                if ftype == TType.BOOL:
                    self.disable_hdfs_num_rows_estimate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 85:
                if ftype == TType.STRING:
                    self.default_hints_insert_statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 86:
                if ftype == TType.BOOL:
                    self.spool_query_results = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 87:
                if ftype == TType.I32:
                    self.default_transactional_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 88:
                if ftype == TType.I32:
                    self.statement_expression_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 89:
                if ftype == TType.I32:
                    self.max_statement_length_bytes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 90:
                if ftype == TType.BOOL:
                    self.disable_data_cache = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 91:
                if ftype == TType.I64:
                    self.max_result_spooling_mem = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 92:
                if ftype == TType.I64:
                    self.max_spilled_result_spooling_mem = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 93:
                if ftype == TType.BOOL:
                    self.disable_hbase_num_rows_estimate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 94:
                if ftype == TType.I64:
                    self.fetch_rows_timeout_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 95:
                if ftype == TType.STRING:
                    self.now_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 96:
                if ftype == TType.I64:
                    self.parquet_object_store_split_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 97:
                if ftype == TType.I64:
                    self.mem_limit_executors = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 98:
                if ftype == TType.I64:
                    self.broadcast_bytes_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 99:
                if ftype == TType.I64:
                    self.preagg_bytes_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.BOOL:
                    self.enable_cnf_rewrites = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.I32:
                    self.max_cnf_exprs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.I64:
                    self.kudu_snapshot_read_timestamp_micros = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryOptions')
        if self.abort_on_error is not None:
            oprot.writeFieldBegin('abort_on_error', TType.BOOL, 1)
            oprot.writeBool(self.abort_on_error)
            oprot.writeFieldEnd()
        if self.max_errors is not None:
            oprot.writeFieldBegin('max_errors', TType.I32, 2)
            oprot.writeI32(self.max_errors)
            oprot.writeFieldEnd()
        if self.disable_codegen is not None:
            oprot.writeFieldBegin('disable_codegen', TType.BOOL, 3)
            oprot.writeBool(self.disable_codegen)
            oprot.writeFieldEnd()
        if self.batch_size is not None:
            oprot.writeFieldBegin('batch_size', TType.I32, 4)
            oprot.writeI32(self.batch_size)
            oprot.writeFieldEnd()
        if self.num_nodes is not None:
            oprot.writeFieldBegin('num_nodes', TType.I32, 5)
            oprot.writeI32(self.num_nodes)
            oprot.writeFieldEnd()
        if self.max_scan_range_length is not None:
            oprot.writeFieldBegin('max_scan_range_length', TType.I64, 6)
            oprot.writeI64(self.max_scan_range_length)
            oprot.writeFieldEnd()
        if self.num_scanner_threads is not None:
            oprot.writeFieldBegin('num_scanner_threads', TType.I32, 7)
            oprot.writeI32(self.num_scanner_threads)
            oprot.writeFieldEnd()
        if self.debug_action is not None:
            oprot.writeFieldBegin('debug_action', TType.STRING, 11)
            oprot.writeString(self.debug_action.encode('utf-8') if sys.version_info[0] == 2 else self.debug_action)
            oprot.writeFieldEnd()
        if self.mem_limit is not None:
            oprot.writeFieldBegin('mem_limit', TType.I64, 12)
            oprot.writeI64(self.mem_limit)
            oprot.writeFieldEnd()
        if self.compression_codec is not None:
            oprot.writeFieldBegin('compression_codec', TType.STRUCT, 14)
            self.compression_codec.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_caching is not None:
            oprot.writeFieldBegin('hbase_caching', TType.I32, 15)
            oprot.writeI32(self.hbase_caching)
            oprot.writeFieldEnd()
        if self.hbase_cache_blocks is not None:
            oprot.writeFieldBegin('hbase_cache_blocks', TType.BOOL, 16)
            oprot.writeBool(self.hbase_cache_blocks)
            oprot.writeFieldEnd()
        if self.parquet_file_size is not None:
            oprot.writeFieldBegin('parquet_file_size', TType.I64, 17)
            oprot.writeI64(self.parquet_file_size)
            oprot.writeFieldEnd()
        if self.explain_level is not None:
            oprot.writeFieldBegin('explain_level', TType.I32, 18)
            oprot.writeI32(self.explain_level)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 19)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.request_pool is not None:
            oprot.writeFieldBegin('request_pool', TType.STRING, 20)
            oprot.writeString(self.request_pool.encode('utf-8') if sys.version_info[0] == 2 else self.request_pool)
            oprot.writeFieldEnd()
        if self.disable_outermost_topn is not None:
            oprot.writeFieldBegin('disable_outermost_topn', TType.BOOL, 24)
            oprot.writeBool(self.disable_outermost_topn)
            oprot.writeFieldEnd()
        if self.query_timeout_s is not None:
            oprot.writeFieldBegin('query_timeout_s', TType.I32, 26)
            oprot.writeI32(self.query_timeout_s)
            oprot.writeFieldEnd()
        if self.buffer_pool_limit is not None:
            oprot.writeFieldBegin('buffer_pool_limit', TType.I64, 27)
            oprot.writeI64(self.buffer_pool_limit)
            oprot.writeFieldEnd()
        if self.appx_count_distinct is not None:
            oprot.writeFieldBegin('appx_count_distinct', TType.BOOL, 28)
            oprot.writeBool(self.appx_count_distinct)
            oprot.writeFieldEnd()
        if self.disable_unsafe_spills is not None:
            oprot.writeFieldBegin('disable_unsafe_spills', TType.BOOL, 29)
            oprot.writeBool(self.disable_unsafe_spills)
            oprot.writeFieldEnd()
        if self.exec_single_node_rows_threshold is not None:
            oprot.writeFieldBegin('exec_single_node_rows_threshold', TType.I32, 31)
            oprot.writeI32(self.exec_single_node_rows_threshold)
            oprot.writeFieldEnd()
        if self.optimize_partition_key_scans is not None:
            oprot.writeFieldBegin('optimize_partition_key_scans', TType.BOOL, 32)
            oprot.writeBool(self.optimize_partition_key_scans)
            oprot.writeFieldEnd()
        if self.replica_preference is not None:
            oprot.writeFieldBegin('replica_preference', TType.I32, 33)
            oprot.writeI32(self.replica_preference)
            oprot.writeFieldEnd()
        if self.schedule_random_replica is not None:
            oprot.writeFieldBegin('schedule_random_replica', TType.BOOL, 34)
            oprot.writeBool(self.schedule_random_replica)
            oprot.writeFieldEnd()
        if self.disable_streaming_preaggregations is not None:
            oprot.writeFieldBegin('disable_streaming_preaggregations', TType.BOOL, 36)
            oprot.writeBool(self.disable_streaming_preaggregations)
            oprot.writeFieldEnd()
        if self.runtime_filter_mode is not None:
            oprot.writeFieldBegin('runtime_filter_mode', TType.I32, 37)
            oprot.writeI32(self.runtime_filter_mode)
            oprot.writeFieldEnd()
        if self.runtime_bloom_filter_size is not None:
            oprot.writeFieldBegin('runtime_bloom_filter_size', TType.I32, 38)
            oprot.writeI32(self.runtime_bloom_filter_size)
            oprot.writeFieldEnd()
        if self.runtime_filter_wait_time_ms is not None:
            oprot.writeFieldBegin('runtime_filter_wait_time_ms', TType.I32, 39)
            oprot.writeI32(self.runtime_filter_wait_time_ms)
            oprot.writeFieldEnd()
        if self.disable_row_runtime_filtering is not None:
            oprot.writeFieldBegin('disable_row_runtime_filtering', TType.BOOL, 40)
            oprot.writeBool(self.disable_row_runtime_filtering)
            oprot.writeFieldEnd()
        if self.max_num_runtime_filters is not None:
            oprot.writeFieldBegin('max_num_runtime_filters', TType.I32, 41)
            oprot.writeI32(self.max_num_runtime_filters)
            oprot.writeFieldEnd()
        if self.parquet_annotate_strings_utf8 is not None:
            oprot.writeFieldBegin('parquet_annotate_strings_utf8', TType.BOOL, 42)
            oprot.writeBool(self.parquet_annotate_strings_utf8)
            oprot.writeFieldEnd()
        if self.parquet_fallback_schema_resolution is not None:
            oprot.writeFieldBegin('parquet_fallback_schema_resolution', TType.I32, 43)
            oprot.writeI32(self.parquet_fallback_schema_resolution)
            oprot.writeFieldEnd()
        if self.mt_dop is not None:
            oprot.writeFieldBegin('mt_dop', TType.I32, 44)
            oprot.writeI32(self.mt_dop)
            oprot.writeFieldEnd()
        if self.s3_skip_insert_staging is not None:
            oprot.writeFieldBegin('s3_skip_insert_staging', TType.BOOL, 45)
            oprot.writeBool(self.s3_skip_insert_staging)
            oprot.writeFieldEnd()
        if self.runtime_filter_min_size is not None:
            oprot.writeFieldBegin('runtime_filter_min_size', TType.I32, 46)
            oprot.writeI32(self.runtime_filter_min_size)
            oprot.writeFieldEnd()
        if self.runtime_filter_max_size is not None:
            oprot.writeFieldBegin('runtime_filter_max_size', TType.I32, 47)
            oprot.writeI32(self.runtime_filter_max_size)
            oprot.writeFieldEnd()
        if self.prefetch_mode is not None:
            oprot.writeFieldBegin('prefetch_mode', TType.I32, 48)
            oprot.writeI32(self.prefetch_mode)
            oprot.writeFieldEnd()
        if self.strict_mode is not None:
            oprot.writeFieldBegin('strict_mode', TType.BOOL, 49)
            oprot.writeBool(self.strict_mode)
            oprot.writeFieldEnd()
        if self.scratch_limit is not None:
            oprot.writeFieldBegin('scratch_limit', TType.I64, 50)
            oprot.writeI64(self.scratch_limit)
            oprot.writeFieldEnd()
        if self.enable_expr_rewrites is not None:
            oprot.writeFieldBegin('enable_expr_rewrites', TType.BOOL, 51)
            oprot.writeBool(self.enable_expr_rewrites)
            oprot.writeFieldEnd()
        if self.decimal_v2 is not None:
            oprot.writeFieldBegin('decimal_v2', TType.BOOL, 52)
            oprot.writeBool(self.decimal_v2)
            oprot.writeFieldEnd()
        if self.parquet_dictionary_filtering is not None:
            oprot.writeFieldBegin('parquet_dictionary_filtering', TType.BOOL, 53)
            oprot.writeBool(self.parquet_dictionary_filtering)
            oprot.writeFieldEnd()
        if self.parquet_array_resolution is not None:
            oprot.writeFieldBegin('parquet_array_resolution', TType.I32, 54)
            oprot.writeI32(self.parquet_array_resolution)
            oprot.writeFieldEnd()
        if self.parquet_read_statistics is not None:
            oprot.writeFieldBegin('parquet_read_statistics', TType.BOOL, 55)
            oprot.writeBool(self.parquet_read_statistics)
            oprot.writeFieldEnd()
        if self.default_join_distribution_mode is not None:
            oprot.writeFieldBegin('default_join_distribution_mode', TType.I32, 56)
            oprot.writeI32(self.default_join_distribution_mode)
            oprot.writeFieldEnd()
        if self.disable_codegen_rows_threshold is not None:
            oprot.writeFieldBegin('disable_codegen_rows_threshold', TType.I32, 57)
            oprot.writeI32(self.disable_codegen_rows_threshold)
            oprot.writeFieldEnd()
        if self.default_spillable_buffer_size is not None:
            oprot.writeFieldBegin('default_spillable_buffer_size', TType.I64, 58)
            oprot.writeI64(self.default_spillable_buffer_size)
            oprot.writeFieldEnd()
        if self.min_spillable_buffer_size is not None:
            oprot.writeFieldBegin('min_spillable_buffer_size', TType.I64, 59)
            oprot.writeI64(self.min_spillable_buffer_size)
            oprot.writeFieldEnd()
        if self.max_row_size is not None:
            oprot.writeFieldBegin('max_row_size', TType.I64, 60)
            oprot.writeI64(self.max_row_size)
            oprot.writeFieldEnd()
        if self.idle_session_timeout is not None:
            oprot.writeFieldBegin('idle_session_timeout', TType.I32, 61)
            oprot.writeI32(self.idle_session_timeout)
            oprot.writeFieldEnd()
        if self.compute_stats_min_sample_size is not None:
            oprot.writeFieldBegin('compute_stats_min_sample_size', TType.I64, 62)
            oprot.writeI64(self.compute_stats_min_sample_size)
            oprot.writeFieldEnd()
        if self.exec_time_limit_s is not None:
            oprot.writeFieldBegin('exec_time_limit_s', TType.I32, 63)
            oprot.writeI32(self.exec_time_limit_s)
            oprot.writeFieldEnd()
        if self.shuffle_distinct_exprs is not None:
            oprot.writeFieldBegin('shuffle_distinct_exprs', TType.BOOL, 64)
            oprot.writeBool(self.shuffle_distinct_exprs)
            oprot.writeFieldEnd()
        if self.max_mem_estimate_for_admission is not None:
            oprot.writeFieldBegin('max_mem_estimate_for_admission', TType.I64, 65)
            oprot.writeI64(self.max_mem_estimate_for_admission)
            oprot.writeFieldEnd()
        if self.thread_reservation_limit is not None:
            oprot.writeFieldBegin('thread_reservation_limit', TType.I32, 66)
            oprot.writeI32(self.thread_reservation_limit)
            oprot.writeFieldEnd()
        if self.thread_reservation_aggregate_limit is not None:
            oprot.writeFieldBegin('thread_reservation_aggregate_limit', TType.I32, 67)
            oprot.writeI32(self.thread_reservation_aggregate_limit)
            oprot.writeFieldEnd()
        if self.kudu_read_mode is not None:
            oprot.writeFieldBegin('kudu_read_mode', TType.I32, 68)
            oprot.writeI32(self.kudu_read_mode)
            oprot.writeFieldEnd()
        if self.allow_erasure_coded_files is not None:
            oprot.writeFieldBegin('allow_erasure_coded_files', TType.BOOL, 69)
            oprot.writeBool(self.allow_erasure_coded_files)
            oprot.writeFieldEnd()
        if self.timezone is not None:
            oprot.writeFieldBegin('timezone', TType.STRING, 70)
            oprot.writeString(self.timezone.encode('utf-8') if sys.version_info[0] == 2 else self.timezone)
            oprot.writeFieldEnd()
        if self.scan_bytes_limit is not None:
            oprot.writeFieldBegin('scan_bytes_limit', TType.I64, 71)
            oprot.writeI64(self.scan_bytes_limit)
            oprot.writeFieldEnd()
        if self.cpu_limit_s is not None:
            oprot.writeFieldBegin('cpu_limit_s', TType.I64, 72)
            oprot.writeI64(self.cpu_limit_s)
            oprot.writeFieldEnd()
        if self.topn_bytes_limit is not None:
            oprot.writeFieldBegin('topn_bytes_limit', TType.I64, 73)
            oprot.writeI64(self.topn_bytes_limit)
            oprot.writeFieldEnd()
        if self.client_identifier is not None:
            oprot.writeFieldBegin('client_identifier', TType.STRING, 74)
            oprot.writeString(self.client_identifier.encode('utf-8') if sys.version_info[0] == 2 else self.client_identifier)
            oprot.writeFieldEnd()
        if self.resource_trace_ratio is not None:
            oprot.writeFieldBegin('resource_trace_ratio', TType.DOUBLE, 75)
            oprot.writeDouble(self.resource_trace_ratio)
            oprot.writeFieldEnd()
        if self.num_remote_executor_candidates is not None:
            oprot.writeFieldBegin('num_remote_executor_candidates', TType.I32, 76)
            oprot.writeI32(self.num_remote_executor_candidates)
            oprot.writeFieldEnd()
        if self.num_rows_produced_limit is not None:
            oprot.writeFieldBegin('num_rows_produced_limit', TType.I64, 77)
            oprot.writeI64(self.num_rows_produced_limit)
            oprot.writeFieldEnd()
        if self.planner_testcase_mode is not None:
            oprot.writeFieldBegin('planner_testcase_mode', TType.BOOL, 78)
            oprot.writeBool(self.planner_testcase_mode)
            oprot.writeFieldEnd()
        if self.default_file_format is not None:
            oprot.writeFieldBegin('default_file_format', TType.I32, 79)
            oprot.writeI32(self.default_file_format)
            oprot.writeFieldEnd()
        if self.parquet_timestamp_type is not None:
            oprot.writeFieldBegin('parquet_timestamp_type', TType.I32, 80)
            oprot.writeI32(self.parquet_timestamp_type)
            oprot.writeFieldEnd()
        if self.parquet_read_page_index is not None:
            oprot.writeFieldBegin('parquet_read_page_index', TType.BOOL, 81)
            oprot.writeBool(self.parquet_read_page_index)
            oprot.writeFieldEnd()
        if self.parquet_write_page_index is not None:
            oprot.writeFieldBegin('parquet_write_page_index', TType.BOOL, 82)
            oprot.writeBool(self.parquet_write_page_index)
            oprot.writeFieldEnd()
        if self.parquet_page_row_count_limit is not None:
            oprot.writeFieldBegin('parquet_page_row_count_limit', TType.I32, 83)
            oprot.writeI32(self.parquet_page_row_count_limit)
            oprot.writeFieldEnd()
        if self.disable_hdfs_num_rows_estimate is not None:
            oprot.writeFieldBegin('disable_hdfs_num_rows_estimate', TType.BOOL, 84)
            oprot.writeBool(self.disable_hdfs_num_rows_estimate)
            oprot.writeFieldEnd()
        if self.default_hints_insert_statement is not None:
            oprot.writeFieldBegin('default_hints_insert_statement', TType.STRING, 85)
            oprot.writeString(self.default_hints_insert_statement.encode('utf-8') if sys.version_info[0] == 2 else self.default_hints_insert_statement)
            oprot.writeFieldEnd()
        if self.spool_query_results is not None:
            oprot.writeFieldBegin('spool_query_results', TType.BOOL, 86)
            oprot.writeBool(self.spool_query_results)
            oprot.writeFieldEnd()
        if self.default_transactional_type is not None:
            oprot.writeFieldBegin('default_transactional_type', TType.I32, 87)
            oprot.writeI32(self.default_transactional_type)
            oprot.writeFieldEnd()
        if self.statement_expression_limit is not None:
            oprot.writeFieldBegin('statement_expression_limit', TType.I32, 88)
            oprot.writeI32(self.statement_expression_limit)
            oprot.writeFieldEnd()
        if self.max_statement_length_bytes is not None:
            oprot.writeFieldBegin('max_statement_length_bytes', TType.I32, 89)
            oprot.writeI32(self.max_statement_length_bytes)
            oprot.writeFieldEnd()
        if self.disable_data_cache is not None:
            oprot.writeFieldBegin('disable_data_cache', TType.BOOL, 90)
            oprot.writeBool(self.disable_data_cache)
            oprot.writeFieldEnd()
        if self.max_result_spooling_mem is not None:
            oprot.writeFieldBegin('max_result_spooling_mem', TType.I64, 91)
            oprot.writeI64(self.max_result_spooling_mem)
            oprot.writeFieldEnd()
        if self.max_spilled_result_spooling_mem is not None:
            oprot.writeFieldBegin('max_spilled_result_spooling_mem', TType.I64, 92)
            oprot.writeI64(self.max_spilled_result_spooling_mem)
            oprot.writeFieldEnd()
        if self.disable_hbase_num_rows_estimate is not None:
            oprot.writeFieldBegin('disable_hbase_num_rows_estimate', TType.BOOL, 93)
            oprot.writeBool(self.disable_hbase_num_rows_estimate)
            oprot.writeFieldEnd()
        if self.fetch_rows_timeout_ms is not None:
            oprot.writeFieldBegin('fetch_rows_timeout_ms', TType.I64, 94)
            oprot.writeI64(self.fetch_rows_timeout_ms)
            oprot.writeFieldEnd()
        if self.now_string is not None:
            oprot.writeFieldBegin('now_string', TType.STRING, 95)
            oprot.writeString(self.now_string.encode('utf-8') if sys.version_info[0] == 2 else self.now_string)
            oprot.writeFieldEnd()
        if self.parquet_object_store_split_size is not None:
            oprot.writeFieldBegin('parquet_object_store_split_size', TType.I64, 96)
            oprot.writeI64(self.parquet_object_store_split_size)
            oprot.writeFieldEnd()
        if self.mem_limit_executors is not None:
            oprot.writeFieldBegin('mem_limit_executors', TType.I64, 97)
            oprot.writeI64(self.mem_limit_executors)
            oprot.writeFieldEnd()
        if self.broadcast_bytes_limit is not None:
            oprot.writeFieldBegin('broadcast_bytes_limit', TType.I64, 98)
            oprot.writeI64(self.broadcast_bytes_limit)
            oprot.writeFieldEnd()
        if self.preagg_bytes_limit is not None:
            oprot.writeFieldBegin('preagg_bytes_limit', TType.I64, 99)
            oprot.writeI64(self.preagg_bytes_limit)
            oprot.writeFieldEnd()
        if self.enable_cnf_rewrites is not None:
            oprot.writeFieldBegin('enable_cnf_rewrites', TType.BOOL, 100)
            oprot.writeBool(self.enable_cnf_rewrites)
            oprot.writeFieldEnd()
        if self.max_cnf_exprs is not None:
            oprot.writeFieldBegin('max_cnf_exprs', TType.I32, 101)
            oprot.writeI32(self.max_cnf_exprs)
            oprot.writeFieldEnd()
        if self.kudu_snapshot_read_timestamp_micros is not None:
            oprot.writeFieldBegin('kudu_snapshot_read_timestamp_micros', TType.I64, 102)
            oprot.writeI64(self.kudu_snapshot_read_timestamp_micros)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSessionState(object):
    """
    Attributes:
     - session_id
     - session_type
     - database
     - connected_user
     - delegated_user
     - network_address
     - kudu_latest_observed_ts
    """


    def __init__(self, session_id=None, session_type=None, database=None, connected_user=None, delegated_user=None, network_address=None, kudu_latest_observed_ts=None,):
        self.session_id = session_id
        self.session_type = session_type
        self.database = database
        self.connected_user = connected_user
        self.delegated_user = delegated_user
        self.network_address = network_address
        self.kudu_latest_observed_ts = kudu_latest_observed_ts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.STRUCT:
                    self.session_id = Types.ttypes.TUniqueId()
                    self.session_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.session_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.connected_user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.delegated_user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.network_address = Types.ttypes.TNetworkAddress()
                    self.network_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.kudu_latest_observed_ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSessionState')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.connected_user is not None:
            oprot.writeFieldBegin('connected_user', TType.STRING, 2)
            oprot.writeString(self.connected_user.encode('utf-8') if sys.version_info[0] == 2 else self.connected_user)
            oprot.writeFieldEnd()
        if self.session_id is not None:
            oprot.writeFieldBegin('session_id', TType.STRUCT, 3)
            self.session_id.write(oprot)
            oprot.writeFieldEnd()
        if self.network_address is not None:
            oprot.writeFieldBegin('network_address', TType.STRUCT, 4)
            self.network_address.write(oprot)
            oprot.writeFieldEnd()
        if self.session_type is not None:
            oprot.writeFieldBegin('session_type', TType.I32, 5)
            oprot.writeI32(self.session_type)
            oprot.writeFieldEnd()
        if self.delegated_user is not None:
            oprot.writeFieldBegin('delegated_user', TType.STRING, 6)
            oprot.writeString(self.delegated_user.encode('utf-8') if sys.version_info[0] == 2 else self.delegated_user)
            oprot.writeFieldEnd()
        if self.kudu_latest_observed_ts is not None:
            oprot.writeFieldBegin('kudu_latest_observed_ts', TType.I64, 7)
            oprot.writeI64(self.kudu_latest_observed_ts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.session_id is None:
            raise TProtocolException(message='Required field session_id is unset!')
        if self.session_type is None:
            raise TProtocolException(message='Required field session_type is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.connected_user is None:
            raise TProtocolException(message='Required field connected_user is unset!')
        if self.network_address is None:
            raise TProtocolException(message='Required field network_address is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TClientRequest(object):
    """
    Attributes:
     - stmt
     - query_options
     - redacted_stmt
    """


    def __init__(self, stmt=None, query_options=None, redacted_stmt=None,):
        self.stmt = stmt
        self.query_options = query_options
        self.redacted_stmt = redacted_stmt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.stmt = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query_options = TQueryOptions()
                    self.query_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.redacted_stmt = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TClientRequest')
        if self.stmt is not None:
            oprot.writeFieldBegin('stmt', TType.STRING, 1)
            oprot.writeString(self.stmt.encode('utf-8') if sys.version_info[0] == 2 else self.stmt)
            oprot.writeFieldEnd()
        if self.query_options is not None:
            oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
            self.query_options.write(oprot)
            oprot.writeFieldEnd()
        if self.redacted_stmt is not None:
            oprot.writeFieldBegin('redacted_stmt', TType.STRING, 3)
            oprot.writeString(self.redacted_stmt.encode('utf-8') if sys.version_info[0] == 2 else self.redacted_stmt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stmt is None:
            raise TProtocolException(message='Required field stmt is unset!')
        if self.query_options is None:
            raise TProtocolException(message='Required field query_options is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDebugOptions(object):
    """
    Attributes:
     - node_id
     - phase
     - action
     - action_param
    """


    def __init__(self, node_id=None, phase=None, action=None, action_param=None,):
        self.node_id = node_id
        self.phase = phase
        self.action = action
        self.action_param = action_param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.phase = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.action = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.action_param = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDebugOptions')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.phase is not None:
            oprot.writeFieldBegin('phase', TType.I32, 2)
            oprot.writeI32(self.phase)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.I32, 3)
            oprot.writeI32(self.action)
            oprot.writeFieldEnd()
        if self.action_param is not None:
            oprot.writeFieldBegin('action_param', TType.STRING, 4)
            oprot.writeString(self.action_param.encode('utf-8') if sys.version_info[0] == 2 else self.action_param)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TQueryCtx(object):
    """
    Attributes:
     - client_request
     - query_id
     - session
     - now_string
     - pid
     - coord_address
     - coord_krpc_address
     - tables_missing_stats
     - disable_spilling
     - parent_query_id
     - tables_with_corrupt_stats
     - snapshot_timestamp
     - desc_tbl_testonly
     - desc_tbl_serialized
     - start_unix_millis
     - disable_codegen_hint
     - tables_missing_diskids
     - request_pool
     - utc_timestamp_string
     - local_time_zone
     - disable_hbase_num_rows_estimate
     - trace_resource_usage
     - status_report_interval_ms
     - status_report_max_retry_s
     - transaction_id
    """


    def __init__(self, client_request=None, query_id=None, session=None, now_string=None, pid=None, coord_address=None, coord_krpc_address=None, tables_missing_stats=None, disable_spilling=None, parent_query_id=None, tables_with_corrupt_stats=None, snapshot_timestamp=-1, desc_tbl_testonly=None, desc_tbl_serialized=None, start_unix_millis=None, disable_codegen_hint=False, tables_missing_diskids=None, request_pool=None, utc_timestamp_string=None, local_time_zone=None, disable_hbase_num_rows_estimate=False, trace_resource_usage=False, status_report_interval_ms=None, status_report_max_retry_s=None, transaction_id=None,):
        self.client_request = client_request
        self.query_id = query_id
        self.session = session
        self.now_string = now_string
        self.pid = pid
        self.coord_address = coord_address
        self.coord_krpc_address = coord_krpc_address
        self.tables_missing_stats = tables_missing_stats
        self.disable_spilling = disable_spilling
        self.parent_query_id = parent_query_id
        self.tables_with_corrupt_stats = tables_with_corrupt_stats
        self.snapshot_timestamp = snapshot_timestamp
        self.desc_tbl_testonly = desc_tbl_testonly
        self.desc_tbl_serialized = desc_tbl_serialized
        self.start_unix_millis = start_unix_millis
        self.disable_codegen_hint = disable_codegen_hint
        self.tables_missing_diskids = tables_missing_diskids
        self.request_pool = request_pool
        self.utc_timestamp_string = utc_timestamp_string
        self.local_time_zone = local_time_zone
        self.disable_hbase_num_rows_estimate = disable_hbase_num_rows_estimate
        self.trace_resource_usage = trace_resource_usage
        self.status_report_interval_ms = status_report_interval_ms
        self.status_report_max_retry_s = status_report_max_retry_s
        self.transaction_id = transaction_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.client_request = TClientRequest()
                    self.client_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query_id = Types.ttypes.TUniqueId()
                    self.query_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.session = TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.now_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.pid = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.coord_address = Types.ttypes.TNetworkAddress()
                    self.coord_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.coord_krpc_address = Types.ttypes.TNetworkAddress()
                    self.coord_krpc_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.tables_missing_stats = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = CatalogObjects.ttypes.TTableName()
                        _elem5.read(iprot)
                        self.tables_missing_stats.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.disable_spilling = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.parent_query_id = Types.ttypes.TUniqueId()
                    self.parent_query_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.tables_with_corrupt_stats = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = CatalogObjects.ttypes.TTableName()
                        _elem11.read(iprot)
                        self.tables_with_corrupt_stats.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.snapshot_timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.desc_tbl_testonly = Descriptors.ttypes.TDescriptorTable()
                    self.desc_tbl_testonly.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRUCT:
                    self.desc_tbl_serialized = Descriptors.ttypes.TDescriptorTableSerialized()
                    self.desc_tbl_serialized.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.start_unix_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.disable_codegen_hint = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.tables_missing_diskids = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = CatalogObjects.ttypes.TTableName()
                        _elem17.read(iprot)
                        self.tables_missing_diskids.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.request_pool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.utc_timestamp_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.local_time_zone = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    self.disable_hbase_num_rows_estimate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.BOOL:
                    self.trace_resource_usage = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I32:
                    self.status_report_interval_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.status_report_max_retry_s = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I64:
                    self.transaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryCtx')
        if self.client_request is not None:
            oprot.writeFieldBegin('client_request', TType.STRUCT, 1)
            self.client_request.write(oprot)
            oprot.writeFieldEnd()
        if self.query_id is not None:
            oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
            self.query_id.write(oprot)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 3)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        if self.now_string is not None:
            oprot.writeFieldBegin('now_string', TType.STRING, 4)
            oprot.writeString(self.now_string.encode('utf-8') if sys.version_info[0] == 2 else self.now_string)
            oprot.writeFieldEnd()
        if self.pid is not None:
            oprot.writeFieldBegin('pid', TType.I32, 5)
            oprot.writeI32(self.pid)
            oprot.writeFieldEnd()
        if self.coord_address is not None:
            oprot.writeFieldBegin('coord_address', TType.STRUCT, 6)
            self.coord_address.write(oprot)
            oprot.writeFieldEnd()
        if self.coord_krpc_address is not None:
            oprot.writeFieldBegin('coord_krpc_address', TType.STRUCT, 7)
            self.coord_krpc_address.write(oprot)
            oprot.writeFieldEnd()
        if self.tables_missing_stats is not None:
            oprot.writeFieldBegin('tables_missing_stats', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.tables_missing_stats))
            for iter18 in self.tables_missing_stats:
                iter18.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.disable_spilling is not None:
            oprot.writeFieldBegin('disable_spilling', TType.BOOL, 9)
            oprot.writeBool(self.disable_spilling)
            oprot.writeFieldEnd()
        if self.parent_query_id is not None:
            oprot.writeFieldBegin('parent_query_id', TType.STRUCT, 10)
            self.parent_query_id.write(oprot)
            oprot.writeFieldEnd()
        if self.tables_with_corrupt_stats is not None:
            oprot.writeFieldBegin('tables_with_corrupt_stats', TType.LIST, 11)
            oprot.writeListBegin(TType.STRUCT, len(self.tables_with_corrupt_stats))
            for iter19 in self.tables_with_corrupt_stats:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.snapshot_timestamp is not None:
            oprot.writeFieldBegin('snapshot_timestamp', TType.I64, 12)
            oprot.writeI64(self.snapshot_timestamp)
            oprot.writeFieldEnd()
        if self.desc_tbl_testonly is not None:
            oprot.writeFieldBegin('desc_tbl_testonly', TType.STRUCT, 13)
            self.desc_tbl_testonly.write(oprot)
            oprot.writeFieldEnd()
        if self.start_unix_millis is not None:
            oprot.writeFieldBegin('start_unix_millis', TType.I64, 14)
            oprot.writeI64(self.start_unix_millis)
            oprot.writeFieldEnd()
        if self.disable_codegen_hint is not None:
            oprot.writeFieldBegin('disable_codegen_hint', TType.BOOL, 15)
            oprot.writeBool(self.disable_codegen_hint)
            oprot.writeFieldEnd()
        if self.tables_missing_diskids is not None:
            oprot.writeFieldBegin('tables_missing_diskids', TType.LIST, 16)
            oprot.writeListBegin(TType.STRUCT, len(self.tables_missing_diskids))
            for iter20 in self.tables_missing_diskids:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.request_pool is not None:
            oprot.writeFieldBegin('request_pool', TType.STRING, 17)
            oprot.writeString(self.request_pool.encode('utf-8') if sys.version_info[0] == 2 else self.request_pool)
            oprot.writeFieldEnd()
        if self.utc_timestamp_string is not None:
            oprot.writeFieldBegin('utc_timestamp_string', TType.STRING, 18)
            oprot.writeString(self.utc_timestamp_string.encode('utf-8') if sys.version_info[0] == 2 else self.utc_timestamp_string)
            oprot.writeFieldEnd()
        if self.local_time_zone is not None:
            oprot.writeFieldBegin('local_time_zone', TType.STRING, 19)
            oprot.writeString(self.local_time_zone.encode('utf-8') if sys.version_info[0] == 2 else self.local_time_zone)
            oprot.writeFieldEnd()
        if self.disable_hbase_num_rows_estimate is not None:
            oprot.writeFieldBegin('disable_hbase_num_rows_estimate', TType.BOOL, 20)
            oprot.writeBool(self.disable_hbase_num_rows_estimate)
            oprot.writeFieldEnd()
        if self.trace_resource_usage is not None:
            oprot.writeFieldBegin('trace_resource_usage', TType.BOOL, 21)
            oprot.writeBool(self.trace_resource_usage)
            oprot.writeFieldEnd()
        if self.status_report_interval_ms is not None:
            oprot.writeFieldBegin('status_report_interval_ms', TType.I32, 22)
            oprot.writeI32(self.status_report_interval_ms)
            oprot.writeFieldEnd()
        if self.status_report_max_retry_s is not None:
            oprot.writeFieldBegin('status_report_max_retry_s', TType.I32, 23)
            oprot.writeI32(self.status_report_max_retry_s)
            oprot.writeFieldEnd()
        if self.desc_tbl_serialized is not None:
            oprot.writeFieldBegin('desc_tbl_serialized', TType.STRUCT, 24)
            self.desc_tbl_serialized.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction_id is not None:
            oprot.writeFieldBegin('transaction_id', TType.I64, 25)
            oprot.writeI64(self.transaction_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.client_request is None:
            raise TProtocolException(message='Required field client_request is unset!')
        if self.query_id is None:
            raise TProtocolException(message='Required field query_id is unset!')
        if self.session is None:
            raise TProtocolException(message='Required field session is unset!')
        if self.now_string is None:
            raise TProtocolException(message='Required field now_string is unset!')
        if self.pid is None:
            raise TProtocolException(message='Required field pid is unset!')
        if self.start_unix_millis is None:
            raise TProtocolException(message='Required field start_unix_millis is unset!')
        if self.utc_timestamp_string is None:
            raise TProtocolException(message='Required field utc_timestamp_string is unset!')
        if self.local_time_zone is None:
            raise TProtocolException(message='Required field local_time_zone is unset!')
        if self.trace_resource_usage is None:
            raise TProtocolException(message='Required field trace_resource_usage is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanFragmentDestination(object):
    """
    Attributes:
     - fragment_instance_id
     - thrift_backend
     - krpc_backend
    """


    def __init__(self, fragment_instance_id=None, thrift_backend=None, krpc_backend=None,):
        self.fragment_instance_id = fragment_instance_id
        self.thrift_backend = thrift_backend
        self.krpc_backend = krpc_backend

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragment_instance_id = Types.ttypes.TUniqueId()
                    self.fragment_instance_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.thrift_backend = Types.ttypes.TNetworkAddress()
                    self.thrift_backend.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.krpc_backend = Types.ttypes.TNetworkAddress()
                    self.krpc_backend.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanFragmentDestination')
        if self.fragment_instance_id is not None:
            oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 1)
            self.fragment_instance_id.write(oprot)
            oprot.writeFieldEnd()
        if self.thrift_backend is not None:
            oprot.writeFieldBegin('thrift_backend', TType.STRUCT, 2)
            self.thrift_backend.write(oprot)
            oprot.writeFieldEnd()
        if self.krpc_backend is not None:
            oprot.writeFieldBegin('krpc_backend', TType.STRUCT, 3)
            self.krpc_backend.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragment_instance_id is None:
            raise TProtocolException(message='Required field fragment_instance_id is unset!')
        if self.thrift_backend is None:
            raise TProtocolException(message='Required field thrift_backend is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanFragmentCtx(object):
    """
    Attributes:
     - fragment
     - destinations
    """


    def __init__(self, fragment=None, destinations=None,):
        self.fragment = fragment
        self.destinations = destinations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragment = Planner.ttypes.TPlanFragment()
                    self.fragment.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.destinations = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TPlanFragmentDestination()
                        _elem26.read(iprot)
                        self.destinations.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanFragmentCtx')
        if self.fragment is not None:
            oprot.writeFieldBegin('fragment', TType.STRUCT, 1)
            self.fragment.write(oprot)
            oprot.writeFieldEnd()
        if self.destinations is not None:
            oprot.writeFieldBegin('destinations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.destinations))
            for iter27 in self.destinations:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragment is None:
            raise TProtocolException(message='Required field fragment is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TScanRangeParams(object):
    """
    Attributes:
     - scan_range
     - volume_id
     - try_hdfs_cache
     - is_remote
    """


    def __init__(self, scan_range=None, volume_id=-1, try_hdfs_cache=False, is_remote=None,):
        self.scan_range = scan_range
        self.volume_id = volume_id
        self.try_hdfs_cache = try_hdfs_cache
        self.is_remote = is_remote

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scan_range = PlanNodes.ttypes.TScanRange()
                    self.scan_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.volume_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.try_hdfs_cache = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_remote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TScanRangeParams')
        if self.scan_range is not None:
            oprot.writeFieldBegin('scan_range', TType.STRUCT, 1)
            self.scan_range.write(oprot)
            oprot.writeFieldEnd()
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.I32, 2)
            oprot.writeI32(self.volume_id)
            oprot.writeFieldEnd()
        if self.try_hdfs_cache is not None:
            oprot.writeFieldBegin('try_hdfs_cache', TType.BOOL, 3)
            oprot.writeBool(self.try_hdfs_cache)
            oprot.writeFieldEnd()
        if self.is_remote is not None:
            oprot.writeFieldBegin('is_remote', TType.BOOL, 4)
            oprot.writeBool(self.is_remote)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.scan_range is None:
            raise TProtocolException(message='Required field scan_range is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeFilterSource(object):
    """
    Attributes:
     - src_node_id
     - filter_id
    """


    def __init__(self, src_node_id=None, filter_id=None,):
        self.src_node_id = src_node_id
        self.filter_id = filter_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.filter_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterSource')
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 1)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.filter_id is not None:
            oprot.writeFieldBegin('filter_id', TType.I32, 2)
            oprot.writeI32(self.filter_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.src_node_id is None:
            raise TProtocolException(message='Required field src_node_id is unset!')
        if self.filter_id is None:
            raise TProtocolException(message='Required field filter_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJoinBuildInput(object):
    """
    Attributes:
     - join_node_id
     - input_finstance_id
    """


    def __init__(self, join_node_id=None, input_finstance_id=None,):
        self.join_node_id = join_node_id
        self.input_finstance_id = input_finstance_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.join_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.input_finstance_id = Types.ttypes.TUniqueId()
                    self.input_finstance_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJoinBuildInput')
        if self.join_node_id is not None:
            oprot.writeFieldBegin('join_node_id', TType.I32, 1)
            oprot.writeI32(self.join_node_id)
            oprot.writeFieldEnd()
        if self.input_finstance_id is not None:
            oprot.writeFieldBegin('input_finstance_id', TType.STRUCT, 2)
            self.input_finstance_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.join_node_id is None:
            raise TProtocolException(message='Required field join_node_id is unset!')
        if self.input_finstance_id is None:
            raise TProtocolException(message='Required field input_finstance_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanFragmentInstanceCtx(object):
    """
    Attributes:
     - fragment_idx
     - fragment_instance_id
     - per_fragment_instance_idx
     - per_node_scan_ranges
     - per_exch_num_senders
     - sender_id
     - debug_options
     - filters_produced
     - join_build_inputs
     - num_join_build_outputs
    """


    def __init__(self, fragment_idx=None, fragment_instance_id=None, per_fragment_instance_idx=None, per_node_scan_ranges=None, per_exch_num_senders=None, sender_id=None, debug_options=None, filters_produced=None, join_build_inputs=None, num_join_build_outputs=None,):
        self.fragment_idx = fragment_idx
        self.fragment_instance_id = fragment_instance_id
        self.per_fragment_instance_idx = per_fragment_instance_idx
        self.per_node_scan_ranges = per_node_scan_ranges
        self.per_exch_num_senders = per_exch_num_senders
        self.sender_id = sender_id
        self.debug_options = debug_options
        self.filters_produced = filters_produced
        self.join_build_inputs = join_build_inputs
        self.num_join_build_outputs = num_join_build_outputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.fragment_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.fragment_instance_id = Types.ttypes.TUniqueId()
                    self.fragment_instance_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.per_fragment_instance_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.per_node_scan_ranges = {}
                    (_ktype29, _vtype30, _size28) = iprot.readMapBegin()
                    for _i32 in range(_size28):
                        _key33 = iprot.readI32()
                        _val34 = []
                        (_etype38, _size35) = iprot.readListBegin()
                        for _i39 in range(_size35):
                            _elem40 = TScanRangeParams()
                            _elem40.read(iprot)
                            _val34.append(_elem40)
                        iprot.readListEnd()
                        self.per_node_scan_ranges[_key33] = _val34
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.per_exch_num_senders = {}
                    (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                    for _i45 in range(_size41):
                        _key46 = iprot.readI32()
                        _val47 = iprot.readI32()
                        self.per_exch_num_senders[_key46] = _val47
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sender_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.debug_options = TDebugOptions()
                    self.debug_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.filters_produced = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = TRuntimeFilterSource()
                        _elem53.read(iprot)
                        self.filters_produced.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.join_build_inputs = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = TJoinBuildInput()
                        _elem59.read(iprot)
                        self.join_build_inputs.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.num_join_build_outputs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanFragmentInstanceCtx')
        if self.fragment_idx is not None:
            oprot.writeFieldBegin('fragment_idx', TType.I32, 1)
            oprot.writeI32(self.fragment_idx)
            oprot.writeFieldEnd()
        if self.fragment_instance_id is not None:
            oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
            self.fragment_instance_id.write(oprot)
            oprot.writeFieldEnd()
        if self.per_fragment_instance_idx is not None:
            oprot.writeFieldBegin('per_fragment_instance_idx', TType.I32, 3)
            oprot.writeI32(self.per_fragment_instance_idx)
            oprot.writeFieldEnd()
        if self.per_node_scan_ranges is not None:
            oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
            for kiter60, viter61 in self.per_node_scan_ranges.items():
                oprot.writeI32(kiter60)
                oprot.writeListBegin(TType.STRUCT, len(viter61))
                for iter62 in viter61:
                    iter62.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.per_exch_num_senders is not None:
            oprot.writeFieldBegin('per_exch_num_senders', TType.MAP, 5)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.per_exch_num_senders))
            for kiter63, viter64 in self.per_exch_num_senders.items():
                oprot.writeI32(kiter63)
                oprot.writeI32(viter64)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.sender_id is not None:
            oprot.writeFieldBegin('sender_id', TType.I32, 6)
            oprot.writeI32(self.sender_id)
            oprot.writeFieldEnd()
        if self.debug_options is not None:
            oprot.writeFieldBegin('debug_options', TType.STRUCT, 7)
            self.debug_options.write(oprot)
            oprot.writeFieldEnd()
        if self.filters_produced is not None:
            oprot.writeFieldBegin('filters_produced', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.filters_produced))
            for iter65 in self.filters_produced:
                iter65.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.join_build_inputs is not None:
            oprot.writeFieldBegin('join_build_inputs', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.join_build_inputs))
            for iter66 in self.join_build_inputs:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_join_build_outputs is not None:
            oprot.writeFieldBegin('num_join_build_outputs', TType.I32, 10)
            oprot.writeI32(self.num_join_build_outputs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragment_idx is None:
            raise TProtocolException(message='Required field fragment_idx is unset!')
        if self.fragment_instance_id is None:
            raise TProtocolException(message='Required field fragment_instance_id is unset!')
        if self.per_fragment_instance_idx is None:
            raise TProtocolException(message='Required field per_fragment_instance_idx is unset!')
        if self.per_node_scan_ranges is None:
            raise TProtocolException(message='Required field per_node_scan_ranges is unset!')
        if self.per_exch_num_senders is None:
            raise TProtocolException(message='Required field per_exch_num_senders is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecPlanFragmentInfo(object):
    """
    Attributes:
     - fragment_ctxs
     - fragment_instance_ctxs
    """


    def __init__(self, fragment_ctxs=None, fragment_instance_ctxs=None,):
        self.fragment_ctxs = fragment_ctxs
        self.fragment_instance_ctxs = fragment_instance_ctxs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fragment_ctxs = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = TPlanFragmentCtx()
                        _elem72.read(iprot)
                        self.fragment_ctxs.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fragment_instance_ctxs = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = TPlanFragmentInstanceCtx()
                        _elem78.read(iprot)
                        self.fragment_instance_ctxs.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecPlanFragmentInfo')
        if self.fragment_ctxs is not None:
            oprot.writeFieldBegin('fragment_ctxs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fragment_ctxs))
            for iter79 in self.fragment_ctxs:
                iter79.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fragment_instance_ctxs is not None:
            oprot.writeFieldBegin('fragment_instance_ctxs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fragment_instance_ctxs))
            for iter80 in self.fragment_instance_ctxs:
                iter80.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResolveRequestPoolParams(object):
    """
    Attributes:
     - user
     - requested_pool
    """


    def __init__(self, user=None, requested_pool=None,):
        self.user = user
        self.requested_pool = requested_pool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.requested_pool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResolveRequestPoolParams')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.requested_pool is not None:
            oprot.writeFieldBegin('requested_pool', TType.STRING, 2)
            oprot.writeString(self.requested_pool.encode('utf-8') if sys.version_info[0] == 2 else self.requested_pool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.requested_pool is None:
            raise TProtocolException(message='Required field requested_pool is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResolveRequestPoolResult(object):
    """
    Attributes:
     - resolved_pool
     - has_access
     - status
    """


    def __init__(self, resolved_pool=None, has_access=None, status=None,):
        self.resolved_pool = resolved_pool
        self.has_access = has_access
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.resolved_pool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_access = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResolveRequestPoolResult')
        if self.resolved_pool is not None:
            oprot.writeFieldBegin('resolved_pool', TType.STRING, 1)
            oprot.writeString(self.resolved_pool.encode('utf-8') if sys.version_info[0] == 2 else self.resolved_pool)
            oprot.writeFieldEnd()
        if self.has_access is not None:
            oprot.writeFieldBegin('has_access', TType.BOOL, 2)
            oprot.writeBool(self.has_access)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPoolConfigParams(object):
    """
    Attributes:
     - pool
    """


    def __init__(self, pool=None,):
        self.pool = pool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolConfigParams')
        if self.pool is not None:
            oprot.writeFieldBegin('pool', TType.STRING, 1)
            oprot.writeString(self.pool.encode('utf-8') if sys.version_info[0] == 2 else self.pool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pool is None:
            raise TProtocolException(message='Required field pool is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPoolConfig(object):
    """
    Attributes:
     - max_requests
     - max_queued
     - max_mem_resources
     - queue_timeout_ms
     - default_query_options
     - max_query_mem_limit
     - min_query_mem_limit
     - clamp_mem_limit_query_option
     - max_running_queries_multiple
     - max_queued_queries_multiple
     - max_memory_multiple
    """


    def __init__(self, max_requests=None, max_queued=None, max_mem_resources=None, queue_timeout_ms=None, default_query_options=None, max_query_mem_limit=0, min_query_mem_limit=0, clamp_mem_limit_query_option=True, max_running_queries_multiple=0, max_queued_queries_multiple=0, max_memory_multiple=0,):
        self.max_requests = max_requests
        self.max_queued = max_queued
        self.max_mem_resources = max_mem_resources
        self.queue_timeout_ms = queue_timeout_ms
        self.default_query_options = default_query_options
        self.max_query_mem_limit = max_query_mem_limit
        self.min_query_mem_limit = min_query_mem_limit
        self.clamp_mem_limit_query_option = clamp_mem_limit_query_option
        self.max_running_queries_multiple = max_running_queries_multiple
        self.max_queued_queries_multiple = max_queued_queries_multiple
        self.max_memory_multiple = max_memory_multiple

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.max_requests = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_queued = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.max_mem_resources = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.queue_timeout_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.default_query_options = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_query_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.min_query_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.clamp_mem_limit_query_option = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.max_running_queries_multiple = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.max_queued_queries_multiple = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.max_memory_multiple = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolConfig')
        if self.max_requests is not None:
            oprot.writeFieldBegin('max_requests', TType.I64, 1)
            oprot.writeI64(self.max_requests)
            oprot.writeFieldEnd()
        if self.max_queued is not None:
            oprot.writeFieldBegin('max_queued', TType.I64, 2)
            oprot.writeI64(self.max_queued)
            oprot.writeFieldEnd()
        if self.max_mem_resources is not None:
            oprot.writeFieldBegin('max_mem_resources', TType.I64, 3)
            oprot.writeI64(self.max_mem_resources)
            oprot.writeFieldEnd()
        if self.queue_timeout_ms is not None:
            oprot.writeFieldBegin('queue_timeout_ms', TType.I64, 4)
            oprot.writeI64(self.queue_timeout_ms)
            oprot.writeFieldEnd()
        if self.default_query_options is not None:
            oprot.writeFieldBegin('default_query_options', TType.STRING, 5)
            oprot.writeString(self.default_query_options.encode('utf-8') if sys.version_info[0] == 2 else self.default_query_options)
            oprot.writeFieldEnd()
        if self.max_query_mem_limit is not None:
            oprot.writeFieldBegin('max_query_mem_limit', TType.I64, 6)
            oprot.writeI64(self.max_query_mem_limit)
            oprot.writeFieldEnd()
        if self.min_query_mem_limit is not None:
            oprot.writeFieldBegin('min_query_mem_limit', TType.I64, 7)
            oprot.writeI64(self.min_query_mem_limit)
            oprot.writeFieldEnd()
        if self.clamp_mem_limit_query_option is not None:
            oprot.writeFieldBegin('clamp_mem_limit_query_option', TType.BOOL, 8)
            oprot.writeBool(self.clamp_mem_limit_query_option)
            oprot.writeFieldEnd()
        if self.max_running_queries_multiple is not None:
            oprot.writeFieldBegin('max_running_queries_multiple', TType.DOUBLE, 9)
            oprot.writeDouble(self.max_running_queries_multiple)
            oprot.writeFieldEnd()
        if self.max_queued_queries_multiple is not None:
            oprot.writeFieldBegin('max_queued_queries_multiple', TType.DOUBLE, 10)
            oprot.writeDouble(self.max_queued_queries_multiple)
            oprot.writeFieldEnd()
        if self.max_memory_multiple is not None:
            oprot.writeFieldBegin('max_memory_multiple', TType.I64, 11)
            oprot.writeI64(self.max_memory_multiple)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.max_requests is None:
            raise TProtocolException(message='Required field max_requests is unset!')
        if self.max_queued is None:
            raise TProtocolException(message='Required field max_queued is unset!')
        if self.max_mem_resources is None:
            raise TProtocolException(message='Required field max_mem_resources is unset!')
        if self.default_query_options is None:
            raise TProtocolException(message='Required field default_query_options is unset!')
        if self.max_query_mem_limit is None:
            raise TProtocolException(message='Required field max_query_mem_limit is unset!')
        if self.min_query_mem_limit is None:
            raise TProtocolException(message='Required field min_query_mem_limit is unset!')
        if self.clamp_mem_limit_query_option is None:
            raise TProtocolException(message='Required field clamp_mem_limit_query_option is unset!')
        if self.max_running_queries_multiple is None:
            raise TProtocolException(message='Required field max_running_queries_multiple is unset!')
        if self.max_queued_queries_multiple is None:
            raise TProtocolException(message='Required field max_queued_queries_multiple is unset!')
        if self.max_memory_multiple is None:
            raise TProtocolException(message='Required field max_memory_multiple is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TParseDateStringResult(object):
    """
    Attributes:
     - valid
     - days_since_epoch
     - canonical_date_string
    """


    def __init__(self, valid=None, days_since_epoch=None, canonical_date_string=None,):
        self.valid = valid
        self.days_since_epoch = days_since_epoch
        self.canonical_date_string = canonical_date_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.valid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.days_since_epoch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.canonical_date_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TParseDateStringResult')
        if self.valid is not None:
            oprot.writeFieldBegin('valid', TType.BOOL, 1)
            oprot.writeBool(self.valid)
            oprot.writeFieldEnd()
        if self.days_since_epoch is not None:
            oprot.writeFieldBegin('days_since_epoch', TType.I32, 2)
            oprot.writeI32(self.days_since_epoch)
            oprot.writeFieldEnd()
        if self.canonical_date_string is not None:
            oprot.writeFieldBegin('canonical_date_string', TType.STRING, 3)
            oprot.writeString(self.canonical_date_string.encode('utf-8') if sys.version_info[0] == 2 else self.canonical_date_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.valid is None:
            raise TProtocolException(message='Required field valid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TQueryOptions)
TQueryOptions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'abort_on_error', None, False, ),  # 1
    (2, TType.I32, 'max_errors', None, 100, ),  # 2
    (3, TType.BOOL, 'disable_codegen', None, False, ),  # 3
    (4, TType.I32, 'batch_size', None, 0, ),  # 4
    (5, TType.I32, 'num_nodes', None, 0, ),  # 5
    (6, TType.I64, 'max_scan_range_length', None, 0, ),  # 6
    (7, TType.I32, 'num_scanner_threads', None, 0, ),  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    (11, TType.STRING, 'debug_action', 'UTF8', "", ),  # 11
    (12, TType.I64, 'mem_limit', None, 0, ),  # 12
    None,  # 13
    (14, TType.STRUCT, 'compression_codec', [CatalogObjects.ttypes.TCompressionCodec, None], None, ),  # 14
    (15, TType.I32, 'hbase_caching', None, 0, ),  # 15
    (16, TType.BOOL, 'hbase_cache_blocks', None, False, ),  # 16
    (17, TType.I64, 'parquet_file_size', None, 0, ),  # 17
    (18, TType.I32, 'explain_level', None, 1, ),  # 18
    (19, TType.BOOL, 'sync_ddl', None, False, ),  # 19
    (20, TType.STRING, 'request_pool', 'UTF8', None, ),  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    (24, TType.BOOL, 'disable_outermost_topn', None, False, ),  # 24
    None,  # 25
    (26, TType.I32, 'query_timeout_s', None, 0, ),  # 26
    (27, TType.I64, 'buffer_pool_limit', None, None, ),  # 27
    (28, TType.BOOL, 'appx_count_distinct', None, False, ),  # 28
    (29, TType.BOOL, 'disable_unsafe_spills', None, False, ),  # 29
    None,  # 30
    (31, TType.I32, 'exec_single_node_rows_threshold', None, 100, ),  # 31
    (32, TType.BOOL, 'optimize_partition_key_scans', None, False, ),  # 32
    (33, TType.I32, 'replica_preference', None, 0, ),  # 33
    (34, TType.BOOL, 'schedule_random_replica', None, False, ),  # 34
    None,  # 35
    (36, TType.BOOL, 'disable_streaming_preaggregations', None, False, ),  # 36
    (37, TType.I32, 'runtime_filter_mode', None, 2, ),  # 37
    (38, TType.I32, 'runtime_bloom_filter_size', None, 1048576, ),  # 38
    (39, TType.I32, 'runtime_filter_wait_time_ms', None, 0, ),  # 39
    (40, TType.BOOL, 'disable_row_runtime_filtering', None, False, ),  # 40
    (41, TType.I32, 'max_num_runtime_filters', None, 10, ),  # 41
    (42, TType.BOOL, 'parquet_annotate_strings_utf8', None, False, ),  # 42
    (43, TType.I32, 'parquet_fallback_schema_resolution', None, 0, ),  # 43
    (44, TType.I32, 'mt_dop', None, None, ),  # 44
    (45, TType.BOOL, 's3_skip_insert_staging', None, True, ),  # 45
    (46, TType.I32, 'runtime_filter_min_size', None, 1048576, ),  # 46
    (47, TType.I32, 'runtime_filter_max_size', None, 16777216, ),  # 47
    (48, TType.I32, 'prefetch_mode', None, 1, ),  # 48
    (49, TType.BOOL, 'strict_mode', None, False, ),  # 49
    (50, TType.I64, 'scratch_limit', None, -1, ),  # 50
    (51, TType.BOOL, 'enable_expr_rewrites', None, True, ),  # 51
    (52, TType.BOOL, 'decimal_v2', None, True, ),  # 52
    (53, TType.BOOL, 'parquet_dictionary_filtering', None, True, ),  # 53
    (54, TType.I32, 'parquet_array_resolution', None, 0, ),  # 54
    (55, TType.BOOL, 'parquet_read_statistics', None, True, ),  # 55
    (56, TType.I32, 'default_join_distribution_mode', None, 0, ),  # 56
    (57, TType.I32, 'disable_codegen_rows_threshold', None, 50000, ),  # 57
    (58, TType.I64, 'default_spillable_buffer_size', None, 2097152, ),  # 58
    (59, TType.I64, 'min_spillable_buffer_size', None, 65536, ),  # 59
    (60, TType.I64, 'max_row_size', None, 524288, ),  # 60
    (61, TType.I32, 'idle_session_timeout', None, None, ),  # 61
    (62, TType.I64, 'compute_stats_min_sample_size', None, 1073741824, ),  # 62
    (63, TType.I32, 'exec_time_limit_s', None, 0, ),  # 63
    (64, TType.BOOL, 'shuffle_distinct_exprs', None, True, ),  # 64
    (65, TType.I64, 'max_mem_estimate_for_admission', None, 0, ),  # 65
    (66, TType.I32, 'thread_reservation_limit', None, 3000, ),  # 66
    (67, TType.I32, 'thread_reservation_aggregate_limit', None, 0, ),  # 67
    (68, TType.I32, 'kudu_read_mode', None, 0, ),  # 68
    (69, TType.BOOL, 'allow_erasure_coded_files', None, False, ),  # 69
    (70, TType.STRING, 'timezone', 'UTF8', "", ),  # 70
    (71, TType.I64, 'scan_bytes_limit', None, 0, ),  # 71
    (72, TType.I64, 'cpu_limit_s', None, 0, ),  # 72
    (73, TType.I64, 'topn_bytes_limit', None, 536870912, ),  # 73
    (74, TType.STRING, 'client_identifier', 'UTF8', None, ),  # 74
    (75, TType.DOUBLE, 'resource_trace_ratio', None, 0, ),  # 75
    (76, TType.I32, 'num_remote_executor_candidates', None, 3, ),  # 76
    (77, TType.I64, 'num_rows_produced_limit', None, 0, ),  # 77
    (78, TType.BOOL, 'planner_testcase_mode', None, False, ),  # 78
    (79, TType.I32, 'default_file_format', None, 0, ),  # 79
    (80, TType.I32, 'parquet_timestamp_type', None, 0, ),  # 80
    (81, TType.BOOL, 'parquet_read_page_index', None, True, ),  # 81
    (82, TType.BOOL, 'parquet_write_page_index', None, True, ),  # 82
    (83, TType.I32, 'parquet_page_row_count_limit', None, None, ),  # 83
    (84, TType.BOOL, 'disable_hdfs_num_rows_estimate', None, False, ),  # 84
    (85, TType.STRING, 'default_hints_insert_statement', 'UTF8', None, ),  # 85
    (86, TType.BOOL, 'spool_query_results', None, False, ),  # 86
    (87, TType.I32, 'default_transactional_type', None, 0, ),  # 87
    (88, TType.I32, 'statement_expression_limit', None, 250000, ),  # 88
    (89, TType.I32, 'max_statement_length_bytes', None, 16777216, ),  # 89
    (90, TType.BOOL, 'disable_data_cache', None, False, ),  # 90
    (91, TType.I64, 'max_result_spooling_mem', None, 104857600, ),  # 91
    (92, TType.I64, 'max_spilled_result_spooling_mem', None, 1073741824, ),  # 92
    (93, TType.BOOL, 'disable_hbase_num_rows_estimate', None, False, ),  # 93
    (94, TType.I64, 'fetch_rows_timeout_ms', None, 10000, ),  # 94
    (95, TType.STRING, 'now_string', 'UTF8', "", ),  # 95
    (96, TType.I64, 'parquet_object_store_split_size', None, 268435456, ),  # 96
    (97, TType.I64, 'mem_limit_executors', None, 0, ),  # 97
    (98, TType.I64, 'broadcast_bytes_limit', None, 34359738368, ),  # 98
    (99, TType.I64, 'preagg_bytes_limit', None, -1, ),  # 99
    (100, TType.BOOL, 'enable_cnf_rewrites', None, True, ),  # 100
    (101, TType.I32, 'max_cnf_exprs', None, 0, ),  # 101
    (102, TType.I64, 'kudu_snapshot_read_timestamp_micros', None, 0, ),  # 102
)
all_structs.append(TSessionState)
TSessionState.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'connected_user', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'session_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.STRUCT, 'network_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 4
    (5, TType.I32, 'session_type', None, None, ),  # 5
    (6, TType.STRING, 'delegated_user', 'UTF8', None, ),  # 6
    (7, TType.I64, 'kudu_latest_observed_ts', None, None, ),  # 7
)
all_structs.append(TClientRequest)
TClientRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'stmt', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'query_options', [TQueryOptions, None], None, ),  # 2
    (3, TType.STRING, 'redacted_stmt', 'UTF8', None, ),  # 3
)
all_structs.append(TDebugOptions)
TDebugOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'phase', None, None, ),  # 2
    (3, TType.I32, 'action', None, None, ),  # 3
    (4, TType.STRING, 'action_param', 'UTF8', None, ),  # 4
)
all_structs.append(TQueryCtx)
TQueryCtx.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'client_request', [TClientRequest, None], None, ),  # 1
    (2, TType.STRUCT, 'query_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRUCT, 'session', [TSessionState, None], None, ),  # 3
    (4, TType.STRING, 'now_string', 'UTF8', None, ),  # 4
    (5, TType.I32, 'pid', None, None, ),  # 5
    (6, TType.STRUCT, 'coord_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 6
    (7, TType.STRUCT, 'coord_krpc_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 7
    (8, TType.LIST, 'tables_missing_stats', (TType.STRUCT, [CatalogObjects.ttypes.TTableName, None], False), None, ),  # 8
    (9, TType.BOOL, 'disable_spilling', None, None, ),  # 9
    (10, TType.STRUCT, 'parent_query_id', [Types.ttypes.TUniqueId, None], None, ),  # 10
    (11, TType.LIST, 'tables_with_corrupt_stats', (TType.STRUCT, [CatalogObjects.ttypes.TTableName, None], False), None, ),  # 11
    (12, TType.I64, 'snapshot_timestamp', None, -1, ),  # 12
    (13, TType.STRUCT, 'desc_tbl_testonly', [Descriptors.ttypes.TDescriptorTable, None], None, ),  # 13
    (14, TType.I64, 'start_unix_millis', None, None, ),  # 14
    (15, TType.BOOL, 'disable_codegen_hint', None, False, ),  # 15
    (16, TType.LIST, 'tables_missing_diskids', (TType.STRUCT, [CatalogObjects.ttypes.TTableName, None], False), None, ),  # 16
    (17, TType.STRING, 'request_pool', 'UTF8', None, ),  # 17
    (18, TType.STRING, 'utc_timestamp_string', 'UTF8', None, ),  # 18
    (19, TType.STRING, 'local_time_zone', 'UTF8', None, ),  # 19
    (20, TType.BOOL, 'disable_hbase_num_rows_estimate', None, False, ),  # 20
    (21, TType.BOOL, 'trace_resource_usage', None, False, ),  # 21
    (22, TType.I32, 'status_report_interval_ms', None, None, ),  # 22
    (23, TType.I32, 'status_report_max_retry_s', None, None, ),  # 23
    (24, TType.STRUCT, 'desc_tbl_serialized', [Descriptors.ttypes.TDescriptorTableSerialized, None], None, ),  # 24
    (25, TType.I64, 'transaction_id', None, None, ),  # 25
)
all_structs.append(TPlanFragmentDestination)
TPlanFragmentDestination.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragment_instance_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.STRUCT, 'thrift_backend', [Types.ttypes.TNetworkAddress, None], None, ),  # 2
    (3, TType.STRUCT, 'krpc_backend', [Types.ttypes.TNetworkAddress, None], None, ),  # 3
)
all_structs.append(TPlanFragmentCtx)
TPlanFragmentCtx.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragment', [Planner.ttypes.TPlanFragment, None], None, ),  # 1
    (2, TType.LIST, 'destinations', (TType.STRUCT, [TPlanFragmentDestination, None], False), None, ),  # 2
)
all_structs.append(TScanRangeParams)
TScanRangeParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scan_range', [PlanNodes.ttypes.TScanRange, None], None, ),  # 1
    (2, TType.I32, 'volume_id', None, -1, ),  # 2
    (3, TType.BOOL, 'try_hdfs_cache', None, False, ),  # 3
    (4, TType.BOOL, 'is_remote', None, None, ),  # 4
)
all_structs.append(TRuntimeFilterSource)
TRuntimeFilterSource.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'src_node_id', None, None, ),  # 1
    (2, TType.I32, 'filter_id', None, None, ),  # 2
)
all_structs.append(TJoinBuildInput)
TJoinBuildInput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'join_node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'input_finstance_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
)
all_structs.append(TPlanFragmentInstanceCtx)
TPlanFragmentInstanceCtx.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'fragment_idx', None, None, ),  # 1
    (2, TType.STRUCT, 'fragment_instance_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.I32, 'per_fragment_instance_idx', None, None, ),  # 3
    (4, TType.MAP, 'per_node_scan_ranges', (TType.I32, None, TType.LIST, (TType.STRUCT, [TScanRangeParams, None], False), False), None, ),  # 4
    (5, TType.MAP, 'per_exch_num_senders', (TType.I32, None, TType.I32, None, False), None, ),  # 5
    (6, TType.I32, 'sender_id', None, None, ),  # 6
    (7, TType.STRUCT, 'debug_options', [TDebugOptions, None], None, ),  # 7
    (8, TType.LIST, 'filters_produced', (TType.STRUCT, [TRuntimeFilterSource, None], False), None, ),  # 8
    (9, TType.LIST, 'join_build_inputs', (TType.STRUCT, [TJoinBuildInput, None], False), None, ),  # 9
    (10, TType.I32, 'num_join_build_outputs', None, None, ),  # 10
)
all_structs.append(TExecPlanFragmentInfo)
TExecPlanFragmentInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fragment_ctxs', (TType.STRUCT, [TPlanFragmentCtx, None], False), None, ),  # 1
    (2, TType.LIST, 'fragment_instance_ctxs', (TType.STRUCT, [TPlanFragmentInstanceCtx, None], False), None, ),  # 2
)
all_structs.append(TResolveRequestPoolParams)
TResolveRequestPoolParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'requested_pool', 'UTF8', None, ),  # 2
)
all_structs.append(TResolveRequestPoolResult)
TResolveRequestPoolResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'resolved_pool', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'has_access', None, None, ),  # 2
    (3, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 3
)
all_structs.append(TPoolConfigParams)
TPoolConfigParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool', 'UTF8', None, ),  # 1
)
all_structs.append(TPoolConfig)
TPoolConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'max_requests', None, None, ),  # 1
    (2, TType.I64, 'max_queued', None, None, ),  # 2
    (3, TType.I64, 'max_mem_resources', None, None, ),  # 3
    (4, TType.I64, 'queue_timeout_ms', None, None, ),  # 4
    (5, TType.STRING, 'default_query_options', 'UTF8', None, ),  # 5
    (6, TType.I64, 'max_query_mem_limit', None, 0, ),  # 6
    (7, TType.I64, 'min_query_mem_limit', None, 0, ),  # 7
    (8, TType.BOOL, 'clamp_mem_limit_query_option', None, True, ),  # 8
    (9, TType.DOUBLE, 'max_running_queries_multiple', None, 0, ),  # 9
    (10, TType.DOUBLE, 'max_queued_queries_multiple', None, 0, ),  # 10
    (11, TType.I64, 'max_memory_multiple', None, 0, ),  # 11
)
all_structs.append(TParseDateStringResult)
TParseDateStringResult.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'valid', None, None, ),  # 1
    (2, TType.I32, 'days_since_epoch', None, None, ),  # 2
    (3, TType.STRING, 'canonical_date_string', 'UTF8', None, ),  # 3
)
fix_spec(all_structs)
del all_structs
