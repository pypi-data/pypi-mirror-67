#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import ExecStats.ttypes
import Exprs.ttypes
import Types.ttypes
import Descriptors.ttypes
import Partitions.ttypes
import PlanNodes.ttypes
import ResourceProfile.ttypes

from thrift.transport import TTransport
all_structs = []


class TDataSinkType(object):
    DATA_STREAM_SINK = 0
    TABLE_SINK = 1
    HASH_JOIN_BUILDER = 2
    PLAN_ROOT_SINK = 3
    NESTED_LOOP_JOIN_BUILDER = 4

    _VALUES_TO_NAMES = {
        0: "DATA_STREAM_SINK",
        1: "TABLE_SINK",
        2: "HASH_JOIN_BUILDER",
        3: "PLAN_ROOT_SINK",
        4: "NESTED_LOOP_JOIN_BUILDER",
    }

    _NAMES_TO_VALUES = {
        "DATA_STREAM_SINK": 0,
        "TABLE_SINK": 1,
        "HASH_JOIN_BUILDER": 2,
        "PLAN_ROOT_SINK": 3,
        "NESTED_LOOP_JOIN_BUILDER": 4,
    }


class TSinkAction(object):
    INSERT = 0
    UPDATE = 1
    UPSERT = 2
    DELETE = 3

    _VALUES_TO_NAMES = {
        0: "INSERT",
        1: "UPDATE",
        2: "UPSERT",
        3: "DELETE",
    }

    _NAMES_TO_VALUES = {
        "INSERT": 0,
        "UPDATE": 1,
        "UPSERT": 2,
        "DELETE": 3,
    }


class TTableSinkType(object):
    HDFS = 0
    HBASE = 1
    KUDU = 2

    _VALUES_TO_NAMES = {
        0: "HDFS",
        1: "HBASE",
        2: "KUDU",
    }

    _NAMES_TO_VALUES = {
        "HDFS": 0,
        "HBASE": 1,
        "KUDU": 2,
    }


class TDataStreamSink(object):
    """
    Attributes:
     - dest_node_id
     - output_partition
    """


    def __init__(self, dest_node_id=None, output_partition=None,):
        self.dest_node_id = dest_node_id
        self.output_partition = output_partition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.output_partition = Partitions.ttypes.TDataPartition()
                    self.output_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataStreamSink')
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 1)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.output_partition is not None:
            oprot.writeFieldBegin('output_partition', TType.STRUCT, 2)
            self.output_partition.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dest_node_id is None:
            raise TProtocolException(message='Required field dest_node_id is unset!')
        if self.output_partition is None:
            raise TProtocolException(message='Required field output_partition is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsTableSink(object):
    """
    Attributes:
     - partition_key_exprs
     - overwrite
     - skip_header_line_count
     - input_is_clustered
     - sort_columns
     - write_id
     - sorting_order
    """


    def __init__(self, partition_key_exprs=None, overwrite=None, skip_header_line_count=None, input_is_clustered=None, sort_columns=None, write_id=None, sorting_order=None,):
        self.partition_key_exprs = partition_key_exprs
        self.overwrite = overwrite
        self.skip_header_line_count = skip_header_line_count
        self.input_is_clustered = input_is_clustered
        self.sort_columns = sort_columns
        self.write_id = write_id
        self.sorting_order = sorting_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_key_exprs = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Exprs.ttypes.TExpr()
                        _elem5.read(iprot)
                        self.partition_key_exprs.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.skip_header_line_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.input_is_clustered = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.sort_columns = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.sort_columns.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsTableSink')
        if self.partition_key_exprs is not None:
            oprot.writeFieldBegin('partition_key_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_key_exprs))
            for iter12 in self.partition_key_exprs:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.overwrite is not None:
            oprot.writeFieldBegin('overwrite', TType.BOOL, 2)
            oprot.writeBool(self.overwrite)
            oprot.writeFieldEnd()
        if self.skip_header_line_count is not None:
            oprot.writeFieldBegin('skip_header_line_count', TType.I32, 3)
            oprot.writeI32(self.skip_header_line_count)
            oprot.writeFieldEnd()
        if self.input_is_clustered is not None:
            oprot.writeFieldBegin('input_is_clustered', TType.BOOL, 4)
            oprot.writeBool(self.input_is_clustered)
            oprot.writeFieldEnd()
        if self.sort_columns is not None:
            oprot.writeFieldBegin('sort_columns', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.sort_columns))
            for iter13 in self.sort_columns:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 6)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 7)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_key_exprs is None:
            raise TProtocolException(message='Required field partition_key_exprs is unset!')
        if self.overwrite is None:
            raise TProtocolException(message='Required field overwrite is unset!')
        if self.input_is_clustered is None:
            raise TProtocolException(message='Required field input_is_clustered is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduTableSink(object):
    """
    Attributes:
     - referenced_columns
     - ignore_not_found_or_duplicate
    """


    def __init__(self, referenced_columns=None, ignore_not_found_or_duplicate=None,):
        self.referenced_columns = referenced_columns
        self.ignore_not_found_or_duplicate = ignore_not_found_or_duplicate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.referenced_columns = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.referenced_columns.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ignore_not_found_or_duplicate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduTableSink')
        if self.referenced_columns is not None:
            oprot.writeFieldBegin('referenced_columns', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.referenced_columns))
            for iter20 in self.referenced_columns:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ignore_not_found_or_duplicate is not None:
            oprot.writeFieldBegin('ignore_not_found_or_duplicate', TType.BOOL, 2)
            oprot.writeBool(self.ignore_not_found_or_duplicate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJoinBuildSink(object):
    """
    Attributes:
     - dest_node_id
     - join_op
     - eq_join_conjuncts
     - runtime_filters
     - hash_seed
     - share_build
    """


    def __init__(self, dest_node_id=None, join_op=None, eq_join_conjuncts=None, runtime_filters=None, hash_seed=None, share_build=None,):
        self.dest_node_id = dest_node_id
        self.join_op = join_op
        self.eq_join_conjuncts = eq_join_conjuncts
        self.runtime_filters = runtime_filters
        self.hash_seed = hash_seed
        self.share_build = share_build

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.join_op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.eq_join_conjuncts = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = PlanNodes.ttypes.TEqJoinCondition()
                        _elem26.read(iprot)
                        self.eq_join_conjuncts.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.runtime_filters = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = PlanNodes.ttypes.TRuntimeFilterDesc()
                        _elem32.read(iprot)
                        self.runtime_filters.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.hash_seed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.share_build = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJoinBuildSink')
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 1)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.join_op is not None:
            oprot.writeFieldBegin('join_op', TType.I32, 2)
            oprot.writeI32(self.join_op)
            oprot.writeFieldEnd()
        if self.eq_join_conjuncts is not None:
            oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
            for iter33 in self.eq_join_conjuncts:
                iter33.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runtime_filters is not None:
            oprot.writeFieldBegin('runtime_filters', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.runtime_filters))
            for iter34 in self.runtime_filters:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hash_seed is not None:
            oprot.writeFieldBegin('hash_seed', TType.I32, 5)
            oprot.writeI32(self.hash_seed)
            oprot.writeFieldEnd()
        if self.share_build is not None:
            oprot.writeFieldBegin('share_build', TType.BOOL, 6)
            oprot.writeBool(self.share_build)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dest_node_id is None:
            raise TProtocolException(message='Required field dest_node_id is unset!')
        if self.join_op is None:
            raise TProtocolException(message='Required field join_op is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanRootSink(object):
    """
    Attributes:
     - resource_profile
    """


    def __init__(self, resource_profile=None,):
        self.resource_profile = resource_profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanRootSink')
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 1)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.resource_profile is None:
            raise TProtocolException(message='Required field resource_profile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableSink(object):
    """
    Attributes:
     - target_table_id
     - type
     - action
     - hdfs_table_sink
     - kudu_table_sink
    """


    def __init__(self, target_table_id=None, type=None, action=None, hdfs_table_sink=None, kudu_table_sink=None,):
        self.target_table_id = target_table_id
        self.type = type
        self.action = action
        self.hdfs_table_sink = hdfs_table_sink
        self.kudu_table_sink = kudu_table_sink

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.target_table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.action = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.hdfs_table_sink = THdfsTableSink()
                    self.hdfs_table_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.kudu_table_sink = TKuduTableSink()
                    self.kudu_table_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableSink')
        if self.target_table_id is not None:
            oprot.writeFieldBegin('target_table_id', TType.I32, 1)
            oprot.writeI32(self.target_table_id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.I32, 3)
            oprot.writeI32(self.action)
            oprot.writeFieldEnd()
        if self.hdfs_table_sink is not None:
            oprot.writeFieldBegin('hdfs_table_sink', TType.STRUCT, 4)
            self.hdfs_table_sink.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_table_sink is not None:
            oprot.writeFieldBegin('kudu_table_sink', TType.STRUCT, 5)
            self.kudu_table_sink.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target_table_id is None:
            raise TProtocolException(message='Required field target_table_id is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.action is None:
            raise TProtocolException(message='Required field action is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSink(object):
    """
    Attributes:
     - type
     - stream_sink
     - table_sink
     - join_build_sink
     - plan_root_sink
     - label
     - estimated_stats
     - output_exprs
     - resource_profile
    """


    def __init__(self, type=None, stream_sink=None, table_sink=None, join_build_sink=None, plan_root_sink=None, label=None, estimated_stats=None, output_exprs=None, resource_profile=None,):
        self.type = type
        self.stream_sink = stream_sink
        self.table_sink = table_sink
        self.join_build_sink = join_build_sink
        self.plan_root_sink = plan_root_sink
        self.label = label
        self.estimated_stats = estimated_stats
        self.output_exprs = output_exprs
        self.resource_profile = resource_profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.stream_sink = TDataStreamSink()
                    self.stream_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table_sink = TTableSink()
                    self.table_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.join_build_sink = TJoinBuildSink()
                    self.join_build_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.plan_root_sink = TPlanRootSink()
                    self.plan_root_sink.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.estimated_stats = ExecStats.ttypes.TExecStats()
                    self.estimated_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.output_exprs = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = Exprs.ttypes.TExpr()
                        _elem40.read(iprot)
                        self.output_exprs.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSink')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.stream_sink is not None:
            oprot.writeFieldBegin('stream_sink', TType.STRUCT, 2)
            self.stream_sink.write(oprot)
            oprot.writeFieldEnd()
        if self.table_sink is not None:
            oprot.writeFieldBegin('table_sink', TType.STRUCT, 3)
            self.table_sink.write(oprot)
            oprot.writeFieldEnd()
        if self.join_build_sink is not None:
            oprot.writeFieldBegin('join_build_sink', TType.STRUCT, 4)
            self.join_build_sink.write(oprot)
            oprot.writeFieldEnd()
        if self.plan_root_sink is not None:
            oprot.writeFieldBegin('plan_root_sink', TType.STRUCT, 5)
            self.plan_root_sink.write(oprot)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 6)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.estimated_stats is not None:
            oprot.writeFieldBegin('estimated_stats', TType.STRUCT, 7)
            self.estimated_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.output_exprs is not None:
            oprot.writeFieldBegin('output_exprs', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.output_exprs))
            for iter41 in self.output_exprs:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 9)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TDataStreamSink)
TDataStreamSink.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dest_node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'output_partition', [Partitions.ttypes.TDataPartition, None], None, ),  # 2
)
all_structs.append(THdfsTableSink)
THdfsTableSink.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_key_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.BOOL, 'overwrite', None, None, ),  # 2
    (3, TType.I32, 'skip_header_line_count', None, None, ),  # 3
    (4, TType.BOOL, 'input_is_clustered', None, None, ),  # 4
    (5, TType.LIST, 'sort_columns', (TType.I32, None, False), None, ),  # 5
    (6, TType.I64, 'write_id', None, None, ),  # 6
    (7, TType.I32, 'sorting_order', None, None, ),  # 7
)
all_structs.append(TKuduTableSink)
TKuduTableSink.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'referenced_columns', (TType.I32, None, False), None, ),  # 1
    (2, TType.BOOL, 'ignore_not_found_or_duplicate', None, None, ),  # 2
)
all_structs.append(TJoinBuildSink)
TJoinBuildSink.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dest_node_id', None, None, ),  # 1
    (2, TType.I32, 'join_op', None, None, ),  # 2
    (3, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT, [PlanNodes.ttypes.TEqJoinCondition, None], False), None, ),  # 3
    (4, TType.LIST, 'runtime_filters', (TType.STRUCT, [PlanNodes.ttypes.TRuntimeFilterDesc, None], False), None, ),  # 4
    (5, TType.I32, 'hash_seed', None, None, ),  # 5
    (6, TType.BOOL, 'share_build', None, None, ),  # 6
)
all_structs.append(TPlanRootSink)
TPlanRootSink.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 1
)
all_structs.append(TTableSink)
TTableSink.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'target_table_id', None, None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I32, 'action', None, None, ),  # 3
    (4, TType.STRUCT, 'hdfs_table_sink', [THdfsTableSink, None], None, ),  # 4
    (5, TType.STRUCT, 'kudu_table_sink', [TKuduTableSink, None], None, ),  # 5
)
all_structs.append(TDataSink)
TDataSink.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'stream_sink', [TDataStreamSink, None], None, ),  # 2
    (3, TType.STRUCT, 'table_sink', [TTableSink, None], None, ),  # 3
    (4, TType.STRUCT, 'join_build_sink', [TJoinBuildSink, None], None, ),  # 4
    (5, TType.STRUCT, 'plan_root_sink', [TPlanRootSink, None], None, ),  # 5
    (6, TType.STRING, 'label', 'UTF8', None, ),  # 6
    (7, TType.STRUCT, 'estimated_stats', [ExecStats.ttypes.TExecStats, None], None, ),  # 7
    (8, TType.LIST, 'output_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 8
    (9, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 9
)
fix_spec(all_structs)
del all_structs
