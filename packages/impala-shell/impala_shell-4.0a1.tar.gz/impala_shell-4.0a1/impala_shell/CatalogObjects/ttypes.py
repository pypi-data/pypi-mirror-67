#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Exprs.ttypes
import Status.ttypes
import Types.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes

from thrift.transport import TTransport
all_structs = []


class TCatalogObjectType(object):
    UNKNOWN = 0
    CATALOG = 1
    DATABASE = 2
    TABLE = 3
    VIEW = 4
    FUNCTION = 5
    DATA_SOURCE = 6
    PRINCIPAL = 7
    PRIVILEGE = 8
    HDFS_CACHE_POOL = 9
    AUTHZ_CACHE_INVALIDATION = 10

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "CATALOG",
        2: "DATABASE",
        3: "TABLE",
        4: "VIEW",
        5: "FUNCTION",
        6: "DATA_SOURCE",
        7: "PRINCIPAL",
        8: "PRIVILEGE",
        9: "HDFS_CACHE_POOL",
        10: "AUTHZ_CACHE_INVALIDATION",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "CATALOG": 1,
        "DATABASE": 2,
        "TABLE": 3,
        "VIEW": 4,
        "FUNCTION": 5,
        "DATA_SOURCE": 6,
        "PRINCIPAL": 7,
        "PRIVILEGE": 8,
        "HDFS_CACHE_POOL": 9,
        "AUTHZ_CACHE_INVALIDATION": 10,
    }


class TTableType(object):
    HDFS_TABLE = 0
    HBASE_TABLE = 1
    VIEW = 2
    DATA_SOURCE_TABLE = 3
    KUDU_TABLE = 4

    _VALUES_TO_NAMES = {
        0: "HDFS_TABLE",
        1: "HBASE_TABLE",
        2: "VIEW",
        3: "DATA_SOURCE_TABLE",
        4: "KUDU_TABLE",
    }

    _NAMES_TO_VALUES = {
        "HDFS_TABLE": 0,
        "HBASE_TABLE": 1,
        "VIEW": 2,
        "DATA_SOURCE_TABLE": 3,
        "KUDU_TABLE": 4,
    }


class THdfsFileFormat(object):
    TEXT = 0
    RC_FILE = 1
    SEQUENCE_FILE = 2
    AVRO = 3
    PARQUET = 4
    KUDU = 5
    ORC = 6
    HUDI_PARQUET = 7

    _VALUES_TO_NAMES = {
        0: "TEXT",
        1: "RC_FILE",
        2: "SEQUENCE_FILE",
        3: "AVRO",
        4: "PARQUET",
        5: "KUDU",
        6: "ORC",
        7: "HUDI_PARQUET",
    }

    _NAMES_TO_VALUES = {
        "TEXT": 0,
        "RC_FILE": 1,
        "SEQUENCE_FILE": 2,
        "AVRO": 3,
        "PARQUET": 4,
        "KUDU": 5,
        "ORC": 6,
        "HUDI_PARQUET": 7,
    }


class THdfsCompression(object):
    NONE = 0
    DEFAULT = 1
    GZIP = 2
    DEFLATE = 3
    BZIP2 = 4
    SNAPPY = 5
    SNAPPY_BLOCKED = 6
    LZO = 7
    LZ4 = 8
    ZLIB = 9
    ZSTD = 10
    BROTLI = 11
    LZ4_BLOCKED = 12

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "DEFAULT",
        2: "GZIP",
        3: "DEFLATE",
        4: "BZIP2",
        5: "SNAPPY",
        6: "SNAPPY_BLOCKED",
        7: "LZO",
        8: "LZ4",
        9: "ZLIB",
        10: "ZSTD",
        11: "BROTLI",
        12: "LZ4_BLOCKED",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "DEFAULT": 1,
        "GZIP": 2,
        "DEFLATE": 3,
        "BZIP2": 4,
        "SNAPPY": 5,
        "SNAPPY_BLOCKED": 6,
        "LZO": 7,
        "LZ4": 8,
        "ZLIB": 9,
        "ZSTD": 10,
        "BROTLI": 11,
        "LZ4_BLOCKED": 12,
    }


class TColumnEncoding(object):
    AUTO = 0
    PLAIN = 1
    PREFIX = 2
    GROUP_VARINT = 3
    RLE = 4
    DICTIONARY = 5
    BIT_SHUFFLE = 6

    _VALUES_TO_NAMES = {
        0: "AUTO",
        1: "PLAIN",
        2: "PREFIX",
        3: "GROUP_VARINT",
        4: "RLE",
        5: "DICTIONARY",
        6: "BIT_SHUFFLE",
    }

    _NAMES_TO_VALUES = {
        "AUTO": 0,
        "PLAIN": 1,
        "PREFIX": 2,
        "GROUP_VARINT": 3,
        "RLE": 4,
        "DICTIONARY": 5,
        "BIT_SHUFFLE": 6,
    }


class THdfsSeqCompressionMode(object):
    RECORD = 0
    BLOCK = 1

    _VALUES_TO_NAMES = {
        0: "RECORD",
        1: "BLOCK",
    }

    _NAMES_TO_VALUES = {
        "RECORD": 0,
        "BLOCK": 1,
    }


class TTablePropertyType(object):
    TBL_PROPERTY = 0
    SERDE_PROPERTY = 1

    _VALUES_TO_NAMES = {
        0: "TBL_PROPERTY",
        1: "SERDE_PROPERTY",
    }

    _NAMES_TO_VALUES = {
        "TBL_PROPERTY": 0,
        "SERDE_PROPERTY": 1,
    }


class TAccessLevel(object):
    NONE = 0
    READ_WRITE = 1
    READ_ONLY = 2
    WRITE_ONLY = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "READ_WRITE",
        2: "READ_ONLY",
        3: "WRITE_ONLY",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "READ_WRITE": 1,
        "READ_ONLY": 2,
        "WRITE_ONLY": 3,
    }


class TPrincipalType(object):
    ROLE = 0
    USER = 1
    GROUP = 2

    _VALUES_TO_NAMES = {
        0: "ROLE",
        1: "USER",
        2: "GROUP",
    }

    _NAMES_TO_VALUES = {
        "ROLE": 0,
        "USER": 1,
        "GROUP": 2,
    }


class TPrivilegeScope(object):
    SERVER = 0
    URI = 1
    DATABASE = 2
    TABLE = 3
    COLUMN = 4

    _VALUES_TO_NAMES = {
        0: "SERVER",
        1: "URI",
        2: "DATABASE",
        3: "TABLE",
        4: "COLUMN",
    }

    _NAMES_TO_VALUES = {
        "SERVER": 0,
        "URI": 1,
        "DATABASE": 2,
        "TABLE": 3,
        "COLUMN": 4,
    }


class TPrivilegeLevel(object):
    ALL = 0
    INSERT = 1
    SELECT = 2
    REFRESH = 3
    CREATE = 4
    ALTER = 5
    DROP = 6
    OWNER = 7

    _VALUES_TO_NAMES = {
        0: "ALL",
        1: "INSERT",
        2: "SELECT",
        3: "REFRESH",
        4: "CREATE",
        5: "ALTER",
        6: "DROP",
        7: "OWNER",
    }

    _NAMES_TO_VALUES = {
        "ALL": 0,
        "INSERT": 1,
        "SELECT": 2,
        "REFRESH": 3,
        "CREATE": 4,
        "ALTER": 5,
        "DROP": 6,
        "OWNER": 7,
    }


class TCompressionCodec(object):
    """
    Attributes:
     - codec
     - compression_level
    """


    def __init__(self, codec=None, compression_level=None,):
        self.codec = codec
        self.compression_level = compression_level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.codec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.compression_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCompressionCodec')
        if self.codec is not None:
            oprot.writeFieldBegin('codec', TType.I32, 1)
            oprot.writeI32(self.codec)
            oprot.writeFieldEnd()
        if self.compression_level is not None:
            oprot.writeFieldBegin('compression_level', TType.I32, 2)
            oprot.writeI32(self.compression_level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.codec is None:
            raise TProtocolException(message='Required field codec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionKeyValue(object):
    """
    Attributes:
     - name
     - value
    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionKeyValue')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableName(object):
    """
    Attributes:
     - db_name
     - table_name
    """


    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableName')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableStats(object):
    """
    Attributes:
     - num_rows
     - total_file_bytes
    """


    def __init__(self, num_rows=None, total_file_bytes=None,):
        self.num_rows = num_rows
        self.total_file_bytes = total_file_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.total_file_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableStats')
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 1)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.total_file_bytes is not None:
            oprot.writeFieldBegin('total_file_bytes', TType.I64, 2)
            oprot.writeI64(self.total_file_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnStats(object):
    """
    Attributes:
     - avg_size
     - max_size
     - num_distinct_values
     - num_nulls
    """


    def __init__(self, avg_size=None, max_size=None, num_distinct_values=None, num_nulls=None,):
        self.avg_size = avg_size
        self.max_size = max_size
        self.num_distinct_values = num_distinct_values
        self.num_nulls = num_nulls

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.avg_size = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_distinct_values = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_nulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnStats')
        if self.avg_size is not None:
            oprot.writeFieldBegin('avg_size', TType.DOUBLE, 1)
            oprot.writeDouble(self.avg_size)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I64, 2)
            oprot.writeI64(self.max_size)
            oprot.writeFieldEnd()
        if self.num_distinct_values is not None:
            oprot.writeFieldBegin('num_distinct_values', TType.I64, 3)
            oprot.writeI64(self.num_distinct_values)
            oprot.writeFieldEnd()
        if self.num_nulls is not None:
            oprot.writeFieldBegin('num_nulls', TType.I64, 4)
            oprot.writeI64(self.num_nulls)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.avg_size is None:
            raise TProtocolException(message='Required field avg_size is unset!')
        if self.max_size is None:
            raise TProtocolException(message='Required field max_size is unset!')
        if self.num_distinct_values is None:
            raise TProtocolException(message='Required field num_distinct_values is unset!')
        if self.num_nulls is None:
            raise TProtocolException(message='Required field num_nulls is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIntermediateColumnStats(object):
    """
    Attributes:
     - intermediate_ndv
     - is_ndv_encoded
     - num_nulls
     - max_width
     - avg_width
     - num_rows
    """


    def __init__(self, intermediate_ndv=None, is_ndv_encoded=None, num_nulls=None, max_width=None, avg_width=None, num_rows=None,):
        self.intermediate_ndv = intermediate_ndv
        self.is_ndv_encoded = is_ndv_encoded
        self.num_nulls = num_nulls
        self.max_width = max_width
        self.avg_width = avg_width
        self.num_rows = num_rows

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.intermediate_ndv = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_ndv_encoded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_nulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.avg_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIntermediateColumnStats')
        if self.intermediate_ndv is not None:
            oprot.writeFieldBegin('intermediate_ndv', TType.STRING, 1)
            oprot.writeBinary(self.intermediate_ndv)
            oprot.writeFieldEnd()
        if self.is_ndv_encoded is not None:
            oprot.writeFieldBegin('is_ndv_encoded', TType.BOOL, 2)
            oprot.writeBool(self.is_ndv_encoded)
            oprot.writeFieldEnd()
        if self.num_nulls is not None:
            oprot.writeFieldBegin('num_nulls', TType.I64, 3)
            oprot.writeI64(self.num_nulls)
            oprot.writeFieldEnd()
        if self.max_width is not None:
            oprot.writeFieldBegin('max_width', TType.I32, 4)
            oprot.writeI32(self.max_width)
            oprot.writeFieldEnd()
        if self.avg_width is not None:
            oprot.writeFieldBegin('avg_width', TType.DOUBLE, 5)
            oprot.writeDouble(self.avg_width)
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 6)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionStats(object):
    """
    Attributes:
     - stats
     - intermediate_col_stats
    """


    def __init__(self, stats=None, intermediate_col_stats=None,):
        self.stats = stats
        self.intermediate_col_stats = intermediate_col_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats = TTableStats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.intermediate_col_stats = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = TIntermediateColumnStats()
                        _val6.read(iprot)
                        self.intermediate_col_stats[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionStats')
        if self.stats is not None:
            oprot.writeFieldBegin('stats', TType.STRUCT, 1)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        if self.intermediate_col_stats is not None:
            oprot.writeFieldBegin('intermediate_col_stats', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.intermediate_col_stats))
            for kiter7, viter8 in self.intermediate_col_stats.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                viter8.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stats is None:
            raise TProtocolException(message='Required field stats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumn(object):
    """
    Attributes:
     - columnName
     - columnType
     - comment
     - col_stats
     - position
     - is_hbase_column
     - column_family
     - column_qualifier
     - is_binary
     - is_kudu_column
     - is_key
     - is_nullable
     - encoding
     - compression
     - default_value
     - block_size
     - kudu_column_name
    """


    def __init__(self, columnName=None, columnType=None, comment=None, col_stats=None, position=None, is_hbase_column=None, column_family=None, column_qualifier=None, is_binary=None, is_kudu_column=None, is_key=None, is_nullable=None, encoding=None, compression=None, default_value=None, block_size=None, kudu_column_name=None,):
        self.columnName = columnName
        self.columnType = columnType
        self.comment = comment
        self.col_stats = col_stats
        self.position = position
        self.is_hbase_column = is_hbase_column
        self.column_family = column_family
        self.column_qualifier = column_qualifier
        self.is_binary = is_binary
        self.is_kudu_column = is_kudu_column
        self.is_key = is_key
        self.is_nullable = is_nullable
        self.encoding = encoding
        self.compression = compression
        self.default_value = default_value
        self.block_size = block_size
        self.kudu_column_name = kudu_column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.columnType = Types.ttypes.TColumnType()
                    self.columnType.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.col_stats = TColumnStats()
                    self.col_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_hbase_column = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.column_family = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.column_qualifier = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.is_binary = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.is_kudu_column = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_key = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.is_nullable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.compression = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.default_value = Exprs.ttypes.TExpr()
                    self.default_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.block_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.kudu_column_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumn')
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 1)
            oprot.writeString(self.columnName.encode('utf-8') if sys.version_info[0] == 2 else self.columnName)
            oprot.writeFieldEnd()
        if self.columnType is not None:
            oprot.writeFieldBegin('columnType', TType.STRUCT, 2)
            self.columnType.write(oprot)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 3)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.col_stats is not None:
            oprot.writeFieldBegin('col_stats', TType.STRUCT, 4)
            self.col_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.I32, 5)
            oprot.writeI32(self.position)
            oprot.writeFieldEnd()
        if self.is_hbase_column is not None:
            oprot.writeFieldBegin('is_hbase_column', TType.BOOL, 6)
            oprot.writeBool(self.is_hbase_column)
            oprot.writeFieldEnd()
        if self.column_family is not None:
            oprot.writeFieldBegin('column_family', TType.STRING, 7)
            oprot.writeString(self.column_family.encode('utf-8') if sys.version_info[0] == 2 else self.column_family)
            oprot.writeFieldEnd()
        if self.column_qualifier is not None:
            oprot.writeFieldBegin('column_qualifier', TType.STRING, 8)
            oprot.writeString(self.column_qualifier.encode('utf-8') if sys.version_info[0] == 2 else self.column_qualifier)
            oprot.writeFieldEnd()
        if self.is_binary is not None:
            oprot.writeFieldBegin('is_binary', TType.BOOL, 9)
            oprot.writeBool(self.is_binary)
            oprot.writeFieldEnd()
        if self.is_kudu_column is not None:
            oprot.writeFieldBegin('is_kudu_column', TType.BOOL, 10)
            oprot.writeBool(self.is_kudu_column)
            oprot.writeFieldEnd()
        if self.is_key is not None:
            oprot.writeFieldBegin('is_key', TType.BOOL, 11)
            oprot.writeBool(self.is_key)
            oprot.writeFieldEnd()
        if self.is_nullable is not None:
            oprot.writeFieldBegin('is_nullable', TType.BOOL, 12)
            oprot.writeBool(self.is_nullable)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 13)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.compression is not None:
            oprot.writeFieldBegin('compression', TType.I32, 14)
            oprot.writeI32(self.compression)
            oprot.writeFieldEnd()
        if self.default_value is not None:
            oprot.writeFieldBegin('default_value', TType.STRUCT, 15)
            self.default_value.write(oprot)
            oprot.writeFieldEnd()
        if self.block_size is not None:
            oprot.writeFieldBegin('block_size', TType.I32, 16)
            oprot.writeI32(self.block_size)
            oprot.writeFieldEnd()
        if self.kudu_column_name is not None:
            oprot.writeFieldBegin('kudu_column_name', TType.STRING, 17)
            oprot.writeString(self.kudu_column_name.encode('utf-8') if sys.version_info[0] == 2 else self.kudu_column_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columnName is None:
            raise TProtocolException(message='Required field columnName is unset!')
        if self.columnType is None:
            raise TProtocolException(message='Required field columnType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsFileDesc(object):
    """
    Attributes:
     - file_desc_data
    """


    def __init__(self, file_desc_data=None,):
        self.file_desc_data = file_desc_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_desc_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsFileDesc')
        if self.file_desc_data is not None:
            oprot.writeFieldBegin('file_desc_data', TType.STRING, 1)
            oprot.writeBinary(self.file_desc_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_desc_data is None:
            raise TProtocolException(message='Required field file_desc_data is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsPartitionLocation(object):
    """
    Attributes:
     - prefix_index
     - suffix
    """


    def __init__(self, prefix_index=-1, suffix=None,):
        self.prefix_index = prefix_index
        self.suffix = suffix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.prefix_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.suffix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsPartitionLocation')
        if self.prefix_index is not None:
            oprot.writeFieldBegin('prefix_index', TType.I32, 1)
            oprot.writeI32(self.prefix_index)
            oprot.writeFieldEnd()
        if self.suffix is not None:
            oprot.writeFieldBegin('suffix', TType.STRING, 2)
            oprot.writeString(self.suffix.encode('utf-8') if sys.version_info[0] == 2 else self.suffix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefix_index is None:
            raise TProtocolException(message='Required field prefix_index is unset!')
        if self.suffix is None:
            raise TProtocolException(message='Required field suffix is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsPartition(object):
    """
    Attributes:
     - lineDelim
     - fieldDelim
     - collectionDelim
     - mapKeyDelim
     - escapeChar
     - fileFormat
     - partitionKeyExprs
     - blockSize
     - location
     - id
     - file_desc
     - access_level
     - stats
     - is_marked_cached
     - hms_parameters
     - num_blocks
     - total_file_size_bytes
     - partition_stats
     - has_incremental_stats
     - write_id
    """


    def __init__(self, lineDelim=None, fieldDelim=None, collectionDelim=None, mapKeyDelim=None, escapeChar=None, fileFormat=None, partitionKeyExprs=None, blockSize=None, location=None, id=None, file_desc=None, access_level=None, stats=None, is_marked_cached=None, hms_parameters=None, num_blocks=None, total_file_size_bytes=None, partition_stats=None, has_incremental_stats=None, write_id=None,):
        self.lineDelim = lineDelim
        self.fieldDelim = fieldDelim
        self.collectionDelim = collectionDelim
        self.mapKeyDelim = mapKeyDelim
        self.escapeChar = escapeChar
        self.fileFormat = fileFormat
        self.partitionKeyExprs = partitionKeyExprs
        self.blockSize = blockSize
        self.location = location
        self.id = id
        self.file_desc = file_desc
        self.access_level = access_level
        self.stats = stats
        self.is_marked_cached = is_marked_cached
        self.hms_parameters = hms_parameters
        self.num_blocks = num_blocks
        self.total_file_size_bytes = total_file_size_bytes
        self.partition_stats = partition_stats
        self.has_incremental_stats = has_incremental_stats
        self.write_id = write_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.lineDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.fieldDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.collectionDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.mapKeyDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.escapeChar = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.fileFormat = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.partitionKeyExprs = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = Exprs.ttypes.TExpr()
                        _elem14.read(iprot)
                        self.partitionKeyExprs.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.blockSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.location = THdfsPartitionLocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.file_desc = []
                    (_etype18, _size15) = iprot.readListBegin()
                    for _i19 in range(_size15):
                        _elem20 = THdfsFileDesc()
                        _elem20.read(iprot)
                        self.file_desc.append(_elem20)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.access_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.stats = TTableStats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.is_marked_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.MAP:
                    self.hms_parameters = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val27 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.hms_parameters[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.num_blocks = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.total_file_size_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.partition_stats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.has_incremental_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsPartition')
        if self.lineDelim is not None:
            oprot.writeFieldBegin('lineDelim', TType.BYTE, 1)
            oprot.writeByte(self.lineDelim)
            oprot.writeFieldEnd()
        if self.fieldDelim is not None:
            oprot.writeFieldBegin('fieldDelim', TType.BYTE, 2)
            oprot.writeByte(self.fieldDelim)
            oprot.writeFieldEnd()
        if self.collectionDelim is not None:
            oprot.writeFieldBegin('collectionDelim', TType.BYTE, 3)
            oprot.writeByte(self.collectionDelim)
            oprot.writeFieldEnd()
        if self.mapKeyDelim is not None:
            oprot.writeFieldBegin('mapKeyDelim', TType.BYTE, 4)
            oprot.writeByte(self.mapKeyDelim)
            oprot.writeFieldEnd()
        if self.escapeChar is not None:
            oprot.writeFieldBegin('escapeChar', TType.BYTE, 5)
            oprot.writeByte(self.escapeChar)
            oprot.writeFieldEnd()
        if self.fileFormat is not None:
            oprot.writeFieldBegin('fileFormat', TType.I32, 6)
            oprot.writeI32(self.fileFormat)
            oprot.writeFieldEnd()
        if self.partitionKeyExprs is not None:
            oprot.writeFieldBegin('partitionKeyExprs', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionKeyExprs))
            for iter28 in self.partitionKeyExprs:
                iter28.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.blockSize is not None:
            oprot.writeFieldBegin('blockSize', TType.I32, 8)
            oprot.writeI32(self.blockSize)
            oprot.writeFieldEnd()
        if self.file_desc is not None:
            oprot.writeFieldBegin('file_desc', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.file_desc))
            for iter29 in self.file_desc:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 10)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.access_level is not None:
            oprot.writeFieldBegin('access_level', TType.I32, 11)
            oprot.writeI32(self.access_level)
            oprot.writeFieldEnd()
        if self.stats is not None:
            oprot.writeFieldBegin('stats', TType.STRUCT, 12)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        if self.is_marked_cached is not None:
            oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 13)
            oprot.writeBool(self.is_marked_cached)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 14)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.hms_parameters is not None:
            oprot.writeFieldBegin('hms_parameters', TType.MAP, 15)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.hms_parameters))
            for kiter30, viter31 in self.hms_parameters.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                oprot.writeString(viter31.encode('utf-8') if sys.version_info[0] == 2 else viter31)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.num_blocks is not None:
            oprot.writeFieldBegin('num_blocks', TType.I64, 16)
            oprot.writeI64(self.num_blocks)
            oprot.writeFieldEnd()
        if self.total_file_size_bytes is not None:
            oprot.writeFieldBegin('total_file_size_bytes', TType.I64, 17)
            oprot.writeI64(self.total_file_size_bytes)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.STRING, 18)
            oprot.writeBinary(self.partition_stats)
            oprot.writeFieldEnd()
        if self.has_incremental_stats is not None:
            oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 19)
            oprot.writeBool(self.has_incremental_stats)
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 20)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineDelim is None:
            raise TProtocolException(message='Required field lineDelim is unset!')
        if self.fieldDelim is None:
            raise TProtocolException(message='Required field fieldDelim is unset!')
        if self.collectionDelim is None:
            raise TProtocolException(message='Required field collectionDelim is unset!')
        if self.mapKeyDelim is None:
            raise TProtocolException(message='Required field mapKeyDelim is unset!')
        if self.escapeChar is None:
            raise TProtocolException(message='Required field escapeChar is unset!')
        if self.fileFormat is None:
            raise TProtocolException(message='Required field fileFormat is unset!')
        if self.blockSize is None:
            raise TProtocolException(message='Required field blockSize is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsTable(object):
    """
    Attributes:
     - hdfsBaseDir
     - colNames
     - nullPartitionKeyValue
     - nullColumnValue
     - avroSchema
     - partitions
     - prototype_partition
     - partition_prefixes
     - network_addresses
     - sql_constraints
     - is_full_acid
    """


    def __init__(self, hdfsBaseDir=None, colNames=None, nullPartitionKeyValue=None, nullColumnValue=None, avroSchema=None, partitions=None, prototype_partition=None, partition_prefixes=None, network_addresses=None, sql_constraints=None, is_full_acid=False,):
        self.hdfsBaseDir = hdfsBaseDir
        self.colNames = colNames
        self.nullPartitionKeyValue = nullPartitionKeyValue
        self.nullColumnValue = nullColumnValue
        self.avroSchema = avroSchema
        self.partitions = partitions
        self.prototype_partition = prototype_partition
        self.partition_prefixes = partition_prefixes
        self.network_addresses = network_addresses
        self.sql_constraints = sql_constraints
        self.is_full_acid = is_full_acid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hdfsBaseDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.colNames = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.colNames.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.nullPartitionKeyValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.nullColumnValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.avroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.partitions = {}
                    (_ktype39, _vtype40, _size38) = iprot.readMapBegin()
                    for _i42 in range(_size38):
                        _key43 = iprot.readI64()
                        _val44 = THdfsPartition()
                        _val44.read(iprot)
                        self.partitions[_key43] = _val44
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.prototype_partition = THdfsPartition()
                    self.prototype_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.partition_prefixes = []
                    (_etype48, _size45) = iprot.readListBegin()
                    for _i49 in range(_size45):
                        _elem50 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.partition_prefixes.append(_elem50)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.network_addresses = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = Types.ttypes.TNetworkAddress()
                        _elem56.read(iprot)
                        self.network_addresses.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
                    self.sql_constraints.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.is_full_acid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsTable')
        if self.hdfsBaseDir is not None:
            oprot.writeFieldBegin('hdfsBaseDir', TType.STRING, 1)
            oprot.writeString(self.hdfsBaseDir.encode('utf-8') if sys.version_info[0] == 2 else self.hdfsBaseDir)
            oprot.writeFieldEnd()
        if self.colNames is not None:
            oprot.writeFieldBegin('colNames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.colNames))
            for iter57 in self.colNames:
                oprot.writeString(iter57.encode('utf-8') if sys.version_info[0] == 2 else iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullPartitionKeyValue is not None:
            oprot.writeFieldBegin('nullPartitionKeyValue', TType.STRING, 3)
            oprot.writeString(self.nullPartitionKeyValue.encode('utf-8') if sys.version_info[0] == 2 else self.nullPartitionKeyValue)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.MAP, 4)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.partitions))
            for kiter58, viter59 in self.partitions.items():
                oprot.writeI64(kiter58)
                viter59.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.nullColumnValue is not None:
            oprot.writeFieldBegin('nullColumnValue', TType.STRING, 5)
            oprot.writeString(self.nullColumnValue.encode('utf-8') if sys.version_info[0] == 2 else self.nullColumnValue)
            oprot.writeFieldEnd()
        if self.avroSchema is not None:
            oprot.writeFieldBegin('avroSchema', TType.STRING, 6)
            oprot.writeString(self.avroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.avroSchema)
            oprot.writeFieldEnd()
        if self.network_addresses is not None:
            oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
            for iter60 in self.network_addresses:
                iter60.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_prefixes is not None:
            oprot.writeFieldBegin('partition_prefixes', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.partition_prefixes))
            for iter61 in self.partition_prefixes:
                oprot.writeString(iter61.encode('utf-8') if sys.version_info[0] == 2 else iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.prototype_partition is not None:
            oprot.writeFieldBegin('prototype_partition', TType.STRUCT, 10)
            self.prototype_partition.write(oprot)
            oprot.writeFieldEnd()
        if self.sql_constraints is not None:
            oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 11)
            self.sql_constraints.write(oprot)
            oprot.writeFieldEnd()
        if self.is_full_acid is not None:
            oprot.writeFieldBegin('is_full_acid', TType.BOOL, 12)
            oprot.writeBool(self.is_full_acid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hdfsBaseDir is None:
            raise TProtocolException(message='Required field hdfsBaseDir is unset!')
        if self.colNames is None:
            raise TProtocolException(message='Required field colNames is unset!')
        if self.nullPartitionKeyValue is None:
            raise TProtocolException(message='Required field nullPartitionKeyValue is unset!')
        if self.nullColumnValue is None:
            raise TProtocolException(message='Required field nullColumnValue is unset!')
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        if self.prototype_partition is None:
            raise TProtocolException(message='Required field prototype_partition is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseTable(object):
    """
    Attributes:
     - tableName
     - families
     - qualifiers
     - binary_encoded
    """


    def __init__(self, tableName=None, families=None, qualifiers=None, binary_encoded=None,):
        self.tableName = tableName
        self.families = families
        self.qualifiers = qualifiers
        self.binary_encoded = binary_encoded

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.families = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.families.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.qualifiers = []
                    (_etype71, _size68) = iprot.readListBegin()
                    for _i72 in range(_size68):
                        _elem73 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.qualifiers.append(_elem73)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.binary_encoded = []
                    (_etype77, _size74) = iprot.readListBegin()
                    for _i78 in range(_size74):
                        _elem79 = iprot.readBool()
                        self.binary_encoded.append(_elem79)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseTable')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.families is not None:
            oprot.writeFieldBegin('families', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.families))
            for iter80 in self.families:
                oprot.writeString(iter80.encode('utf-8') if sys.version_info[0] == 2 else iter80)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.qualifiers is not None:
            oprot.writeFieldBegin('qualifiers', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.qualifiers))
            for iter81 in self.qualifiers:
                oprot.writeString(iter81.encode('utf-8') if sys.version_info[0] == 2 else iter81)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.binary_encoded is not None:
            oprot.writeFieldBegin('binary_encoded', TType.LIST, 4)
            oprot.writeListBegin(TType.BOOL, len(self.binary_encoded))
            for iter82 in self.binary_encoded:
                oprot.writeBool(iter82)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.families is None:
            raise TProtocolException(message='Required field families is unset!')
        if self.qualifiers is None:
            raise TProtocolException(message='Required field qualifiers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSource(object):
    """
    Attributes:
     - name
     - hdfs_location
     - class_name
     - api_version
    """


    def __init__(self, name=None, hdfs_location=None, class_name=None, api_version=None,):
        self.name = name
        self.hdfs_location = hdfs_location
        self.class_name = class_name
        self.api_version = api_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hdfs_location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.class_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.api_version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSource')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hdfs_location is not None:
            oprot.writeFieldBegin('hdfs_location', TType.STRING, 2)
            oprot.writeString(self.hdfs_location.encode('utf-8') if sys.version_info[0] == 2 else self.hdfs_location)
            oprot.writeFieldEnd()
        if self.class_name is not None:
            oprot.writeFieldBegin('class_name', TType.STRING, 3)
            oprot.writeString(self.class_name.encode('utf-8') if sys.version_info[0] == 2 else self.class_name)
            oprot.writeFieldEnd()
        if self.api_version is not None:
            oprot.writeFieldBegin('api_version', TType.STRING, 4)
            oprot.writeString(self.api_version.encode('utf-8') if sys.version_info[0] == 2 else self.api_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.hdfs_location is None:
            raise TProtocolException(message='Required field hdfs_location is unset!')
        if self.class_name is None:
            raise TProtocolException(message='Required field class_name is unset!')
        if self.api_version is None:
            raise TProtocolException(message='Required field api_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSourceTable(object):
    """
    Attributes:
     - data_source
     - init_string
    """


    def __init__(self, data_source=None, init_string=None,):
        self.data_source = data_source
        self.init_string = init_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data_source = TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.init_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSourceTable')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.init_string is not None:
            oprot.writeFieldBegin('init_string', TType.STRING, 2)
            oprot.writeString(self.init_string.encode('utf-8') if sys.version_info[0] == 2 else self.init_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        if self.init_string is None:
            raise TProtocolException(message='Required field init_string is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionByHashParam(object):
    """
    Attributes:
     - columns
     - num_partitions
    """


    def __init__(self, columns=None, num_partitions=None,):
        self.columns = columns
        self.num_partitions = num_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_partitions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionByHashParam')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter89 in self.columns:
                oprot.writeString(iter89.encode('utf-8') if sys.version_info[0] == 2 else iter89)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_partitions is not None:
            oprot.writeFieldBegin('num_partitions', TType.I32, 2)
            oprot.writeI32(self.num_partitions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.num_partitions is None:
            raise TProtocolException(message='Required field num_partitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRangePartition(object):
    """
    Attributes:
     - lower_bound_values
     - is_lower_bound_inclusive
     - upper_bound_values
     - is_upper_bound_inclusive
    """


    def __init__(self, lower_bound_values=None, is_lower_bound_inclusive=None, upper_bound_values=None, is_upper_bound_inclusive=None,):
        self.lower_bound_values = lower_bound_values
        self.is_lower_bound_inclusive = is_lower_bound_inclusive
        self.upper_bound_values = upper_bound_values
        self.is_upper_bound_inclusive = is_upper_bound_inclusive

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lower_bound_values = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = Exprs.ttypes.TExpr()
                        _elem95.read(iprot)
                        self.lower_bound_values.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_lower_bound_inclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.upper_bound_values = []
                    (_etype99, _size96) = iprot.readListBegin()
                    for _i100 in range(_size96):
                        _elem101 = Exprs.ttypes.TExpr()
                        _elem101.read(iprot)
                        self.upper_bound_values.append(_elem101)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_upper_bound_inclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRangePartition')
        if self.lower_bound_values is not None:
            oprot.writeFieldBegin('lower_bound_values', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.lower_bound_values))
            for iter102 in self.lower_bound_values:
                iter102.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_lower_bound_inclusive is not None:
            oprot.writeFieldBegin('is_lower_bound_inclusive', TType.BOOL, 2)
            oprot.writeBool(self.is_lower_bound_inclusive)
            oprot.writeFieldEnd()
        if self.upper_bound_values is not None:
            oprot.writeFieldBegin('upper_bound_values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.upper_bound_values))
            for iter103 in self.upper_bound_values:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_upper_bound_inclusive is not None:
            oprot.writeFieldBegin('is_upper_bound_inclusive', TType.BOOL, 4)
            oprot.writeBool(self.is_upper_bound_inclusive)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionByRangeParam(object):
    """
    Attributes:
     - columns
     - range_partitions
    """


    def __init__(self, columns=None, range_partitions=None,):
        self.columns = columns
        self.range_partitions = range_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_partitions = []
                    (_etype113, _size110) = iprot.readListBegin()
                    for _i114 in range(_size110):
                        _elem115 = TRangePartition()
                        _elem115.read(iprot)
                        self.range_partitions.append(_elem115)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionByRangeParam')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter116 in self.columns:
                oprot.writeString(iter116.encode('utf-8') if sys.version_info[0] == 2 else iter116)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_partitions is not None:
            oprot.writeFieldBegin('range_partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.range_partitions))
            for iter117 in self.range_partitions:
                iter117.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionParam(object):
    """
    Attributes:
     - by_hash_param
     - by_range_param
    """


    def __init__(self, by_hash_param=None, by_range_param=None,):
        self.by_hash_param = by_hash_param
        self.by_range_param = by_range_param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.by_hash_param = TKuduPartitionByHashParam()
                    self.by_hash_param.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.by_range_param = TKuduPartitionByRangeParam()
                    self.by_range_param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionParam')
        if self.by_hash_param is not None:
            oprot.writeFieldBegin('by_hash_param', TType.STRUCT, 1)
            self.by_hash_param.write(oprot)
            oprot.writeFieldEnd()
        if self.by_range_param is not None:
            oprot.writeFieldBegin('by_range_param', TType.STRUCT, 2)
            self.by_range_param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduTable(object):
    """
    Attributes:
     - table_name
     - master_addresses
     - key_columns
     - partition_by
    """


    def __init__(self, table_name=None, master_addresses=None, key_columns=None, partition_by=None,):
        self.table_name = table_name
        self.master_addresses = master_addresses
        self.key_columns = key_columns
        self.partition_by = partition_by

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.master_addresses = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.master_addresses.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.key_columns = []
                    (_etype127, _size124) = iprot.readListBegin()
                    for _i128 in range(_size124):
                        _elem129 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.key_columns.append(_elem129)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_by = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = TKuduPartitionParam()
                        _elem135.read(iprot)
                        self.partition_by.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduTable')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 1)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.master_addresses is not None:
            oprot.writeFieldBegin('master_addresses', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.master_addresses))
            for iter136 in self.master_addresses:
                oprot.writeString(iter136.encode('utf-8') if sys.version_info[0] == 2 else iter136)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_columns is not None:
            oprot.writeFieldBegin('key_columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.key_columns))
            for iter137 in self.key_columns:
                oprot.writeString(iter137.encode('utf-8') if sys.version_info[0] == 2 else iter137)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_by is not None:
            oprot.writeFieldBegin('partition_by', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
            for iter138 in self.partition_by:
                iter138.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.master_addresses is None:
            raise TProtocolException(message='Required field master_addresses is unset!')
        if self.key_columns is None:
            raise TProtocolException(message='Required field key_columns is unset!')
        if self.partition_by is None:
            raise TProtocolException(message='Required field partition_by is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTable(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - load_status
     - access_level
     - columns
     - clustering_columns
     - table_stats
     - table_type
     - hdfs_table
     - hbase_table
     - metastore_table
     - data_source_table
     - kudu_table
     - valid_write_ids
     - storage_metadata_load_time_ns
    """


    def __init__(self, db_name=None, tbl_name=None, load_status=None, access_level=None, columns=None, clustering_columns=None, table_stats=None, table_type=None, hdfs_table=None, hbase_table=None, metastore_table=None, data_source_table=None, kudu_table=None, valid_write_ids=None, storage_metadata_load_time_ns=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.load_status = load_status
        self.access_level = access_level
        self.columns = columns
        self.clustering_columns = clustering_columns
        self.table_stats = table_stats
        self.table_type = table_type
        self.hdfs_table = hdfs_table
        self.hbase_table = hbase_table
        self.metastore_table = metastore_table
        self.data_source_table = data_source_table
        self.kudu_table = kudu_table
        self.valid_write_ids = valid_write_ids
        self.storage_metadata_load_time_ns = storage_metadata_load_time_ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.load_status = Status.ttypes.TStatus()
                    self.load_status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.access_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = TColumn()
                        _elem144.read(iprot)
                        self.columns.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.clustering_columns = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = TColumn()
                        _elem150.read(iprot)
                        self.clustering_columns.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.table_stats = TTableStats()
                    self.table_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.table_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.hdfs_table = THdfsTable()
                    self.hdfs_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.hbase_table = THBaseTable()
                    self.hbase_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.metastore_table = hive_metastore.ttypes.Table()
                    self.metastore_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.data_source_table = TDataSourceTable()
                    self.data_source_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.kudu_table = TKuduTable()
                    self.kudu_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.valid_write_ids = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.storage_metadata_load_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTable')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.load_status is not None:
            oprot.writeFieldBegin('load_status', TType.STRUCT, 3)
            self.load_status.write(oprot)
            oprot.writeFieldEnd()
        if self.access_level is not None:
            oprot.writeFieldBegin('access_level', TType.I32, 4)
            oprot.writeI32(self.access_level)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter151 in self.columns:
                iter151.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clustering_columns is not None:
            oprot.writeFieldBegin('clustering_columns', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.clustering_columns))
            for iter152 in self.clustering_columns:
                iter152.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.table_stats is not None:
            oprot.writeFieldBegin('table_stats', TType.STRUCT, 7)
            self.table_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.table_type is not None:
            oprot.writeFieldBegin('table_type', TType.I32, 8)
            oprot.writeI32(self.table_type)
            oprot.writeFieldEnd()
        if self.hdfs_table is not None:
            oprot.writeFieldBegin('hdfs_table', TType.STRUCT, 9)
            self.hdfs_table.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_table is not None:
            oprot.writeFieldBegin('hbase_table', TType.STRUCT, 10)
            self.hbase_table.write(oprot)
            oprot.writeFieldEnd()
        if self.metastore_table is not None:
            oprot.writeFieldBegin('metastore_table', TType.STRUCT, 11)
            self.metastore_table.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source_table is not None:
            oprot.writeFieldBegin('data_source_table', TType.STRUCT, 12)
            self.data_source_table.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_table is not None:
            oprot.writeFieldBegin('kudu_table', TType.STRUCT, 13)
            self.kudu_table.write(oprot)
            oprot.writeFieldEnd()
        if self.valid_write_ids is not None:
            oprot.writeFieldBegin('valid_write_ids', TType.STRING, 14)
            oprot.writeString(self.valid_write_ids.encode('utf-8') if sys.version_info[0] == 2 else self.valid_write_ids)
            oprot.writeFieldEnd()
        if self.storage_metadata_load_time_ns is not None:
            oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 15)
            oprot.writeI64(self.storage_metadata_load_time_ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.tbl_name is None:
            raise TProtocolException(message='Required field tbl_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabase(object):
    """
    Attributes:
     - db_name
     - metastore_db
    """


    def __init__(self, db_name=None, metastore_db=None,):
        self.db_name = db_name
        self.metastore_db = metastore_db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metastore_db = hive_metastore.ttypes.Database()
                    self.metastore_db.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabase')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.metastore_db is not None:
            oprot.writeFieldBegin('metastore_db', TType.STRUCT, 2)
            self.metastore_db.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrincipal(object):
    """
    Attributes:
     - principal_name
     - principal_id
     - principal_type
     - grant_groups
    """


    def __init__(self, principal_name=None, principal_id=None, principal_type=None, grant_groups=None,):
        self.principal_name = principal_name
        self.principal_id = principal_id
        self.principal_type = principal_type
        self.grant_groups = grant_groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.grant_groups = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.grant_groups.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrincipal')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_id is not None:
            oprot.writeFieldBegin('principal_id', TType.I32, 2)
            oprot.writeI32(self.principal_id)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.grant_groups is not None:
            oprot.writeFieldBegin('grant_groups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.grant_groups))
            for iter159 in self.grant_groups:
                oprot.writeString(iter159.encode('utf-8') if sys.version_info[0] == 2 else iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.principal_name is None:
            raise TProtocolException(message='Required field principal_name is unset!')
        if self.principal_id is None:
            raise TProtocolException(message='Required field principal_id is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        if self.grant_groups is None:
            raise TProtocolException(message='Required field grant_groups is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrivilege(object):
    """
    Attributes:
     - privilege_level
     - scope
     - has_grant_opt
     - principal_id
     - principal_type
     - server_name
     - db_name
     - table_name
     - uri
     - create_time_ms
     - column_name
    """


    def __init__(self, privilege_level=None, scope=None, has_grant_opt=None, principal_id=None, principal_type=None, server_name=None, db_name=None, table_name=None, uri=None, create_time_ms=None, column_name=None,):
        self.privilege_level = privilege_level
        self.scope = scope
        self.has_grant_opt = has_grant_opt
        self.principal_id = principal_id
        self.principal_type = principal_type
        self.server_name = server_name
        self.db_name = db_name
        self.table_name = table_name
        self.uri = uri
        self.create_time_ms = create_time_ms
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.privilege_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.has_grant_opt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.principal_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.create_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrivilege')
        if self.privilege_level is not None:
            oprot.writeFieldBegin('privilege_level', TType.I32, 2)
            oprot.writeI32(self.privilege_level)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 3)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        if self.has_grant_opt is not None:
            oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
            oprot.writeBool(self.has_grant_opt)
            oprot.writeFieldEnd()
        if self.principal_id is not None:
            oprot.writeFieldBegin('principal_id', TType.I32, 5)
            oprot.writeI32(self.principal_id)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 6)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 7)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 8)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 9)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 10)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.create_time_ms is not None:
            oprot.writeFieldBegin('create_time_ms', TType.I64, 11)
            oprot.writeI64(self.create_time_ms)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 12)
            oprot.writeString(self.column_name.encode('utf-8') if sys.version_info[0] == 2 else self.column_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.privilege_level is None:
            raise TProtocolException(message='Required field privilege_level is unset!')
        if self.scope is None:
            raise TProtocolException(message='Required field scope is unset!')
        if self.has_grant_opt is None:
            raise TProtocolException(message='Required field has_grant_opt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsCachePool(object):
    """
    Attributes:
     - pool_name
    """


    def __init__(self, pool_name=None,):
        self.pool_name = pool_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsCachePool')
        if self.pool_name is not None:
            oprot.writeFieldBegin('pool_name', TType.STRING, 1)
            oprot.writeString(self.pool_name.encode('utf-8') if sys.version_info[0] == 2 else self.pool_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pool_name is None:
            raise TProtocolException(message='Required field pool_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthzCacheInvalidation(object):
    """
    Attributes:
     - marker_name
    """


    def __init__(self, marker_name=None,):
        self.marker_name = marker_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.marker_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthzCacheInvalidation')
        if self.marker_name is not None:
            oprot.writeFieldBegin('marker_name', TType.STRING, 1)
            oprot.writeString(self.marker_name.encode('utf-8') if sys.version_info[0] == 2 else self.marker_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.marker_name is None:
            raise TProtocolException(message='Required field marker_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalog(object):
    """
    Attributes:
     - catalog_service_id
     - last_reset_catalog_version
    """


    def __init__(self, catalog_service_id=None, last_reset_catalog_version=None,):
        self.catalog_service_id = catalog_service_id
        self.last_reset_catalog_version = last_reset_catalog_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.last_reset_catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalog')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.last_reset_catalog_version is not None:
            oprot.writeFieldBegin('last_reset_catalog_version', TType.I64, 2)
            oprot.writeI64(self.last_reset_catalog_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.last_reset_catalog_version is None:
            raise TProtocolException(message='Required field last_reset_catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogObject(object):
    """
    Attributes:
     - type
     - catalog_version
     - catalog
     - db
     - table
     - fn
     - data_source
     - principal
     - privilege
     - cache_pool
     - authz_cache_invalidation
    """


    def __init__(self, type=None, catalog_version=None, catalog=None, db=None, table=None, fn=None, data_source=None, principal=None, privilege=None, cache_pool=None, authz_cache_invalidation=None,):
        self.type = type
        self.catalog_version = catalog_version
        self.catalog = catalog
        self.db = db
        self.table = table
        self.fn = fn
        self.data_source = data_source
        self.principal = principal
        self.privilege = privilege
        self.cache_pool = cache_pool
        self.authz_cache_invalidation = authz_cache_invalidation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.catalog = TCatalog()
                    self.catalog.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.db = TDatabase()
                    self.db.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.table = TTable()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.data_source = TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.principal = TPrincipal()
                    self.principal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.privilege = TPrivilege()
                    self.privilege.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.cache_pool = THdfsCachePool()
                    self.cache_pool.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.authz_cache_invalidation = TAuthzCacheInvalidation()
                    self.authz_cache_invalidation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogObject')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.catalog_version is not None:
            oprot.writeFieldBegin('catalog_version', TType.I64, 2)
            oprot.writeI64(self.catalog_version)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin('catalog', TType.STRUCT, 3)
            self.catalog.write(oprot)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRUCT, 4)
            self.db.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 5)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 6)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 7)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.principal is not None:
            oprot.writeFieldBegin('principal', TType.STRUCT, 8)
            self.principal.write(oprot)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRUCT, 9)
            self.privilege.write(oprot)
            oprot.writeFieldEnd()
        if self.cache_pool is not None:
            oprot.writeFieldBegin('cache_pool', TType.STRUCT, 10)
            self.cache_pool.write(oprot)
            oprot.writeFieldEnd()
        if self.authz_cache_invalidation is not None:
            oprot.writeFieldBegin('authz_cache_invalidation', TType.STRUCT, 11)
            self.authz_cache_invalidation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.catalog_version is None:
            raise TProtocolException(message='Required field catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCompressionCodec)
TCompressionCodec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'codec', None, None, ),  # 1
    (2, TType.I32, 'compression_level', None, None, ),  # 2
)
all_structs.append(TPartitionKeyValue)
TPartitionKeyValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)
all_structs.append(TTableName)
TTableName.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
)
all_structs.append(TTableStats)
TTableStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'num_rows', None, None, ),  # 1
    (2, TType.I64, 'total_file_bytes', None, None, ),  # 2
)
all_structs.append(TColumnStats)
TColumnStats.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'avg_size', None, None, ),  # 1
    (2, TType.I64, 'max_size', None, None, ),  # 2
    (3, TType.I64, 'num_distinct_values', None, None, ),  # 3
    (4, TType.I64, 'num_nulls', None, None, ),  # 4
)
all_structs.append(TIntermediateColumnStats)
TIntermediateColumnStats.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'intermediate_ndv', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'is_ndv_encoded', None, None, ),  # 2
    (3, TType.I64, 'num_nulls', None, None, ),  # 3
    (4, TType.I32, 'max_width', None, None, ),  # 4
    (5, TType.DOUBLE, 'avg_width', None, None, ),  # 5
    (6, TType.I64, 'num_rows', None, None, ),  # 6
)
all_structs.append(TPartitionStats)
TPartitionStats.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stats', [TTableStats, None], None, ),  # 1
    (2, TType.MAP, 'intermediate_col_stats', (TType.STRING, 'UTF8', TType.STRUCT, [TIntermediateColumnStats, None], False), None, ),  # 2
)
all_structs.append(TColumn)
TColumn.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'columnName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'columnType', [Types.ttypes.TColumnType, None], None, ),  # 2
    (3, TType.STRING, 'comment', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'col_stats', [TColumnStats, None], None, ),  # 4
    (5, TType.I32, 'position', None, None, ),  # 5
    (6, TType.BOOL, 'is_hbase_column', None, None, ),  # 6
    (7, TType.STRING, 'column_family', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'column_qualifier', 'UTF8', None, ),  # 8
    (9, TType.BOOL, 'is_binary', None, None, ),  # 9
    (10, TType.BOOL, 'is_kudu_column', None, None, ),  # 10
    (11, TType.BOOL, 'is_key', None, None, ),  # 11
    (12, TType.BOOL, 'is_nullable', None, None, ),  # 12
    (13, TType.I32, 'encoding', None, None, ),  # 13
    (14, TType.I32, 'compression', None, None, ),  # 14
    (15, TType.STRUCT, 'default_value', [Exprs.ttypes.TExpr, None], None, ),  # 15
    (16, TType.I32, 'block_size', None, None, ),  # 16
    (17, TType.STRING, 'kudu_column_name', 'UTF8', None, ),  # 17
)
all_structs.append(THdfsFileDesc)
THdfsFileDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_desc_data', 'BINARY', None, ),  # 1
)
all_structs.append(THdfsPartitionLocation)
THdfsPartitionLocation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'prefix_index', None, -1, ),  # 1
    (2, TType.STRING, 'suffix', 'UTF8', None, ),  # 2
)
all_structs.append(THdfsPartition)
THdfsPartition.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'lineDelim', None, None, ),  # 1
    (2, TType.BYTE, 'fieldDelim', None, None, ),  # 2
    (3, TType.BYTE, 'collectionDelim', None, None, ),  # 3
    (4, TType.BYTE, 'mapKeyDelim', None, None, ),  # 4
    (5, TType.BYTE, 'escapeChar', None, None, ),  # 5
    (6, TType.I32, 'fileFormat', None, None, ),  # 6
    (7, TType.LIST, 'partitionKeyExprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    (8, TType.I32, 'blockSize', None, None, ),  # 8
    (9, TType.LIST, 'file_desc', (TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 9
    (10, TType.STRUCT, 'location', [THdfsPartitionLocation, None], None, ),  # 10
    (11, TType.I32, 'access_level', None, None, ),  # 11
    (12, TType.STRUCT, 'stats', [TTableStats, None], None, ),  # 12
    (13, TType.BOOL, 'is_marked_cached', None, None, ),  # 13
    (14, TType.I64, 'id', None, None, ),  # 14
    (15, TType.MAP, 'hms_parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 15
    (16, TType.I64, 'num_blocks', None, None, ),  # 16
    (17, TType.I64, 'total_file_size_bytes', None, None, ),  # 17
    (18, TType.STRING, 'partition_stats', 'BINARY', None, ),  # 18
    (19, TType.BOOL, 'has_incremental_stats', None, None, ),  # 19
    (20, TType.I64, 'write_id', None, None, ),  # 20
)
all_structs.append(THdfsTable)
THdfsTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hdfsBaseDir', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'colNames', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'nullPartitionKeyValue', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'partitions', (TType.I64, None, TType.STRUCT, [THdfsPartition, None], False), None, ),  # 4
    (5, TType.STRING, 'nullColumnValue', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'avroSchema', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT, [Types.ttypes.TNetworkAddress, None], False), None, ),  # 7
    None,  # 8
    (9, TType.LIST, 'partition_prefixes', (TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.STRUCT, 'prototype_partition', [THdfsPartition, None], None, ),  # 10
    (11, TType.STRUCT, 'sql_constraints', [SqlConstraints.ttypes.TSqlConstraints, None], None, ),  # 11
    (12, TType.BOOL, 'is_full_acid', None, False, ),  # 12
)
all_structs.append(THBaseTable)
THBaseTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'families', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'qualifiers', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'binary_encoded', (TType.BOOL, None, False), None, ),  # 4
)
all_structs.append(TDataSource)
TDataSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hdfs_location', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'class_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'api_version', 'UTF8', None, ),  # 4
)
all_structs.append(TDataSourceTable)
TDataSourceTable.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'data_source', [TDataSource, None], None, ),  # 1
    (2, TType.STRING, 'init_string', 'UTF8', None, ),  # 2
)
all_structs.append(TKuduPartitionByHashParam)
TKuduPartitionByHashParam.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'num_partitions', None, None, ),  # 2
)
all_structs.append(TRangePartition)
TRangePartition.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lower_bound_values', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.BOOL, 'is_lower_bound_inclusive', None, None, ),  # 2
    (3, TType.LIST, 'upper_bound_values', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 3
    (4, TType.BOOL, 'is_upper_bound_inclusive', None, None, ),  # 4
)
all_structs.append(TKuduPartitionByRangeParam)
TKuduPartitionByRangeParam.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'range_partitions', (TType.STRUCT, [TRangePartition, None], False), None, ),  # 2
)
all_structs.append(TKuduPartitionParam)
TKuduPartitionParam.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'by_hash_param', [TKuduPartitionByHashParam, None], None, ),  # 1
    (2, TType.STRUCT, 'by_range_param', [TKuduPartitionByRangeParam, None], None, ),  # 2
)
all_structs.append(TKuduTable)
TKuduTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'master_addresses', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'key_columns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'partition_by', (TType.STRUCT, [TKuduPartitionParam, None], False), None, ),  # 4
)
all_structs.append(TTable)
TTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'load_status', [Status.ttypes.TStatus, None], None, ),  # 3
    (4, TType.I32, 'access_level', None, None, ),  # 4
    (5, TType.LIST, 'columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 5
    (6, TType.LIST, 'clustering_columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 6
    (7, TType.STRUCT, 'table_stats', [TTableStats, None], None, ),  # 7
    (8, TType.I32, 'table_type', None, None, ),  # 8
    (9, TType.STRUCT, 'hdfs_table', [THdfsTable, None], None, ),  # 9
    (10, TType.STRUCT, 'hbase_table', [THBaseTable, None], None, ),  # 10
    (11, TType.STRUCT, 'metastore_table', [hive_metastore.ttypes.Table, None], None, ),  # 11
    (12, TType.STRUCT, 'data_source_table', [TDataSourceTable, None], None, ),  # 12
    (13, TType.STRUCT, 'kudu_table', [TKuduTable, None], None, ),  # 13
    (14, TType.STRING, 'valid_write_ids', 'UTF8', None, ),  # 14
    (15, TType.I64, 'storage_metadata_load_time_ns', None, None, ),  # 15
)
all_structs.append(TDatabase)
TDatabase.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'metastore_db', [hive_metastore.ttypes.Database, None], None, ),  # 2
)
all_structs.append(TPrincipal)
TPrincipal.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'principal_id', None, None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
    (4, TType.LIST, 'grant_groups', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TPrivilege)
TPrivilege.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.I32, 'privilege_level', None, None, ),  # 2
    (3, TType.I32, 'scope', None, None, ),  # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ),  # 4
    (5, TType.I32, 'principal_id', None, None, ),  # 5
    (6, TType.I32, 'principal_type', None, None, ),  # 6
    (7, TType.STRING, 'server_name', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'db_name', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'table_name', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'uri', 'UTF8', None, ),  # 10
    (11, TType.I64, 'create_time_ms', None, None, ),  # 11
    (12, TType.STRING, 'column_name', 'UTF8', None, ),  # 12
)
all_structs.append(THdfsCachePool)
THdfsCachePool.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_name', 'UTF8', None, ),  # 1
)
all_structs.append(TAuthzCacheInvalidation)
TAuthzCacheInvalidation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'marker_name', 'UTF8', None, ),  # 1
)
all_structs.append(TCatalog)
TCatalog.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'last_reset_catalog_version', None, None, ),  # 2
)
all_structs.append(TCatalogObject)
TCatalogObject.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I64, 'catalog_version', None, None, ),  # 2
    (3, TType.STRUCT, 'catalog', [TCatalog, None], None, ),  # 3
    (4, TType.STRUCT, 'db', [TDatabase, None], None, ),  # 4
    (5, TType.STRUCT, 'table', [TTable, None], None, ),  # 5
    (6, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 6
    (7, TType.STRUCT, 'data_source', [TDataSource, None], None, ),  # 7
    (8, TType.STRUCT, 'principal', [TPrincipal, None], None, ),  # 8
    (9, TType.STRUCT, 'privilege', [TPrivilege, None], None, ),  # 9
    (10, TType.STRUCT, 'cache_pool', [THdfsCachePool, None], None, ),  # 10
    (11, TType.STRUCT, 'authz_cache_invalidation', [TAuthzCacheInvalidation, None], None, ),  # 11
)
fix_spec(all_structs)
del all_structs
