#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Types.ttypes
import ImpalaInternalService.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import RuntimeProfile.ttypes
import Descriptors.ttypes
import Data.ttypes
import Results.ttypes
import Exprs.ttypes
import TCLIService.ttypes
import Status.ttypes
import CatalogObjects.ttypes
import CatalogService.ttypes
import LineageGraph.ttypes

from thrift.transport import TTransport
all_structs = []


class TDescribeOutputStyle(object):
    MINIMAL = 0
    EXTENDED = 1
    FORMATTED = 2

    _VALUES_TO_NAMES = {
        0: "MINIMAL",
        1: "EXTENDED",
        2: "FORMATTED",
    }

    _NAMES_TO_VALUES = {
        "MINIMAL": 0,
        "EXTENDED": 1,
        "FORMATTED": 2,
    }


class TShowStatsOp(object):
    TABLE_STATS = 0
    COLUMN_STATS = 1
    PARTITIONS = 2
    RANGE_PARTITIONS = 3

    _VALUES_TO_NAMES = {
        0: "TABLE_STATS",
        1: "COLUMN_STATS",
        2: "PARTITIONS",
        3: "RANGE_PARTITIONS",
    }

    _NAMES_TO_VALUES = {
        "TABLE_STATS": 0,
        "COLUMN_STATS": 1,
        "PARTITIONS": 2,
        "RANGE_PARTITIONS": 3,
    }


class TCatalogOpType(object):
    SHOW_TABLES = 0
    SHOW_DBS = 1
    SHOW_STATS = 2
    USE = 3
    DESCRIBE_TABLE = 4
    DESCRIBE_DB = 5
    SHOW_FUNCTIONS = 6
    RESET_METADATA = 7
    DDL = 8
    SHOW_CREATE_TABLE = 9
    SHOW_DATA_SRCS = 10
    SHOW_ROLES = 11
    SHOW_GRANT_PRINCIPAL = 12
    SHOW_FILES = 13
    SHOW_CREATE_FUNCTION = 14

    _VALUES_TO_NAMES = {
        0: "SHOW_TABLES",
        1: "SHOW_DBS",
        2: "SHOW_STATS",
        3: "USE",
        4: "DESCRIBE_TABLE",
        5: "DESCRIBE_DB",
        6: "SHOW_FUNCTIONS",
        7: "RESET_METADATA",
        8: "DDL",
        9: "SHOW_CREATE_TABLE",
        10: "SHOW_DATA_SRCS",
        11: "SHOW_ROLES",
        12: "SHOW_GRANT_PRINCIPAL",
        13: "SHOW_FILES",
        14: "SHOW_CREATE_FUNCTION",
    }

    _NAMES_TO_VALUES = {
        "SHOW_TABLES": 0,
        "SHOW_DBS": 1,
        "SHOW_STATS": 2,
        "USE": 3,
        "DESCRIBE_TABLE": 4,
        "DESCRIBE_DB": 5,
        "SHOW_FUNCTIONS": 6,
        "RESET_METADATA": 7,
        "DDL": 8,
        "SHOW_CREATE_TABLE": 9,
        "SHOW_DATA_SRCS": 10,
        "SHOW_ROLES": 11,
        "SHOW_GRANT_PRINCIPAL": 12,
        "SHOW_FILES": 13,
        "SHOW_CREATE_FUNCTION": 14,
    }


class TAdminRequestType(object):
    SHUTDOWN = 0

    _VALUES_TO_NAMES = {
        0: "SHUTDOWN",
    }

    _NAMES_TO_VALUES = {
        "SHUTDOWN": 0,
    }


class TMetadataOpcode(object):
    GET_TYPE_INFO = 0
    GET_CATALOGS = 1
    GET_SCHEMAS = 2
    GET_TABLES = 3
    GET_TABLE_TYPES = 4
    GET_COLUMNS = 5
    GET_FUNCTIONS = 6
    GET_PRIMARY_KEYS = 7
    GET_CROSS_REFERENCE = 8

    _VALUES_TO_NAMES = {
        0: "GET_TYPE_INFO",
        1: "GET_CATALOGS",
        2: "GET_SCHEMAS",
        3: "GET_TABLES",
        4: "GET_TABLE_TYPES",
        5: "GET_COLUMNS",
        6: "GET_FUNCTIONS",
        7: "GET_PRIMARY_KEYS",
        8: "GET_CROSS_REFERENCE",
    }

    _NAMES_TO_VALUES = {
        "GET_TYPE_INFO": 0,
        "GET_CATALOGS": 1,
        "GET_SCHEMAS": 2,
        "GET_TABLES": 3,
        "GET_TABLE_TYPES": 4,
        "GET_COLUMNS": 5,
        "GET_FUNCTIONS": 6,
        "GET_PRIMARY_KEYS": 7,
        "GET_CROSS_REFERENCE": 8,
    }


class TSymbolType(object):
    UDF_EVALUATE = 0
    UDF_PREPARE = 1
    UDF_CLOSE = 2

    _VALUES_TO_NAMES = {
        0: "UDF_EVALUATE",
        1: "UDF_PREPARE",
        2: "UDF_CLOSE",
    }

    _NAMES_TO_VALUES = {
        "UDF_EVALUATE": 0,
        "UDF_PREPARE": 1,
        "UDF_CLOSE": 2,
    }


class TSymbolLookupResultCode(object):
    SYMBOL_FOUND = 0
    BINARY_NOT_FOUND = 1
    SYMBOL_NOT_FOUND = 2

    _VALUES_TO_NAMES = {
        0: "SYMBOL_FOUND",
        1: "BINARY_NOT_FOUND",
        2: "SYMBOL_NOT_FOUND",
    }

    _NAMES_TO_VALUES = {
        "SYMBOL_FOUND": 0,
        "BINARY_NOT_FOUND": 1,
        "SYMBOL_NOT_FOUND": 2,
    }


class THiveUdfExecutorCtorParams(object):
    """
    Attributes:
     - fn
     - local_location
     - input_byte_offsets
     - input_nulls_ptr
     - input_buffer_ptr
     - output_null_ptr
     - output_buffer_ptr
    """


    def __init__(self, fn=None, local_location=None, input_byte_offsets=None, input_nulls_ptr=None, input_buffer_ptr=None, output_null_ptr=None, output_buffer_ptr=None,):
        self.fn = fn
        self.local_location = local_location
        self.input_byte_offsets = input_byte_offsets
        self.input_nulls_ptr = input_nulls_ptr
        self.input_buffer_ptr = input_buffer_ptr
        self.output_null_ptr = output_null_ptr
        self.output_buffer_ptr = output_buffer_ptr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.local_location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.input_byte_offsets = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.input_byte_offsets.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.input_nulls_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.input_buffer_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.output_null_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.output_buffer_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THiveUdfExecutorCtorParams')
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 1)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.local_location is not None:
            oprot.writeFieldBegin('local_location', TType.STRING, 2)
            oprot.writeString(self.local_location.encode('utf-8') if sys.version_info[0] == 2 else self.local_location)
            oprot.writeFieldEnd()
        if self.input_byte_offsets is not None:
            oprot.writeFieldBegin('input_byte_offsets', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.input_byte_offsets))
            for iter6 in self.input_byte_offsets:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.input_nulls_ptr is not None:
            oprot.writeFieldBegin('input_nulls_ptr', TType.I64, 4)
            oprot.writeI64(self.input_nulls_ptr)
            oprot.writeFieldEnd()
        if self.input_buffer_ptr is not None:
            oprot.writeFieldBegin('input_buffer_ptr', TType.I64, 5)
            oprot.writeI64(self.input_buffer_ptr)
            oprot.writeFieldEnd()
        if self.output_null_ptr is not None:
            oprot.writeFieldBegin('output_null_ptr', TType.I64, 6)
            oprot.writeI64(self.output_null_ptr)
            oprot.writeFieldEnd()
        if self.output_buffer_ptr is not None:
            oprot.writeFieldBegin('output_buffer_ptr', TType.I64, 7)
            oprot.writeI64(self.output_buffer_ptr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn is None:
            raise TProtocolException(message='Required field fn is unset!')
        if self.local_location is None:
            raise TProtocolException(message='Required field local_location is unset!')
        if self.input_byte_offsets is None:
            raise TProtocolException(message='Required field input_byte_offsets is unset!')
        if self.input_nulls_ptr is None:
            raise TProtocolException(message='Required field input_nulls_ptr is unset!')
        if self.input_buffer_ptr is None:
            raise TProtocolException(message='Required field input_buffer_ptr is unset!')
        if self.output_null_ptr is None:
            raise TProtocolException(message='Required field output_null_ptr is unset!')
        if self.output_buffer_ptr is None:
            raise TProtocolException(message='Required field output_buffer_ptr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTablesParams(object):
    """
    Attributes:
     - db
     - pattern
     - session
    """


    def __init__(self, db=None, pattern=None, session=None,):
        self.db = db
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.session = ImpalaInternalService.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTablesParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 3)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTablesResult(object):
    """
    Attributes:
     - tables
    """


    def __init__(self, tables=None,):
        self.tables = tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tables = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tables.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTablesResult')
        if self.tables is not None:
            oprot.writeFieldBegin('tables', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tables))
            for iter13 in self.tables:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableMetricsParams(object):
    """
    Attributes:
     - table_name
    """


    def __init__(self, table_name=None,):
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableMetricsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableMetricsResponse(object):
    """
    Attributes:
     - metrics
    """


    def __init__(self, metrics=None,):
        self.metrics = metrics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metrics = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableMetricsResponse')
        if self.metrics is not None:
            oprot.writeFieldBegin('metrics', TType.STRING, 1)
            oprot.writeString(self.metrics.encode('utf-8') if sys.version_info[0] == 2 else self.metrics)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metrics is None:
            raise TProtocolException(message='Required field metrics is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogMetricsResult(object):
    """
    Attributes:
     - num_dbs
     - num_tables
     - cache_eviction_count
     - cache_hit_count
     - cache_load_count
     - cache_load_exception_count
     - cache_load_success_count
     - cache_miss_count
     - cache_request_count
     - cache_total_load_time
     - cache_avg_load_time
     - cache_hit_rate
     - cache_load_exception_rate
     - cache_miss_rate
    """


    def __init__(self, num_dbs=None, num_tables=None, cache_eviction_count=None, cache_hit_count=None, cache_load_count=None, cache_load_exception_count=None, cache_load_success_count=None, cache_miss_count=None, cache_request_count=None, cache_total_load_time=None, cache_avg_load_time=None, cache_hit_rate=None, cache_load_exception_rate=None, cache_miss_rate=None,):
        self.num_dbs = num_dbs
        self.num_tables = num_tables
        self.cache_eviction_count = cache_eviction_count
        self.cache_hit_count = cache_hit_count
        self.cache_load_count = cache_load_count
        self.cache_load_exception_count = cache_load_exception_count
        self.cache_load_success_count = cache_load_success_count
        self.cache_miss_count = cache_miss_count
        self.cache_request_count = cache_request_count
        self.cache_total_load_time = cache_total_load_time
        self.cache_avg_load_time = cache_avg_load_time
        self.cache_hit_rate = cache_hit_rate
        self.cache_load_exception_rate = cache_load_exception_rate
        self.cache_miss_rate = cache_miss_rate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_dbs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_tables = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.cache_eviction_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.cache_hit_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.cache_load_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.cache_load_exception_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.cache_load_success_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.cache_miss_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.cache_request_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.cache_total_load_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.cache_avg_load_time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.cache_hit_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.cache_load_exception_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.cache_miss_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogMetricsResult')
        if self.num_dbs is not None:
            oprot.writeFieldBegin('num_dbs', TType.I32, 1)
            oprot.writeI32(self.num_dbs)
            oprot.writeFieldEnd()
        if self.num_tables is not None:
            oprot.writeFieldBegin('num_tables', TType.I32, 2)
            oprot.writeI32(self.num_tables)
            oprot.writeFieldEnd()
        if self.cache_eviction_count is not None:
            oprot.writeFieldBegin('cache_eviction_count', TType.I64, 3)
            oprot.writeI64(self.cache_eviction_count)
            oprot.writeFieldEnd()
        if self.cache_hit_count is not None:
            oprot.writeFieldBegin('cache_hit_count', TType.I64, 4)
            oprot.writeI64(self.cache_hit_count)
            oprot.writeFieldEnd()
        if self.cache_load_count is not None:
            oprot.writeFieldBegin('cache_load_count', TType.I64, 5)
            oprot.writeI64(self.cache_load_count)
            oprot.writeFieldEnd()
        if self.cache_load_exception_count is not None:
            oprot.writeFieldBegin('cache_load_exception_count', TType.I64, 6)
            oprot.writeI64(self.cache_load_exception_count)
            oprot.writeFieldEnd()
        if self.cache_load_success_count is not None:
            oprot.writeFieldBegin('cache_load_success_count', TType.I64, 7)
            oprot.writeI64(self.cache_load_success_count)
            oprot.writeFieldEnd()
        if self.cache_miss_count is not None:
            oprot.writeFieldBegin('cache_miss_count', TType.I64, 8)
            oprot.writeI64(self.cache_miss_count)
            oprot.writeFieldEnd()
        if self.cache_request_count is not None:
            oprot.writeFieldBegin('cache_request_count', TType.I64, 9)
            oprot.writeI64(self.cache_request_count)
            oprot.writeFieldEnd()
        if self.cache_total_load_time is not None:
            oprot.writeFieldBegin('cache_total_load_time', TType.I64, 10)
            oprot.writeI64(self.cache_total_load_time)
            oprot.writeFieldEnd()
        if self.cache_avg_load_time is not None:
            oprot.writeFieldBegin('cache_avg_load_time', TType.DOUBLE, 11)
            oprot.writeDouble(self.cache_avg_load_time)
            oprot.writeFieldEnd()
        if self.cache_hit_rate is not None:
            oprot.writeFieldBegin('cache_hit_rate', TType.DOUBLE, 12)
            oprot.writeDouble(self.cache_hit_rate)
            oprot.writeFieldEnd()
        if self.cache_load_exception_rate is not None:
            oprot.writeFieldBegin('cache_load_exception_rate', TType.DOUBLE, 13)
            oprot.writeDouble(self.cache_load_exception_rate)
            oprot.writeFieldEnd()
        if self.cache_miss_rate is not None:
            oprot.writeFieldBegin('cache_miss_rate', TType.DOUBLE, 14)
            oprot.writeDouble(self.cache_miss_rate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_dbs is None:
            raise TProtocolException(message='Required field num_dbs is unset!')
        if self.num_tables is None:
            raise TProtocolException(message='Required field num_tables is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDbsParams(object):
    """
    Attributes:
     - pattern
     - session
    """


    def __init__(self, pattern=None, session=None,):
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.session = ImpalaInternalService.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDbsParams')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 2)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDbsResult(object):
    """
    Attributes:
     - dbs
    """


    def __init__(self, dbs=None,):
        self.dbs = dbs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dbs = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = CatalogObjects.ttypes.TDatabase()
                        _elem19.read(iprot)
                        self.dbs.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDbsResult')
        if self.dbs is not None:
            oprot.writeFieldBegin('dbs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dbs))
            for iter20 in self.dbs:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataSrcsParams(object):
    """
    Attributes:
     - pattern
    """


    def __init__(self, pattern=None,):
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataSrcsParams')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataSrcsResult(object):
    """
    Attributes:
     - data_src_names
     - locations
     - class_names
     - api_versions
    """


    def __init__(self, data_src_names=None, locations=None, class_names=None, api_versions=None,):
        self.data_src_names = data_src_names
        self.locations = locations
        self.class_names = class_names
        self.api_versions = api_versions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data_src_names = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.data_src_names.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.locations = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.locations.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.class_names = []
                    (_etype36, _size33) = iprot.readListBegin()
                    for _i37 in range(_size33):
                        _elem38 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.class_names.append(_elem38)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.api_versions = []
                    (_etype42, _size39) = iprot.readListBegin()
                    for _i43 in range(_size39):
                        _elem44 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.api_versions.append(_elem44)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataSrcsResult')
        if self.data_src_names is not None:
            oprot.writeFieldBegin('data_src_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.data_src_names))
            for iter45 in self.data_src_names:
                oprot.writeString(iter45.encode('utf-8') if sys.version_info[0] == 2 else iter45)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.locations is not None:
            oprot.writeFieldBegin('locations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.locations))
            for iter46 in self.locations:
                oprot.writeString(iter46.encode('utf-8') if sys.version_info[0] == 2 else iter46)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.class_names is not None:
            oprot.writeFieldBegin('class_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.class_names))
            for iter47 in self.class_names:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.api_versions is not None:
            oprot.writeFieldBegin('api_versions', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.api_versions))
            for iter48 in self.api_versions:
                oprot.writeString(iter48.encode('utf-8') if sys.version_info[0] == 2 else iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_src_names is None:
            raise TProtocolException(message='Required field data_src_names is unset!')
        if self.locations is None:
            raise TProtocolException(message='Required field locations is unset!')
        if self.class_names is None:
            raise TProtocolException(message='Required field class_names is unset!')
        if self.api_versions is None:
            raise TProtocolException(message='Required field api_versions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeDbParams(object):
    """
    Attributes:
     - db
     - output_style
    """


    def __init__(self, db=None, output_style=None,):
        self.db = db
        self.output_style = output_style

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_style = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.output_style is not None:
            oprot.writeFieldBegin('output_style', TType.I32, 2)
            oprot.writeI32(self.output_style)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.output_style is None:
            raise TProtocolException(message='Required field output_style is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeTableParams(object):
    """
    Attributes:
     - output_style
     - table_name
     - result_struct
     - session
    """


    def __init__(self, output_style=None, table_name=None, result_struct=None, session=None,):
        self.output_style = output_style
        self.table_name = table_name
        self.result_struct = result_struct
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.output_style = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.result_struct = Types.ttypes.TColumnType()
                    self.result_struct.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.session = ImpalaInternalService.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeTableParams')
        if self.output_style is not None:
            oprot.writeFieldBegin('output_style', TType.I32, 1)
            oprot.writeI32(self.output_style)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.result_struct is not None:
            oprot.writeFieldBegin('result_struct', TType.STRUCT, 3)
            self.result_struct.write(oprot)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 4)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.output_style is None:
            raise TProtocolException(message='Required field output_style is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeResult(object):
    """
    Attributes:
     - results
    """


    def __init__(self, results=None,):
        self.results = results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = Data.ttypes.TResultRow()
                        _elem54.read(iprot)
                        self.results.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeResult')
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter55 in self.results:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.results is None:
            raise TProtocolException(message='Required field results is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDataSrcsParams(object):
    """
    Attributes:
     - show_pattern
    """


    def __init__(self, show_pattern=None,):
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDataSrcsParams')
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
            oprot.writeString(self.show_pattern.encode('utf-8') if sys.version_info[0] == 2 else self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDbsParams(object):
    """
    Attributes:
     - show_pattern
    """


    def __init__(self, show_pattern=None,):
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDbsParams')
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
            oprot.writeString(self.show_pattern.encode('utf-8') if sys.version_info[0] == 2 else self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowStatsParams(object):
    """
    Attributes:
     - op
     - table_name
    """


    def __init__(self, op=None, table_name=None,):
        self.op = op
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowStatsParams')
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 1)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowFunctionsParams(object):
    """
    Attributes:
     - category
     - db
     - show_pattern
    """


    def __init__(self, category=None, db=None, show_pattern=None,):
        self.category = category
        self.db = db
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.category = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowFunctionsParams')
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 1)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 3)
            oprot.writeString(self.show_pattern.encode('utf-8') if sys.version_info[0] == 2 else self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTablesParams(object):
    """
    Attributes:
     - db
     - show_pattern
    """


    def __init__(self, db=None, show_pattern=None,):
        self.db = db
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTablesParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 2)
            oprot.writeString(self.show_pattern.encode('utf-8') if sys.version_info[0] == 2 else self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowFilesParams(object):
    """
    Attributes:
     - table_name
     - partition_set
    """


    def __init__(self, table_name=None, partition_set=None,):
        self.table_name = table_name
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = []
                        (_etype65, _size62) = iprot.readListBegin()
                        for _i66 in range(_size62):
                            _elem67 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem67.read(iprot)
                            _elem61.append(_elem67)
                        iprot.readListEnd()
                        self.partition_set.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowFilesParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter68 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter68))
                for iter69 in iter68:
                    iter69.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRolesParams(object):
    """
    Attributes:
     - requesting_user
     - is_show_current_roles
     - grant_group
    """


    def __init__(self, requesting_user=None, is_show_current_roles=None, grant_group=None,):
        self.requesting_user = requesting_user
        self.is_show_current_roles = is_show_current_roles
        self.grant_group = grant_group

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_show_current_roles = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.grant_group = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRolesParams')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user.encode('utf-8') if sys.version_info[0] == 2 else self.requesting_user)
            oprot.writeFieldEnd()
        if self.is_show_current_roles is not None:
            oprot.writeFieldBegin('is_show_current_roles', TType.BOOL, 3)
            oprot.writeBool(self.is_show_current_roles)
            oprot.writeFieldEnd()
        if self.grant_group is not None:
            oprot.writeFieldBegin('grant_group', TType.STRING, 4)
            oprot.writeString(self.grant_group.encode('utf-8') if sys.version_info[0] == 2 else self.grant_group)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_show_current_roles is None:
            raise TProtocolException(message='Required field is_show_current_roles is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRolesResult(object):
    """
    Attributes:
     - role_names
    """


    def __init__(self, role_names=None,):
        self.role_names = role_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.role_names = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.role_names.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRolesResult')
        if self.role_names is not None:
            oprot.writeFieldBegin('role_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.role_names))
            for iter76 in self.role_names:
                oprot.writeString(iter76.encode('utf-8') if sys.version_info[0] == 2 else iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.role_names is None:
            raise TProtocolException(message='Required field role_names is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowGrantPrincipalParams(object):
    """
    Attributes:
     - requesting_user
     - name
     - principal_type
     - privilege
    """


    def __init__(self, requesting_user=None, name=None, principal_type=None, privilege=None,):
        self.requesting_user = requesting_user
        self.name = name
        self.principal_type = principal_type
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.privilege = CatalogObjects.ttypes.TPrivilege()
                    self.privilege.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowGrantPrincipalParams')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user.encode('utf-8') if sys.version_info[0] == 2 else self.requesting_user)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRUCT, 5)
            self.privilege.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsParams(object):
    """
    Attributes:
     - category
     - db
     - pattern
     - session
    """


    def __init__(self, category=None, db=None, pattern=None, session=None,):
        self.category = category
        self.db = db
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.category = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.session = ImpalaInternalService.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsParams')
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 1)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 3)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 4)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.category is None:
            raise TProtocolException(message='Required field category is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsResult(object):
    """
    Attributes:
     - fn_signatures
     - fn_ret_types
     - fn_binary_types
     - fn_persistence
    """


    def __init__(self, fn_signatures=None, fn_ret_types=None, fn_binary_types=None, fn_persistence=None,):
        self.fn_signatures = fn_signatures
        self.fn_ret_types = fn_ret_types
        self.fn_binary_types = fn_binary_types
        self.fn_persistence = fn_persistence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fn_signatures = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.fn_signatures.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fn_ret_types = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.fn_ret_types.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.fn_binary_types = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.fn_binary_types.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.fn_persistence = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.fn_persistence.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsResult')
        if self.fn_signatures is not None:
            oprot.writeFieldBegin('fn_signatures', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.fn_signatures))
            for iter101 in self.fn_signatures:
                oprot.writeString(iter101.encode('utf-8') if sys.version_info[0] == 2 else iter101)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_ret_types is not None:
            oprot.writeFieldBegin('fn_ret_types', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.fn_ret_types))
            for iter102 in self.fn_ret_types:
                oprot.writeString(iter102.encode('utf-8') if sys.version_info[0] == 2 else iter102)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_binary_types is not None:
            oprot.writeFieldBegin('fn_binary_types', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.fn_binary_types))
            for iter103 in self.fn_binary_types:
                oprot.writeString(iter103.encode('utf-8') if sys.version_info[0] == 2 else iter103)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_persistence is not None:
            oprot.writeFieldBegin('fn_persistence', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.fn_persistence))
            for iter104 in self.fn_persistence:
                oprot.writeString(iter104.encode('utf-8') if sys.version_info[0] == 2 else iter104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUseDbParams(object):
    """
    Attributes:
     - db
    """


    def __init__(self, db=None,):
        self.db = db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUseDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExplainResult(object):
    """
    Attributes:
     - results
    """


    def __init__(self, results=None,):
        self.results = results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = Data.ttypes.TResultRow()
                        _elem110.read(iprot)
                        self.results.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExplainResult')
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter111 in self.results:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.results is None:
            raise TProtocolException(message='Required field results is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFinalizeParams(object):
    """
    Attributes:
     - is_overwrite
     - hdfs_base_dir
     - table_name
     - table_db
     - staging_dir
     - table_id
     - transaction_id
     - write_id
    """


    def __init__(self, is_overwrite=None, hdfs_base_dir=None, table_name=None, table_db=None, staging_dir=None, table_id=None, transaction_id=None, write_id=None,):
        self.is_overwrite = is_overwrite
        self.hdfs_base_dir = hdfs_base_dir
        self.table_name = table_name
        self.table_db = table_db
        self.staging_dir = staging_dir
        self.table_id = table_id
        self.transaction_id = transaction_id
        self.write_id = write_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hdfs_base_dir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.table_db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.staging_dir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.table_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.transaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFinalizeParams')
        if self.is_overwrite is not None:
            oprot.writeFieldBegin('is_overwrite', TType.BOOL, 1)
            oprot.writeBool(self.is_overwrite)
            oprot.writeFieldEnd()
        if self.hdfs_base_dir is not None:
            oprot.writeFieldBegin('hdfs_base_dir', TType.STRING, 2)
            oprot.writeString(self.hdfs_base_dir.encode('utf-8') if sys.version_info[0] == 2 else self.hdfs_base_dir)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 3)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.table_db is not None:
            oprot.writeFieldBegin('table_db', TType.STRING, 4)
            oprot.writeString(self.table_db.encode('utf-8') if sys.version_info[0] == 2 else self.table_db)
            oprot.writeFieldEnd()
        if self.staging_dir is not None:
            oprot.writeFieldBegin('staging_dir', TType.STRING, 5)
            oprot.writeString(self.staging_dir.encode('utf-8') if sys.version_info[0] == 2 else self.staging_dir)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I64, 6)
            oprot.writeI64(self.table_id)
            oprot.writeFieldEnd()
        if self.transaction_id is not None:
            oprot.writeFieldBegin('transaction_id', TType.I64, 7)
            oprot.writeI64(self.transaction_id)
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 8)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_overwrite is None:
            raise TProtocolException(message='Required field is_overwrite is unset!')
        if self.hdfs_base_dir is None:
            raise TProtocolException(message='Required field hdfs_base_dir is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.table_db is None:
            raise TProtocolException(message='Required field table_db is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadDataReq(object):
    """
    Attributes:
     - table_name
     - source_path
     - overwrite
     - partition_spec
    """


    def __init__(self, table_name=None, source_path=None, overwrite=None, partition_spec=None,):
        self.table_name = table_name
        self.source_path = source_path
        self.overwrite = overwrite
        self.partition_spec = partition_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem117.read(iprot)
                        self.partition_spec.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadDataReq')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.source_path is not None:
            oprot.writeFieldBegin('source_path', TType.STRING, 2)
            oprot.writeString(self.source_path.encode('utf-8') if sys.version_info[0] == 2 else self.source_path)
            oprot.writeFieldEnd()
        if self.overwrite is not None:
            oprot.writeFieldBegin('overwrite', TType.BOOL, 3)
            oprot.writeBool(self.overwrite)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter118 in self.partition_spec:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.source_path is None:
            raise TProtocolException(message='Required field source_path is unset!')
        if self.overwrite is None:
            raise TProtocolException(message='Required field overwrite is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadDataResp(object):
    """
    Attributes:
     - load_summary
    """


    def __init__(self, load_summary=None,):
        self.load_summary = load_summary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.load_summary = Data.ttypes.TResultRow()
                    self.load_summary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadDataResp')
        if self.load_summary is not None:
            oprot.writeFieldBegin('load_summary', TType.STRUCT, 1)
            self.load_summary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.load_summary is None:
            raise TProtocolException(message='Required field load_summary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanExecInfo(object):
    """
    Attributes:
     - fragments
     - per_node_scan_ranges
    """


    def __init__(self, fragments=None, per_node_scan_ranges=None,):
        self.fragments = fragments
        self.per_node_scan_ranges = per_node_scan_ranges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fragments = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = Planner.ttypes.TPlanFragment()
                        _elem124.read(iprot)
                        self.fragments.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.per_node_scan_ranges = {}
                    (_ktype126, _vtype127, _size125) = iprot.readMapBegin()
                    for _i129 in range(_size125):
                        _key130 = iprot.readI32()
                        _val131 = Planner.ttypes.TScanRangeSpec()
                        _val131.read(iprot)
                        self.per_node_scan_ranges[_key130] = _val131
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanExecInfo')
        if self.fragments is not None:
            oprot.writeFieldBegin('fragments', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fragments))
            for iter132 in self.fragments:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.per_node_scan_ranges is not None:
            oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.per_node_scan_ranges))
            for kiter133, viter134 in self.per_node_scan_ranges.items():
                oprot.writeI32(kiter133)
                viter134.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragments is None:
            raise TProtocolException(message='Required field fragments is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TQueryExecRequest(object):
    """
    Attributes:
     - plan_exec_info
     - result_set_metadata
     - finalize_params
     - query_ctx
     - query_plan
     - stmt_type
     - host_list
     - lineage_graph
     - per_host_mem_estimate
     - max_per_host_min_mem_reservation
     - max_per_host_thread_reservation
     - dedicated_coord_mem_estimate
    """


    def __init__(self, plan_exec_info=None, result_set_metadata=None, finalize_params=None, query_ctx=None, query_plan=None, stmt_type=None, host_list=None, lineage_graph=None, per_host_mem_estimate=None, max_per_host_min_mem_reservation=None, max_per_host_thread_reservation=None, dedicated_coord_mem_estimate=None,):
        self.plan_exec_info = plan_exec_info
        self.result_set_metadata = result_set_metadata
        self.finalize_params = finalize_params
        self.query_ctx = query_ctx
        self.query_plan = query_plan
        self.stmt_type = stmt_type
        self.host_list = host_list
        self.lineage_graph = lineage_graph
        self.per_host_mem_estimate = per_host_mem_estimate
        self.max_per_host_min_mem_reservation = max_per_host_min_mem_reservation
        self.max_per_host_thread_reservation = max_per_host_thread_reservation
        self.dedicated_coord_mem_estimate = dedicated_coord_mem_estimate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.plan_exec_info = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = TPlanExecInfo()
                        _elem140.read(iprot)
                        self.plan_exec_info.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.result_set_metadata = Results.ttypes.TResultSetMetadata()
                    self.result_set_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.finalize_params = TFinalizeParams()
                    self.finalize_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.query_ctx = ImpalaInternalService.ttypes.TQueryCtx()
                    self.query_ctx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.query_plan = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.stmt_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.host_list = []
                    (_etype144, _size141) = iprot.readListBegin()
                    for _i145 in range(_size141):
                        _elem146 = Types.ttypes.TNetworkAddress()
                        _elem146.read(iprot)
                        self.host_list.append(_elem146)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.lineage_graph = LineageGraph.ttypes.TLineageGraph()
                    self.lineage_graph.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.per_host_mem_estimate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.max_per_host_min_mem_reservation = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.max_per_host_thread_reservation = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.dedicated_coord_mem_estimate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryExecRequest')
        if self.plan_exec_info is not None:
            oprot.writeFieldBegin('plan_exec_info', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.plan_exec_info))
            for iter147 in self.plan_exec_info:
                iter147.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.result_set_metadata is not None:
            oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 2)
            self.result_set_metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.finalize_params is not None:
            oprot.writeFieldBegin('finalize_params', TType.STRUCT, 3)
            self.finalize_params.write(oprot)
            oprot.writeFieldEnd()
        if self.query_ctx is not None:
            oprot.writeFieldBegin('query_ctx', TType.STRUCT, 4)
            self.query_ctx.write(oprot)
            oprot.writeFieldEnd()
        if self.query_plan is not None:
            oprot.writeFieldBegin('query_plan', TType.STRING, 5)
            oprot.writeString(self.query_plan.encode('utf-8') if sys.version_info[0] == 2 else self.query_plan)
            oprot.writeFieldEnd()
        if self.stmt_type is not None:
            oprot.writeFieldBegin('stmt_type', TType.I32, 6)
            oprot.writeI32(self.stmt_type)
            oprot.writeFieldEnd()
        if self.host_list is not None:
            oprot.writeFieldBegin('host_list', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.host_list))
            for iter148 in self.host_list:
                iter148.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lineage_graph is not None:
            oprot.writeFieldBegin('lineage_graph', TType.STRUCT, 8)
            self.lineage_graph.write(oprot)
            oprot.writeFieldEnd()
        if self.per_host_mem_estimate is not None:
            oprot.writeFieldBegin('per_host_mem_estimate', TType.I64, 9)
            oprot.writeI64(self.per_host_mem_estimate)
            oprot.writeFieldEnd()
        if self.max_per_host_min_mem_reservation is not None:
            oprot.writeFieldBegin('max_per_host_min_mem_reservation', TType.I64, 10)
            oprot.writeI64(self.max_per_host_min_mem_reservation)
            oprot.writeFieldEnd()
        if self.max_per_host_thread_reservation is not None:
            oprot.writeFieldBegin('max_per_host_thread_reservation', TType.I64, 11)
            oprot.writeI64(self.max_per_host_thread_reservation)
            oprot.writeFieldEnd()
        if self.dedicated_coord_mem_estimate is not None:
            oprot.writeFieldBegin('dedicated_coord_mem_estimate', TType.I64, 12)
            oprot.writeI64(self.dedicated_coord_mem_estimate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.query_ctx is None:
            raise TProtocolException(message='Required field query_ctx is unset!')
        if self.stmt_type is None:
            raise TProtocolException(message='Required field stmt_type is unset!')
        if self.host_list is None:
            raise TProtocolException(message='Required field host_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogOpRequest(object):
    """
    Attributes:
     - op_type
     - sync_ddl
     - use_db_params
     - describe_db_params
     - describe_table_params
     - show_dbs_params
     - show_tables_params
     - show_fns_params
     - show_data_srcs_params
     - show_roles_params
     - show_grant_principal_params
     - ddl_params
     - reset_metadata_params
     - show_stats_params
     - show_create_table_params
     - show_files_params
     - lineage_graph
     - show_create_function_params
    """


    def __init__(self, op_type=None, sync_ddl=None, use_db_params=None, describe_db_params=None, describe_table_params=None, show_dbs_params=None, show_tables_params=None, show_fns_params=None, show_data_srcs_params=None, show_roles_params=None, show_grant_principal_params=None, ddl_params=None, reset_metadata_params=None, show_stats_params=None, show_create_table_params=None, show_files_params=None, lineage_graph=None, show_create_function_params=None,):
        self.op_type = op_type
        self.sync_ddl = sync_ddl
        self.use_db_params = use_db_params
        self.describe_db_params = describe_db_params
        self.describe_table_params = describe_table_params
        self.show_dbs_params = show_dbs_params
        self.show_tables_params = show_tables_params
        self.show_fns_params = show_fns_params
        self.show_data_srcs_params = show_data_srcs_params
        self.show_roles_params = show_roles_params
        self.show_grant_principal_params = show_grant_principal_params
        self.ddl_params = ddl_params
        self.reset_metadata_params = reset_metadata_params
        self.show_stats_params = show_stats_params
        self.show_create_table_params = show_create_table_params
        self.show_files_params = show_files_params
        self.lineage_graph = lineage_graph
        self.show_create_function_params = show_create_function_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.use_db_params = TUseDbParams()
                    self.use_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.describe_db_params = TDescribeDbParams()
                    self.describe_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.describe_table_params = TDescribeTableParams()
                    self.describe_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.show_dbs_params = TShowDbsParams()
                    self.show_dbs_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.show_tables_params = TShowTablesParams()
                    self.show_tables_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.show_fns_params = TShowFunctionsParams()
                    self.show_fns_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.show_data_srcs_params = TShowDataSrcsParams()
                    self.show_data_srcs_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.show_roles_params = TShowRolesParams()
                    self.show_roles_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.show_grant_principal_params = TShowGrantPrincipalParams()
                    self.show_grant_principal_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.ddl_params = CatalogService.ttypes.TDdlExecRequest()
                    self.ddl_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.reset_metadata_params = CatalogService.ttypes.TResetMetadataRequest()
                    self.reset_metadata_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.show_stats_params = TShowStatsParams()
                    self.show_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.show_create_table_params = CatalogObjects.ttypes.TTableName()
                    self.show_create_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.show_files_params = TShowFilesParams()
                    self.show_files_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.lineage_graph = LineageGraph.ttypes.TLineageGraph()
                    self.lineage_graph.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.show_create_function_params = TGetFunctionsParams()
                    self.show_create_function_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogOpRequest')
        if self.op_type is not None:
            oprot.writeFieldBegin('op_type', TType.I32, 1)
            oprot.writeI32(self.op_type)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 2)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.use_db_params is not None:
            oprot.writeFieldBegin('use_db_params', TType.STRUCT, 3)
            self.use_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.describe_db_params is not None:
            oprot.writeFieldBegin('describe_db_params', TType.STRUCT, 4)
            self.describe_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.describe_table_params is not None:
            oprot.writeFieldBegin('describe_table_params', TType.STRUCT, 5)
            self.describe_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_dbs_params is not None:
            oprot.writeFieldBegin('show_dbs_params', TType.STRUCT, 6)
            self.show_dbs_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_tables_params is not None:
            oprot.writeFieldBegin('show_tables_params', TType.STRUCT, 7)
            self.show_tables_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_fns_params is not None:
            oprot.writeFieldBegin('show_fns_params', TType.STRUCT, 8)
            self.show_fns_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_data_srcs_params is not None:
            oprot.writeFieldBegin('show_data_srcs_params', TType.STRUCT, 9)
            self.show_data_srcs_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_roles_params is not None:
            oprot.writeFieldBegin('show_roles_params', TType.STRUCT, 10)
            self.show_roles_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_grant_principal_params is not None:
            oprot.writeFieldBegin('show_grant_principal_params', TType.STRUCT, 11)
            self.show_grant_principal_params.write(oprot)
            oprot.writeFieldEnd()
        if self.ddl_params is not None:
            oprot.writeFieldBegin('ddl_params', TType.STRUCT, 12)
            self.ddl_params.write(oprot)
            oprot.writeFieldEnd()
        if self.reset_metadata_params is not None:
            oprot.writeFieldBegin('reset_metadata_params', TType.STRUCT, 13)
            self.reset_metadata_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_stats_params is not None:
            oprot.writeFieldBegin('show_stats_params', TType.STRUCT, 14)
            self.show_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_create_table_params is not None:
            oprot.writeFieldBegin('show_create_table_params', TType.STRUCT, 15)
            self.show_create_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_files_params is not None:
            oprot.writeFieldBegin('show_files_params', TType.STRUCT, 16)
            self.show_files_params.write(oprot)
            oprot.writeFieldEnd()
        if self.lineage_graph is not None:
            oprot.writeFieldBegin('lineage_graph', TType.STRUCT, 17)
            self.lineage_graph.write(oprot)
            oprot.writeFieldEnd()
        if self.show_create_function_params is not None:
            oprot.writeFieldBegin('show_create_function_params', TType.STRUCT, 18)
            self.show_create_function_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.op_type is None:
            raise TProtocolException(message='Required field op_type is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetQueryOptionRequest(object):
    """
    Attributes:
     - key
     - value
     - is_set_all
    """


    def __init__(self, key=None, value=None, is_set_all=None,):
        self.key = key
        self.value = value
        self.is_set_all = is_set_all

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_set_all = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetQueryOptionRequest')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.is_set_all is not None:
            oprot.writeFieldBegin('is_set_all', TType.BOOL, 3)
            oprot.writeBool(self.is_set_all)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShutdownParams(object):
    """
    Attributes:
     - backend
     - deadline_s
    """


    def __init__(self, backend=None, deadline_s=None,):
        self.backend = backend
        self.deadline_s = deadline_s

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.backend = Types.ttypes.TNetworkAddress()
                    self.backend.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deadline_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShutdownParams')
        if self.backend is not None:
            oprot.writeFieldBegin('backend', TType.STRUCT, 1)
            self.backend.write(oprot)
            oprot.writeFieldEnd()
        if self.deadline_s is not None:
            oprot.writeFieldBegin('deadline_s', TType.I64, 2)
            oprot.writeI64(self.deadline_s)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAdminRequest(object):
    """
    Attributes:
     - type
     - shutdown_params
    """


    def __init__(self, type=None, shutdown_params=None,):
        self.type = type
        self.shutdown_params = shutdown_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.shutdown_params = TShutdownParams()
                    self.shutdown_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAdminRequest')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.shutdown_params is not None:
            oprot.writeFieldBegin('shutdown_params', TType.STRUCT, 2)
            self.shutdown_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMetadataOpRequest(object):
    """
    Attributes:
     - opcode
     - get_info_req
     - get_type_info_req
     - get_catalogs_req
     - get_schemas_req
     - get_tables_req
     - get_table_types_req
     - get_columns_req
     - get_functions_req
     - session
     - get_primary_keys_req
     - get_cross_reference_req
    """


    def __init__(self, opcode=None, get_info_req=None, get_type_info_req=None, get_catalogs_req=None, get_schemas_req=None, get_tables_req=None, get_table_types_req=None, get_columns_req=None, get_functions_req=None, session=None, get_primary_keys_req=None, get_cross_reference_req=None,):
        self.opcode = opcode
        self.get_info_req = get_info_req
        self.get_type_info_req = get_type_info_req
        self.get_catalogs_req = get_catalogs_req
        self.get_schemas_req = get_schemas_req
        self.get_tables_req = get_tables_req
        self.get_table_types_req = get_table_types_req
        self.get_columns_req = get_columns_req
        self.get_functions_req = get_functions_req
        self.session = session
        self.get_primary_keys_req = get_primary_keys_req
        self.get_cross_reference_req = get_cross_reference_req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opcode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.get_info_req = TCLIService.ttypes.TGetInfoReq()
                    self.get_info_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.get_type_info_req = TCLIService.ttypes.TGetTypeInfoReq()
                    self.get_type_info_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.get_catalogs_req = TCLIService.ttypes.TGetCatalogsReq()
                    self.get_catalogs_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.get_schemas_req = TCLIService.ttypes.TGetSchemasReq()
                    self.get_schemas_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.get_tables_req = TCLIService.ttypes.TGetTablesReq()
                    self.get_tables_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.get_table_types_req = TCLIService.ttypes.TGetTableTypesReq()
                    self.get_table_types_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.get_columns_req = TCLIService.ttypes.TGetColumnsReq()
                    self.get_columns_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.get_functions_req = TCLIService.ttypes.TGetFunctionsReq()
                    self.get_functions_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.session = ImpalaInternalService.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.get_primary_keys_req = TCLIService.ttypes.TGetPrimaryKeysReq()
                    self.get_primary_keys_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.get_cross_reference_req = TCLIService.ttypes.TGetCrossReferenceReq()
                    self.get_cross_reference_req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMetadataOpRequest')
        if self.opcode is not None:
            oprot.writeFieldBegin('opcode', TType.I32, 1)
            oprot.writeI32(self.opcode)
            oprot.writeFieldEnd()
        if self.get_info_req is not None:
            oprot.writeFieldBegin('get_info_req', TType.STRUCT, 2)
            self.get_info_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_type_info_req is not None:
            oprot.writeFieldBegin('get_type_info_req', TType.STRUCT, 3)
            self.get_type_info_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_catalogs_req is not None:
            oprot.writeFieldBegin('get_catalogs_req', TType.STRUCT, 4)
            self.get_catalogs_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_schemas_req is not None:
            oprot.writeFieldBegin('get_schemas_req', TType.STRUCT, 5)
            self.get_schemas_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_tables_req is not None:
            oprot.writeFieldBegin('get_tables_req', TType.STRUCT, 6)
            self.get_tables_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_table_types_req is not None:
            oprot.writeFieldBegin('get_table_types_req', TType.STRUCT, 7)
            self.get_table_types_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_columns_req is not None:
            oprot.writeFieldBegin('get_columns_req', TType.STRUCT, 8)
            self.get_columns_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_functions_req is not None:
            oprot.writeFieldBegin('get_functions_req', TType.STRUCT, 9)
            self.get_functions_req.write(oprot)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 10)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        if self.get_primary_keys_req is not None:
            oprot.writeFieldBegin('get_primary_keys_req', TType.STRUCT, 11)
            self.get_primary_keys_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_cross_reference_req is not None:
            oprot.writeFieldBegin('get_cross_reference_req', TType.STRUCT, 12)
            self.get_cross_reference_req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.opcode is None:
            raise TProtocolException(message='Required field opcode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAccessEvent(object):
    """
    Attributes:
     - name
     - object_type
     - privilege
    """


    def __init__(self, name=None, object_type=None, privilege=None,):
        self.name = name
        self.object_type = object_type
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.object_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.privilege = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAccessEvent')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.object_type is not None:
            oprot.writeFieldBegin('object_type', TType.I32, 2)
            oprot.writeI32(self.object_type)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRING, 3)
            oprot.writeString(self.privilege.encode('utf-8') if sys.version_info[0] == 2 else self.privilege)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.object_type is None:
            raise TProtocolException(message='Required field object_type is unset!')
        if self.privilege is None:
            raise TProtocolException(message='Required field privilege is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecRequest(object):
    """
    Attributes:
     - stmt_type
     - query_options
     - query_exec_request
     - catalog_op_request
     - result_set_metadata
     - explain_result
     - load_data_request
     - access_events
     - analysis_warnings
     - set_query_option_request
     - timeline
     - user_has_profile_access
     - admin_request
     - profile
     - testcase_data_path
    """


    def __init__(self, stmt_type=None, query_options=None, query_exec_request=None, catalog_op_request=None, result_set_metadata=None, explain_result=None, load_data_request=None, access_events=None, analysis_warnings=None, set_query_option_request=None, timeline=None, user_has_profile_access=None, admin_request=None, profile=None, testcase_data_path=None,):
        self.stmt_type = stmt_type
        self.query_options = query_options
        self.query_exec_request = query_exec_request
        self.catalog_op_request = catalog_op_request
        self.result_set_metadata = result_set_metadata
        self.explain_result = explain_result
        self.load_data_request = load_data_request
        self.access_events = access_events
        self.analysis_warnings = analysis_warnings
        self.set_query_option_request = set_query_option_request
        self.timeline = timeline
        self.user_has_profile_access = user_has_profile_access
        self.admin_request = admin_request
        self.profile = profile
        self.testcase_data_path = testcase_data_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.stmt_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query_options = ImpalaInternalService.ttypes.TQueryOptions()
                    self.query_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query_exec_request = TQueryExecRequest()
                    self.query_exec_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.catalog_op_request = TCatalogOpRequest()
                    self.catalog_op_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.result_set_metadata = Results.ttypes.TResultSetMetadata()
                    self.result_set_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.explain_result = TExplainResult()
                    self.explain_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.load_data_request = TLoadDataReq()
                    self.load_data_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.access_events = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = TAccessEvent()
                        _elem154.read(iprot)
                        self.access_events.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.analysis_warnings = []
                    (_etype158, _size155) = iprot.readListBegin()
                    for _i159 in range(_size155):
                        _elem160 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.analysis_warnings.append(_elem160)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.set_query_option_request = TSetQueryOptionRequest()
                    self.set_query_option_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.timeline = RuntimeProfile.ttypes.TEventSequence()
                    self.timeline.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.user_has_profile_access = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.admin_request = TAdminRequest()
                    self.admin_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.profile = RuntimeProfile.ttypes.TRuntimeProfileNode()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.testcase_data_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecRequest')
        if self.stmt_type is not None:
            oprot.writeFieldBegin('stmt_type', TType.I32, 1)
            oprot.writeI32(self.stmt_type)
            oprot.writeFieldEnd()
        if self.query_options is not None:
            oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
            self.query_options.write(oprot)
            oprot.writeFieldEnd()
        if self.query_exec_request is not None:
            oprot.writeFieldBegin('query_exec_request', TType.STRUCT, 3)
            self.query_exec_request.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_op_request is not None:
            oprot.writeFieldBegin('catalog_op_request', TType.STRUCT, 4)
            self.catalog_op_request.write(oprot)
            oprot.writeFieldEnd()
        if self.result_set_metadata is not None:
            oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
            self.result_set_metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.explain_result is not None:
            oprot.writeFieldBegin('explain_result', TType.STRUCT, 6)
            self.explain_result.write(oprot)
            oprot.writeFieldEnd()
        if self.load_data_request is not None:
            oprot.writeFieldBegin('load_data_request', TType.STRUCT, 7)
            self.load_data_request.write(oprot)
            oprot.writeFieldEnd()
        if self.access_events is not None:
            oprot.writeFieldBegin('access_events', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.access_events))
            for iter161 in self.access_events:
                iter161.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.analysis_warnings is not None:
            oprot.writeFieldBegin('analysis_warnings', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.analysis_warnings))
            for iter162 in self.analysis_warnings:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.set_query_option_request is not None:
            oprot.writeFieldBegin('set_query_option_request', TType.STRUCT, 10)
            self.set_query_option_request.write(oprot)
            oprot.writeFieldEnd()
        if self.timeline is not None:
            oprot.writeFieldBegin('timeline', TType.STRUCT, 11)
            self.timeline.write(oprot)
            oprot.writeFieldEnd()
        if self.user_has_profile_access is not None:
            oprot.writeFieldBegin('user_has_profile_access', TType.BOOL, 12)
            oprot.writeBool(self.user_has_profile_access)
            oprot.writeFieldEnd()
        if self.admin_request is not None:
            oprot.writeFieldBegin('admin_request', TType.STRUCT, 13)
            self.admin_request.write(oprot)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 14)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        if self.testcase_data_path is not None:
            oprot.writeFieldBegin('testcase_data_path', TType.STRING, 15)
            oprot.writeString(self.testcase_data_path.encode('utf-8') if sys.version_info[0] == 2 else self.testcase_data_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stmt_type is None:
            raise TProtocolException(message='Required field stmt_type is unset!')
        if self.query_options is None:
            raise TProtocolException(message='Required field query_options is unset!')
        if self.analysis_warnings is None:
            raise TProtocolException(message='Required field analysis_warnings is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCacheJarParams(object):
    """
    Attributes:
     - hdfs_location
    """


    def __init__(self, hdfs_location=None,):
        self.hdfs_location = hdfs_location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hdfs_location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCacheJarParams')
        if self.hdfs_location is not None:
            oprot.writeFieldBegin('hdfs_location', TType.STRING, 1)
            oprot.writeString(self.hdfs_location.encode('utf-8') if sys.version_info[0] == 2 else self.hdfs_location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hdfs_location is None:
            raise TProtocolException(message='Required field hdfs_location is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCacheJarResult(object):
    """
    Attributes:
     - status
     - local_path
    """


    def __init__(self, status=None, local_path=None,):
        self.status = status
        self.local_path = local_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.local_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCacheJarResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.local_path is not None:
            oprot.writeFieldBegin('local_path', TType.STRING, 2)
            oprot.writeString(self.local_path.encode('utf-8') if sys.version_info[0] == 2 else self.local_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSymbolLookupParams(object):
    """
    Attributes:
     - location
     - symbol
     - fn_binary_type
     - arg_types
     - has_var_args
     - ret_arg_type
     - symbol_type
     - needs_refresh
    """


    def __init__(self, location=None, symbol=None, fn_binary_type=None, arg_types=None, has_var_args=None, ret_arg_type=None, symbol_type=None, needs_refresh=None,):
        self.location = location
        self.symbol = symbol
        self.fn_binary_type = fn_binary_type
        self.arg_types = arg_types
        self.has_var_args = has_var_args
        self.ret_arg_type = ret_arg_type
        self.symbol_type = symbol_type
        self.needs_refresh = needs_refresh

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fn_binary_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.arg_types = []
                    (_etype166, _size163) = iprot.readListBegin()
                    for _i167 in range(_size163):
                        _elem168 = Types.ttypes.TColumnType()
                        _elem168.read(iprot)
                        self.arg_types.append(_elem168)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.has_var_args = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ret_arg_type = Types.ttypes.TColumnType()
                    self.ret_arg_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.symbol_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.needs_refresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSymbolLookupParams')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 1)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 2)
            oprot.writeString(self.symbol.encode('utf-8') if sys.version_info[0] == 2 else self.symbol)
            oprot.writeFieldEnd()
        if self.fn_binary_type is not None:
            oprot.writeFieldBegin('fn_binary_type', TType.I32, 3)
            oprot.writeI32(self.fn_binary_type)
            oprot.writeFieldEnd()
        if self.arg_types is not None:
            oprot.writeFieldBegin('arg_types', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
            for iter169 in self.arg_types:
                iter169.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.has_var_args is not None:
            oprot.writeFieldBegin('has_var_args', TType.BOOL, 5)
            oprot.writeBool(self.has_var_args)
            oprot.writeFieldEnd()
        if self.ret_arg_type is not None:
            oprot.writeFieldBegin('ret_arg_type', TType.STRUCT, 6)
            self.ret_arg_type.write(oprot)
            oprot.writeFieldEnd()
        if self.symbol_type is not None:
            oprot.writeFieldBegin('symbol_type', TType.I32, 7)
            oprot.writeI32(self.symbol_type)
            oprot.writeFieldEnd()
        if self.needs_refresh is not None:
            oprot.writeFieldBegin('needs_refresh', TType.BOOL, 8)
            oprot.writeBool(self.needs_refresh)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        if self.symbol is None:
            raise TProtocolException(message='Required field symbol is unset!')
        if self.fn_binary_type is None:
            raise TProtocolException(message='Required field fn_binary_type is unset!')
        if self.arg_types is None:
            raise TProtocolException(message='Required field arg_types is unset!')
        if self.has_var_args is None:
            raise TProtocolException(message='Required field has_var_args is unset!')
        if self.symbol_type is None:
            raise TProtocolException(message='Required field symbol_type is unset!')
        if self.needs_refresh is None:
            raise TProtocolException(message='Required field needs_refresh is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSymbolLookupResult(object):
    """
    Attributes:
     - result_code
     - symbol
     - error_msg
     - last_modified_time
    """


    def __init__(self, result_code=None, symbol=None, error_msg=None, last_modified_time=None,):
        self.result_code = result_code
        self.symbol = symbol
        self.error_msg = error_msg
        self.last_modified_time = last_modified_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.error_msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.last_modified_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSymbolLookupResult')
        if self.result_code is not None:
            oprot.writeFieldBegin('result_code', TType.I32, 1)
            oprot.writeI32(self.result_code)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 2)
            oprot.writeString(self.symbol.encode('utf-8') if sys.version_info[0] == 2 else self.symbol)
            oprot.writeFieldEnd()
        if self.error_msg is not None:
            oprot.writeFieldBegin('error_msg', TType.STRING, 3)
            oprot.writeString(self.error_msg.encode('utf-8') if sys.version_info[0] == 2 else self.error_msg)
            oprot.writeFieldEnd()
        if self.last_modified_time is not None:
            oprot.writeFieldBegin('last_modified_time', TType.I64, 4)
            oprot.writeI64(self.last_modified_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result_code is None:
            raise TProtocolException(message='Required field result_code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogCacheRequest(object):
    """
    Attributes:
     - is_delta
     - catalog_service_id
     - updated_objects_deprecated
     - removed_objects_deprecated
     - native_iterator_ptr
    """


    def __init__(self, is_delta=None, catalog_service_id=None, updated_objects_deprecated=None, removed_objects_deprecated=None, native_iterator_ptr=None,):
        self.is_delta = is_delta
        self.catalog_service_id = catalog_service_id
        self.updated_objects_deprecated = updated_objects_deprecated
        self.removed_objects_deprecated = removed_objects_deprecated
        self.native_iterator_ptr = native_iterator_ptr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_delta = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.updated_objects_deprecated = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = CatalogObjects.ttypes.TCatalogObject()
                        _elem175.read(iprot)
                        self.updated_objects_deprecated.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.removed_objects_deprecated = []
                    (_etype179, _size176) = iprot.readListBegin()
                    for _i180 in range(_size176):
                        _elem181 = CatalogObjects.ttypes.TCatalogObject()
                        _elem181.read(iprot)
                        self.removed_objects_deprecated.append(_elem181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.native_iterator_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogCacheRequest')
        if self.is_delta is not None:
            oprot.writeFieldBegin('is_delta', TType.BOOL, 1)
            oprot.writeBool(self.is_delta)
            oprot.writeFieldEnd()
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 2)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.updated_objects_deprecated is not None:
            oprot.writeFieldBegin('updated_objects_deprecated', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.updated_objects_deprecated))
            for iter182 in self.updated_objects_deprecated:
                iter182.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.removed_objects_deprecated is not None:
            oprot.writeFieldBegin('removed_objects_deprecated', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.removed_objects_deprecated))
            for iter183 in self.removed_objects_deprecated:
                iter183.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.native_iterator_ptr is not None:
            oprot.writeFieldBegin('native_iterator_ptr', TType.I64, 5)
            oprot.writeI64(self.native_iterator_ptr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_delta is None:
            raise TProtocolException(message='Required field is_delta is unset!')
        if self.native_iterator_ptr is None:
            raise TProtocolException(message='Required field native_iterator_ptr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogCacheResponse(object):
    """
    Attributes:
     - catalog_service_id
     - catalog_object_version_lower_bound
     - new_catalog_version
    """


    def __init__(self, catalog_service_id=None, catalog_object_version_lower_bound=None, new_catalog_version=None,):
        self.catalog_service_id = catalog_service_id
        self.catalog_object_version_lower_bound = catalog_object_version_lower_bound
        self.new_catalog_version = new_catalog_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.catalog_object_version_lower_bound = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.new_catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogCacheResponse')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_object_version_lower_bound is not None:
            oprot.writeFieldBegin('catalog_object_version_lower_bound', TType.I64, 2)
            oprot.writeI64(self.catalog_object_version_lower_bound)
            oprot.writeFieldEnd()
        if self.new_catalog_version is not None:
            oprot.writeFieldBegin('new_catalog_version', TType.I64, 3)
            oprot.writeI64(self.new_catalog_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.catalog_object_version_lower_bound is None:
            raise TProtocolException(message='Required field catalog_object_version_lower_bound is unset!')
        if self.new_catalog_version is None:
            raise TProtocolException(message='Required field new_catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateExecutorMembershipRequest(object):
    """
    Attributes:
     - hostnames
     - ip_addresses
     - num_executors
    """


    def __init__(self, hostnames=None, ip_addresses=None, num_executors=None,):
        self.hostnames = hostnames
        self.ip_addresses = ip_addresses
        self.num_executors = num_executors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.hostnames = set()
                    (_etype187, _size184) = iprot.readSetBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.hostnames.add(_elem189)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.ip_addresses = set()
                    (_etype193, _size190) = iprot.readSetBegin()
                    for _i194 in range(_size190):
                        _elem195 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ip_addresses.add(_elem195)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_executors = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateExecutorMembershipRequest')
        if self.hostnames is not None:
            oprot.writeFieldBegin('hostnames', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.hostnames))
            for iter196 in self.hostnames:
                oprot.writeString(iter196.encode('utf-8') if sys.version_info[0] == 2 else iter196)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ip_addresses is not None:
            oprot.writeFieldBegin('ip_addresses', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.ip_addresses))
            for iter197 in self.ip_addresses:
                oprot.writeString(iter197.encode('utf-8') if sys.version_info[0] == 2 else iter197)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.num_executors is not None:
            oprot.writeFieldBegin('num_executors', TType.I32, 3)
            oprot.writeI32(self.num_executors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostnames is None:
            raise TProtocolException(message='Required field hostnames is unset!')
        if self.ip_addresses is None:
            raise TProtocolException(message='Required field ip_addresses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJvmMemoryPool(object):
    """
    Attributes:
     - committed
     - init
     - max
     - used
     - peak_committed
     - peak_init
     - peak_max
     - peak_used
     - name
    """


    def __init__(self, committed=None, init=None, max=None, used=None, peak_committed=None, peak_init=None, peak_max=None, peak_used=None, name=None,):
        self.committed = committed
        self.init = init
        self.max = max
        self.used = used
        self.peak_committed = peak_committed
        self.peak_init = peak_init
        self.peak_max = peak_max
        self.peak_used = peak_used
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.committed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.init = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.used = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.peak_committed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.peak_init = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.peak_max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.peak_used = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJvmMemoryPool')
        if self.committed is not None:
            oprot.writeFieldBegin('committed', TType.I64, 1)
            oprot.writeI64(self.committed)
            oprot.writeFieldEnd()
        if self.init is not None:
            oprot.writeFieldBegin('init', TType.I64, 2)
            oprot.writeI64(self.init)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.I64, 3)
            oprot.writeI64(self.max)
            oprot.writeFieldEnd()
        if self.used is not None:
            oprot.writeFieldBegin('used', TType.I64, 4)
            oprot.writeI64(self.used)
            oprot.writeFieldEnd()
        if self.peak_committed is not None:
            oprot.writeFieldBegin('peak_committed', TType.I64, 5)
            oprot.writeI64(self.peak_committed)
            oprot.writeFieldEnd()
        if self.peak_init is not None:
            oprot.writeFieldBegin('peak_init', TType.I64, 6)
            oprot.writeI64(self.peak_init)
            oprot.writeFieldEnd()
        if self.peak_max is not None:
            oprot.writeFieldBegin('peak_max', TType.I64, 7)
            oprot.writeI64(self.peak_max)
            oprot.writeFieldEnd()
        if self.peak_used is not None:
            oprot.writeFieldBegin('peak_used', TType.I64, 8)
            oprot.writeI64(self.peak_used)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 9)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.committed is None:
            raise TProtocolException(message='Required field committed is unset!')
        if self.init is None:
            raise TProtocolException(message='Required field init is unset!')
        if self.max is None:
            raise TProtocolException(message='Required field max is unset!')
        if self.used is None:
            raise TProtocolException(message='Required field used is unset!')
        if self.peak_committed is None:
            raise TProtocolException(message='Required field peak_committed is unset!')
        if self.peak_init is None:
            raise TProtocolException(message='Required field peak_init is unset!')
        if self.peak_max is None:
            raise TProtocolException(message='Required field peak_max is unset!')
        if self.peak_used is None:
            raise TProtocolException(message='Required field peak_used is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmMemoryMetricsResponse(object):
    """
    Attributes:
     - memory_pools
     - gc_num_warn_threshold_exceeded
     - gc_num_info_threshold_exceeded
     - gc_total_extra_sleep_time_millis
     - gc_count
     - gc_time_millis
    """


    def __init__(self, memory_pools=None, gc_num_warn_threshold_exceeded=None, gc_num_info_threshold_exceeded=None, gc_total_extra_sleep_time_millis=None, gc_count=None, gc_time_millis=None,):
        self.memory_pools = memory_pools
        self.gc_num_warn_threshold_exceeded = gc_num_warn_threshold_exceeded
        self.gc_num_info_threshold_exceeded = gc_num_info_threshold_exceeded
        self.gc_total_extra_sleep_time_millis = gc_total_extra_sleep_time_millis
        self.gc_count = gc_count
        self.gc_time_millis = gc_time_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.memory_pools = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = TJvmMemoryPool()
                        _elem203.read(iprot)
                        self.memory_pools.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.gc_num_warn_threshold_exceeded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.gc_num_info_threshold_exceeded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.gc_total_extra_sleep_time_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.gc_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.gc_time_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmMemoryMetricsResponse')
        if self.memory_pools is not None:
            oprot.writeFieldBegin('memory_pools', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.memory_pools))
            for iter204 in self.memory_pools:
                iter204.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.gc_num_warn_threshold_exceeded is not None:
            oprot.writeFieldBegin('gc_num_warn_threshold_exceeded', TType.I64, 2)
            oprot.writeI64(self.gc_num_warn_threshold_exceeded)
            oprot.writeFieldEnd()
        if self.gc_num_info_threshold_exceeded is not None:
            oprot.writeFieldBegin('gc_num_info_threshold_exceeded', TType.I64, 3)
            oprot.writeI64(self.gc_num_info_threshold_exceeded)
            oprot.writeFieldEnd()
        if self.gc_total_extra_sleep_time_millis is not None:
            oprot.writeFieldBegin('gc_total_extra_sleep_time_millis', TType.I64, 4)
            oprot.writeI64(self.gc_total_extra_sleep_time_millis)
            oprot.writeFieldEnd()
        if self.gc_count is not None:
            oprot.writeFieldBegin('gc_count', TType.I64, 5)
            oprot.writeI64(self.gc_count)
            oprot.writeFieldEnd()
        if self.gc_time_millis is not None:
            oprot.writeFieldBegin('gc_time_millis', TType.I64, 6)
            oprot.writeI64(self.gc_time_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.memory_pools is None:
            raise TProtocolException(message='Required field memory_pools is unset!')
        if self.gc_num_warn_threshold_exceeded is None:
            raise TProtocolException(message='Required field gc_num_warn_threshold_exceeded is unset!')
        if self.gc_num_info_threshold_exceeded is None:
            raise TProtocolException(message='Required field gc_num_info_threshold_exceeded is unset!')
        if self.gc_total_extra_sleep_time_millis is None:
            raise TProtocolException(message='Required field gc_total_extra_sleep_time_millis is unset!')
        if self.gc_count is None:
            raise TProtocolException(message='Required field gc_count is unset!')
        if self.gc_time_millis is None:
            raise TProtocolException(message='Required field gc_time_millis is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJvmThreadInfo(object):
    """
    Attributes:
     - summary
     - cpu_time_in_ns
     - user_time_in_ns
     - blocked_count
     - blocked_time_in_ms
     - is_in_native
    """


    def __init__(self, summary=None, cpu_time_in_ns=None, user_time_in_ns=None, blocked_count=None, blocked_time_in_ms=None, is_in_native=None,):
        self.summary = summary
        self.cpu_time_in_ns = cpu_time_in_ns
        self.user_time_in_ns = user_time_in_ns
        self.blocked_count = blocked_count
        self.blocked_time_in_ms = blocked_time_in_ms
        self.is_in_native = is_in_native

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.summary = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cpu_time_in_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.user_time_in_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.blocked_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.blocked_time_in_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_in_native = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJvmThreadInfo')
        if self.summary is not None:
            oprot.writeFieldBegin('summary', TType.STRING, 1)
            oprot.writeString(self.summary.encode('utf-8') if sys.version_info[0] == 2 else self.summary)
            oprot.writeFieldEnd()
        if self.cpu_time_in_ns is not None:
            oprot.writeFieldBegin('cpu_time_in_ns', TType.I64, 2)
            oprot.writeI64(self.cpu_time_in_ns)
            oprot.writeFieldEnd()
        if self.user_time_in_ns is not None:
            oprot.writeFieldBegin('user_time_in_ns', TType.I64, 3)
            oprot.writeI64(self.user_time_in_ns)
            oprot.writeFieldEnd()
        if self.blocked_count is not None:
            oprot.writeFieldBegin('blocked_count', TType.I64, 4)
            oprot.writeI64(self.blocked_count)
            oprot.writeFieldEnd()
        if self.blocked_time_in_ms is not None:
            oprot.writeFieldBegin('blocked_time_in_ms', TType.I64, 5)
            oprot.writeI64(self.blocked_time_in_ms)
            oprot.writeFieldEnd()
        if self.is_in_native is not None:
            oprot.writeFieldBegin('is_in_native', TType.BOOL, 6)
            oprot.writeBool(self.is_in_native)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.summary is None:
            raise TProtocolException(message='Required field summary is unset!')
        if self.cpu_time_in_ns is None:
            raise TProtocolException(message='Required field cpu_time_in_ns is unset!')
        if self.user_time_in_ns is None:
            raise TProtocolException(message='Required field user_time_in_ns is unset!')
        if self.blocked_count is None:
            raise TProtocolException(message='Required field blocked_count is unset!')
        if self.blocked_time_in_ms is None:
            raise TProtocolException(message='Required field blocked_time_in_ms is unset!')
        if self.is_in_native is None:
            raise TProtocolException(message='Required field is_in_native is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmThreadsInfoRequest(object):
    """
    Attributes:
     - get_complete_info
    """


    def __init__(self, get_complete_info=None,):
        self.get_complete_info = get_complete_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.get_complete_info = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmThreadsInfoRequest')
        if self.get_complete_info is not None:
            oprot.writeFieldBegin('get_complete_info', TType.BOOL, 1)
            oprot.writeBool(self.get_complete_info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.get_complete_info is None:
            raise TProtocolException(message='Required field get_complete_info is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmThreadsInfoResponse(object):
    """
    Attributes:
     - total_thread_count
     - daemon_thread_count
     - peak_thread_count
     - threads
    """


    def __init__(self, total_thread_count=None, daemon_thread_count=None, peak_thread_count=None, threads=None,):
        self.total_thread_count = total_thread_count
        self.daemon_thread_count = daemon_thread_count
        self.peak_thread_count = peak_thread_count
        self.threads = threads

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.total_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.daemon_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.peak_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.threads = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = TJvmThreadInfo()
                        _elem210.read(iprot)
                        self.threads.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmThreadsInfoResponse')
        if self.total_thread_count is not None:
            oprot.writeFieldBegin('total_thread_count', TType.I32, 1)
            oprot.writeI32(self.total_thread_count)
            oprot.writeFieldEnd()
        if self.daemon_thread_count is not None:
            oprot.writeFieldBegin('daemon_thread_count', TType.I32, 2)
            oprot.writeI32(self.daemon_thread_count)
            oprot.writeFieldEnd()
        if self.peak_thread_count is not None:
            oprot.writeFieldBegin('peak_thread_count', TType.I32, 3)
            oprot.writeI32(self.peak_thread_count)
            oprot.writeFieldEnd()
        if self.threads is not None:
            oprot.writeFieldBegin('threads', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.threads))
            for iter211 in self.threads:
                iter211.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.total_thread_count is None:
            raise TProtocolException(message='Required field total_thread_count is unset!')
        if self.daemon_thread_count is None:
            raise TProtocolException(message='Required field daemon_thread_count is unset!')
        if self.peak_thread_count is None:
            raise TProtocolException(message='Required field peak_thread_count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJMXJsonResponse(object):
    """
    Attributes:
     - jmx_json
    """


    def __init__(self, jmx_json=None,):
        self.jmx_json = jmx_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jmx_json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJMXJsonResponse')
        if self.jmx_json is not None:
            oprot.writeFieldBegin('jmx_json', TType.STRING, 1)
            oprot.writeString(self.jmx_json.encode('utf-8') if sys.version_info[0] == 2 else self.jmx_json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jmx_json is None:
            raise TProtocolException(message='Required field jmx_json is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopConfigRequest(object):
    """
    Attributes:
     - name
    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopConfigRequest')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopConfigResponse(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopConfigResponse')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllHadoopConfigsResponse(object):
    """
    Attributes:
     - configs
    """


    def __init__(self, configs=None,):
        self.configs = configs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.configs = {}
                    (_ktype213, _vtype214, _size212) = iprot.readMapBegin()
                    for _i216 in range(_size212):
                        _key217 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val218 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.configs[_key217] = _val218
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllHadoopConfigsResponse')
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
            for kiter219, viter220 in self.configs.items():
                oprot.writeString(kiter219.encode('utf-8') if sys.version_info[0] == 2 else kiter219)
                oprot.writeString(viter220.encode('utf-8') if sys.version_info[0] == 2 else viter220)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopGroupsRequest(object):
    """
    Attributes:
     - user
    """


    def __init__(self, user=None,):
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopGroupsRequest')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopGroupsResponse(object):
    """
    Attributes:
     - groups
    """


    def __init__(self, groups=None,):
        self.groups = groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.groups.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopGroupsResponse')
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter227 in self.groups:
                oprot.writeString(iter227.encode('utf-8') if sys.version_info[0] == 2 else iter227)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.groups is None:
            raise TProtocolException(message='Required field groups is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TBuildTestDescriptorTableParams(object):
    """
    Attributes:
     - slot_types
    """


    def __init__(self, slot_types=None,):
        self.slot_types = slot_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.slot_types = []
                    (_etype231, _size228) = iprot.readListBegin()
                    for _i232 in range(_size228):
                        _elem233 = []
                        (_etype237, _size234) = iprot.readListBegin()
                        for _i238 in range(_size234):
                            _elem239 = Types.ttypes.TColumnType()
                            _elem239.read(iprot)
                            _elem233.append(_elem239)
                        iprot.readListEnd()
                        self.slot_types.append(_elem233)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBuildTestDescriptorTableParams')
        if self.slot_types is not None:
            oprot.writeFieldBegin('slot_types', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.slot_types))
            for iter240 in self.slot_types:
                oprot.writeListBegin(TType.STRUCT, len(iter240))
                for iter241 in iter240:
                    iter241.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.slot_types is None:
            raise TProtocolException(message='Required field slot_types is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTestCaseData(object):
    """
    Attributes:
     - query_stmt
     - tables_and_views
     - dbs
     - testcase_data_path
     - impala_version
    """


    def __init__(self, query_stmt=None, tables_and_views=None, dbs=None, testcase_data_path=None, impala_version=None,):
        self.query_stmt = query_stmt
        self.tables_and_views = tables_and_views
        self.dbs = dbs
        self.testcase_data_path = testcase_data_path
        self.impala_version = impala_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.query_stmt = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tables_and_views = []
                    (_etype245, _size242) = iprot.readListBegin()
                    for _i246 in range(_size242):
                        _elem247 = CatalogObjects.ttypes.TTable()
                        _elem247.read(iprot)
                        self.tables_and_views.append(_elem247)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dbs = []
                    (_etype251, _size248) = iprot.readListBegin()
                    for _i252 in range(_size248):
                        _elem253 = CatalogObjects.ttypes.TDatabase()
                        _elem253.read(iprot)
                        self.dbs.append(_elem253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.testcase_data_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.impala_version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTestCaseData')
        if self.query_stmt is not None:
            oprot.writeFieldBegin('query_stmt', TType.STRING, 1)
            oprot.writeString(self.query_stmt.encode('utf-8') if sys.version_info[0] == 2 else self.query_stmt)
            oprot.writeFieldEnd()
        if self.tables_and_views is not None:
            oprot.writeFieldBegin('tables_and_views', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.tables_and_views))
            for iter254 in self.tables_and_views:
                iter254.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dbs is not None:
            oprot.writeFieldBegin('dbs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dbs))
            for iter255 in self.dbs:
                iter255.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.testcase_data_path is not None:
            oprot.writeFieldBegin('testcase_data_path', TType.STRING, 4)
            oprot.writeString(self.testcase_data_path.encode('utf-8') if sys.version_info[0] == 2 else self.testcase_data_path)
            oprot.writeFieldEnd()
        if self.impala_version is not None:
            oprot.writeFieldBegin('impala_version', TType.STRING, 5)
            oprot.writeString(self.impala_version.encode('utf-8') if sys.version_info[0] == 2 else self.impala_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.query_stmt is None:
            raise TProtocolException(message='Required field query_stmt is unset!')
        if self.testcase_data_path is None:
            raise TProtocolException(message='Required field testcase_data_path is unset!')
        if self.impala_version is None:
            raise TProtocolException(message='Required field impala_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TQueryCompleteContext(object):
    """
    Attributes:
     - lineage_string
    """


    def __init__(self, lineage_string=None,):
        self.lineage_string = lineage_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.lineage_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryCompleteContext')
        if self.lineage_string is not None:
            oprot.writeFieldBegin('lineage_string', TType.STRING, 1)
            oprot.writeString(self.lineage_string.encode('utf-8') if sys.version_info[0] == 2 else self.lineage_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineage_string is None:
            raise TProtocolException(message='Required field lineage_string is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(THiveUdfExecutorCtorParams)
THiveUdfExecutorCtorParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 1
    (2, TType.STRING, 'local_location', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'input_byte_offsets', (TType.I32, None, False), None, ),  # 3
    (4, TType.I64, 'input_nulls_ptr', None, None, ),  # 4
    (5, TType.I64, 'input_buffer_ptr', None, None, ),  # 5
    (6, TType.I64, 'output_null_ptr', None, None, ),  # 6
    (7, TType.I64, 'output_buffer_ptr', None, None, ),  # 7
)
all_structs.append(TGetTablesParams)
TGetTablesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'session', [ImpalaInternalService.ttypes.TSessionState, None], None, ),  # 3
)
all_structs.append(TGetTablesResult)
TGetTablesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TGetTableMetricsParams)
TGetTableMetricsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
)
all_structs.append(TGetTableMetricsResponse)
TGetTableMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'metrics', 'UTF8', None, ),  # 1
)
all_structs.append(TGetCatalogMetricsResult)
TGetCatalogMetricsResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_dbs', None, None, ),  # 1
    (2, TType.I32, 'num_tables', None, None, ),  # 2
    (3, TType.I64, 'cache_eviction_count', None, None, ),  # 3
    (4, TType.I64, 'cache_hit_count', None, None, ),  # 4
    (5, TType.I64, 'cache_load_count', None, None, ),  # 5
    (6, TType.I64, 'cache_load_exception_count', None, None, ),  # 6
    (7, TType.I64, 'cache_load_success_count', None, None, ),  # 7
    (8, TType.I64, 'cache_miss_count', None, None, ),  # 8
    (9, TType.I64, 'cache_request_count', None, None, ),  # 9
    (10, TType.I64, 'cache_total_load_time', None, None, ),  # 10
    (11, TType.DOUBLE, 'cache_avg_load_time', None, None, ),  # 11
    (12, TType.DOUBLE, 'cache_hit_rate', None, None, ),  # 12
    (13, TType.DOUBLE, 'cache_load_exception_rate', None, None, ),  # 13
    (14, TType.DOUBLE, 'cache_miss_rate', None, None, ),  # 14
)
all_structs.append(TGetDbsParams)
TGetDbsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pattern', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'session', [ImpalaInternalService.ttypes.TSessionState, None], None, ),  # 2
)
all_structs.append(TGetDbsResult)
TGetDbsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dbs', (TType.STRUCT, [CatalogObjects.ttypes.TDatabase, None], False), None, ),  # 1
)
all_structs.append(TGetDataSrcsParams)
TGetDataSrcsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pattern', 'UTF8', None, ),  # 1
)
all_structs.append(TGetDataSrcsResult)
TGetDataSrcsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data_src_names', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'locations', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'class_names', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'api_versions', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TDescribeDbParams)
TDescribeDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
    (2, TType.I32, 'output_style', None, None, ),  # 2
)
all_structs.append(TDescribeTableParams)
TDescribeTableParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'output_style', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRUCT, 'result_struct', [Types.ttypes.TColumnType, None], None, ),  # 3
    (4, TType.STRUCT, 'session', [ImpalaInternalService.ttypes.TSessionState, None], None, ),  # 4
)
all_structs.append(TDescribeResult)
TDescribeResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'results', (TType.STRUCT, [Data.ttypes.TResultRow, None], False), None, ),  # 1
)
all_structs.append(TShowDataSrcsParams)
TShowDataSrcsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'show_pattern', 'UTF8', None, ),  # 1
)
all_structs.append(TShowDbsParams)
TShowDbsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'show_pattern', 'UTF8', None, ),  # 1
)
all_structs.append(TShowStatsParams)
TShowStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
)
all_structs.append(TShowFunctionsParams)
TShowFunctionsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'category', None, None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'show_pattern', 'UTF8', None, ),  # 3
)
all_structs.append(TShowTablesParams)
TShowTablesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'show_pattern', 'UTF8', None, ),  # 2
)
all_structs.append(TShowFilesParams)
TShowFilesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TShowRolesParams)
TShowRolesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', 'UTF8', None, ),  # 1
    None,  # 2
    (3, TType.BOOL, 'is_show_current_roles', None, None, ),  # 3
    (4, TType.STRING, 'grant_group', 'UTF8', None, ),  # 4
)
all_structs.append(TShowRolesResult)
TShowRolesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'role_names', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TShowGrantPrincipalParams)
TShowGrantPrincipalParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
    None,  # 4
    (5, TType.STRUCT, 'privilege', [CatalogObjects.ttypes.TPrivilege, None], None, ),  # 5
)
all_structs.append(TGetFunctionsParams)
TGetFunctionsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'category', None, None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'pattern', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'session', [ImpalaInternalService.ttypes.TSessionState, None], None, ),  # 4
)
all_structs.append(TGetFunctionsResult)
TGetFunctionsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fn_signatures', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'fn_ret_types', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'fn_binary_types', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'fn_persistence', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TUseDbParams)
TUseDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
)
all_structs.append(TExplainResult)
TExplainResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'results', (TType.STRUCT, [Data.ttypes.TResultRow, None], False), None, ),  # 1
)
all_structs.append(TFinalizeParams)
TFinalizeParams.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_overwrite', None, None, ),  # 1
    (2, TType.STRING, 'hdfs_base_dir', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'table_db', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'staging_dir', 'UTF8', None, ),  # 5
    (6, TType.I64, 'table_id', None, None, ),  # 6
    (7, TType.I64, 'transaction_id', None, None, ),  # 7
    (8, TType.I64, 'write_id', None, None, ),  # 8
)
all_structs.append(TLoadDataReq)
TLoadDataReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'source_path', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'overwrite', None, None, ),  # 3
    (4, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 4
)
all_structs.append(TLoadDataResp)
TLoadDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'load_summary', [Data.ttypes.TResultRow, None], None, ),  # 1
)
all_structs.append(TPlanExecInfo)
TPlanExecInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT, [Planner.ttypes.TPlanFragment, None], False), None, ),  # 1
    (2, TType.MAP, 'per_node_scan_ranges', (TType.I32, None, TType.STRUCT, [Planner.ttypes.TScanRangeSpec, None], False), None, ),  # 2
)
all_structs.append(TQueryExecRequest)
TQueryExecRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'plan_exec_info', (TType.STRUCT, [TPlanExecInfo, None], False), None, ),  # 1
    (2, TType.STRUCT, 'result_set_metadata', [Results.ttypes.TResultSetMetadata, None], None, ),  # 2
    (3, TType.STRUCT, 'finalize_params', [TFinalizeParams, None], None, ),  # 3
    (4, TType.STRUCT, 'query_ctx', [ImpalaInternalService.ttypes.TQueryCtx, None], None, ),  # 4
    (5, TType.STRING, 'query_plan', 'UTF8', None, ),  # 5
    (6, TType.I32, 'stmt_type', None, None, ),  # 6
    (7, TType.LIST, 'host_list', (TType.STRUCT, [Types.ttypes.TNetworkAddress, None], False), None, ),  # 7
    (8, TType.STRUCT, 'lineage_graph', [LineageGraph.ttypes.TLineageGraph, None], None, ),  # 8
    (9, TType.I64, 'per_host_mem_estimate', None, None, ),  # 9
    (10, TType.I64, 'max_per_host_min_mem_reservation', None, None, ),  # 10
    (11, TType.I64, 'max_per_host_thread_reservation', None, None, ),  # 11
    (12, TType.I64, 'dedicated_coord_mem_estimate', None, None, ),  # 12
)
all_structs.append(TCatalogOpRequest)
TCatalogOpRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op_type', None, None, ),  # 1
    (2, TType.BOOL, 'sync_ddl', None, None, ),  # 2
    (3, TType.STRUCT, 'use_db_params', [TUseDbParams, None], None, ),  # 3
    (4, TType.STRUCT, 'describe_db_params', [TDescribeDbParams, None], None, ),  # 4
    (5, TType.STRUCT, 'describe_table_params', [TDescribeTableParams, None], None, ),  # 5
    (6, TType.STRUCT, 'show_dbs_params', [TShowDbsParams, None], None, ),  # 6
    (7, TType.STRUCT, 'show_tables_params', [TShowTablesParams, None], None, ),  # 7
    (8, TType.STRUCT, 'show_fns_params', [TShowFunctionsParams, None], None, ),  # 8
    (9, TType.STRUCT, 'show_data_srcs_params', [TShowDataSrcsParams, None], None, ),  # 9
    (10, TType.STRUCT, 'show_roles_params', [TShowRolesParams, None], None, ),  # 10
    (11, TType.STRUCT, 'show_grant_principal_params', [TShowGrantPrincipalParams, None], None, ),  # 11
    (12, TType.STRUCT, 'ddl_params', [CatalogService.ttypes.TDdlExecRequest, None], None, ),  # 12
    (13, TType.STRUCT, 'reset_metadata_params', [CatalogService.ttypes.TResetMetadataRequest, None], None, ),  # 13
    (14, TType.STRUCT, 'show_stats_params', [TShowStatsParams, None], None, ),  # 14
    (15, TType.STRUCT, 'show_create_table_params', [CatalogObjects.ttypes.TTableName, None], None, ),  # 15
    (16, TType.STRUCT, 'show_files_params', [TShowFilesParams, None], None, ),  # 16
    (17, TType.STRUCT, 'lineage_graph', [LineageGraph.ttypes.TLineageGraph, None], None, ),  # 17
    (18, TType.STRUCT, 'show_create_function_params', [TGetFunctionsParams, None], None, ),  # 18
)
all_structs.append(TSetQueryOptionRequest)
TSetQueryOptionRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'is_set_all', None, None, ),  # 3
)
all_structs.append(TShutdownParams)
TShutdownParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'backend', [Types.ttypes.TNetworkAddress, None], None, ),  # 1
    (2, TType.I64, 'deadline_s', None, None, ),  # 2
)
all_structs.append(TAdminRequest)
TAdminRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'shutdown_params', [TShutdownParams, None], None, ),  # 2
)
all_structs.append(TMetadataOpRequest)
TMetadataOpRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'opcode', None, None, ),  # 1
    (2, TType.STRUCT, 'get_info_req', [TCLIService.ttypes.TGetInfoReq, None], None, ),  # 2
    (3, TType.STRUCT, 'get_type_info_req', [TCLIService.ttypes.TGetTypeInfoReq, None], None, ),  # 3
    (4, TType.STRUCT, 'get_catalogs_req', [TCLIService.ttypes.TGetCatalogsReq, None], None, ),  # 4
    (5, TType.STRUCT, 'get_schemas_req', [TCLIService.ttypes.TGetSchemasReq, None], None, ),  # 5
    (6, TType.STRUCT, 'get_tables_req', [TCLIService.ttypes.TGetTablesReq, None], None, ),  # 6
    (7, TType.STRUCT, 'get_table_types_req', [TCLIService.ttypes.TGetTableTypesReq, None], None, ),  # 7
    (8, TType.STRUCT, 'get_columns_req', [TCLIService.ttypes.TGetColumnsReq, None], None, ),  # 8
    (9, TType.STRUCT, 'get_functions_req', [TCLIService.ttypes.TGetFunctionsReq, None], None, ),  # 9
    (10, TType.STRUCT, 'session', [ImpalaInternalService.ttypes.TSessionState, None], None, ),  # 10
    (11, TType.STRUCT, 'get_primary_keys_req', [TCLIService.ttypes.TGetPrimaryKeysReq, None], None, ),  # 11
    (12, TType.STRUCT, 'get_cross_reference_req', [TCLIService.ttypes.TGetCrossReferenceReq, None], None, ),  # 12
)
all_structs.append(TAccessEvent)
TAccessEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'object_type', None, None, ),  # 2
    (3, TType.STRING, 'privilege', 'UTF8', None, ),  # 3
)
all_structs.append(TExecRequest)
TExecRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'stmt_type', None, None, ),  # 1
    (2, TType.STRUCT, 'query_options', [ImpalaInternalService.ttypes.TQueryOptions, None], None, ),  # 2
    (3, TType.STRUCT, 'query_exec_request', [TQueryExecRequest, None], None, ),  # 3
    (4, TType.STRUCT, 'catalog_op_request', [TCatalogOpRequest, None], None, ),  # 4
    (5, TType.STRUCT, 'result_set_metadata', [Results.ttypes.TResultSetMetadata, None], None, ),  # 5
    (6, TType.STRUCT, 'explain_result', [TExplainResult, None], None, ),  # 6
    (7, TType.STRUCT, 'load_data_request', [TLoadDataReq, None], None, ),  # 7
    (8, TType.LIST, 'access_events', (TType.STRUCT, [TAccessEvent, None], False), None, ),  # 8
    (9, TType.LIST, 'analysis_warnings', (TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.STRUCT, 'set_query_option_request', [TSetQueryOptionRequest, None], None, ),  # 10
    (11, TType.STRUCT, 'timeline', [RuntimeProfile.ttypes.TEventSequence, None], None, ),  # 11
    (12, TType.BOOL, 'user_has_profile_access', None, None, ),  # 12
    (13, TType.STRUCT, 'admin_request', [TAdminRequest, None], None, ),  # 13
    (14, TType.STRUCT, 'profile', [RuntimeProfile.ttypes.TRuntimeProfileNode, None], None, ),  # 14
    (15, TType.STRING, 'testcase_data_path', 'UTF8', None, ),  # 15
)
all_structs.append(TCacheJarParams)
TCacheJarParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hdfs_location', 'UTF8', None, ),  # 1
)
all_structs.append(TCacheJarResult)
TCacheJarResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRING, 'local_path', 'UTF8', None, ),  # 2
)
all_structs.append(TSymbolLookupParams)
TSymbolLookupParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'location', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'symbol', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fn_binary_type', None, None, ),  # 3
    (4, TType.LIST, 'arg_types', (TType.STRUCT, [Types.ttypes.TColumnType, None], False), None, ),  # 4
    (5, TType.BOOL, 'has_var_args', None, None, ),  # 5
    (6, TType.STRUCT, 'ret_arg_type', [Types.ttypes.TColumnType, None], None, ),  # 6
    (7, TType.I32, 'symbol_type', None, None, ),  # 7
    (8, TType.BOOL, 'needs_refresh', None, None, ),  # 8
)
all_structs.append(TSymbolLookupResult)
TSymbolLookupResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result_code', None, None, ),  # 1
    (2, TType.STRING, 'symbol', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'error_msg', 'UTF8', None, ),  # 3
    (4, TType.I64, 'last_modified_time', None, None, ),  # 4
)
all_structs.append(TUpdateCatalogCacheRequest)
TUpdateCatalogCacheRequest.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_delta', None, None, ),  # 1
    (2, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.LIST, 'updated_objects_deprecated', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 3
    (4, TType.LIST, 'removed_objects_deprecated', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 4
    (5, TType.I64, 'native_iterator_ptr', None, None, ),  # 5
)
all_structs.append(TUpdateCatalogCacheResponse)
TUpdateCatalogCacheResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'catalog_object_version_lower_bound', None, None, ),  # 2
    (3, TType.I64, 'new_catalog_version', None, None, ),  # 3
)
all_structs.append(TUpdateExecutorMembershipRequest)
TUpdateExecutorMembershipRequest.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'hostnames', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.SET, 'ip_addresses', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'num_executors', None, None, ),  # 3
)
all_structs.append(TJvmMemoryPool)
TJvmMemoryPool.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'committed', None, None, ),  # 1
    (2, TType.I64, 'init', None, None, ),  # 2
    (3, TType.I64, 'max', None, None, ),  # 3
    (4, TType.I64, 'used', None, None, ),  # 4
    (5, TType.I64, 'peak_committed', None, None, ),  # 5
    (6, TType.I64, 'peak_init', None, None, ),  # 6
    (7, TType.I64, 'peak_max', None, None, ),  # 7
    (8, TType.I64, 'peak_used', None, None, ),  # 8
    (9, TType.STRING, 'name', 'UTF8', None, ),  # 9
)
all_structs.append(TGetJvmMemoryMetricsResponse)
TGetJvmMemoryMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'memory_pools', (TType.STRUCT, [TJvmMemoryPool, None], False), None, ),  # 1
    (2, TType.I64, 'gc_num_warn_threshold_exceeded', None, None, ),  # 2
    (3, TType.I64, 'gc_num_info_threshold_exceeded', None, None, ),  # 3
    (4, TType.I64, 'gc_total_extra_sleep_time_millis', None, None, ),  # 4
    (5, TType.I64, 'gc_count', None, None, ),  # 5
    (6, TType.I64, 'gc_time_millis', None, None, ),  # 6
)
all_structs.append(TJvmThreadInfo)
TJvmThreadInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'summary', 'UTF8', None, ),  # 1
    (2, TType.I64, 'cpu_time_in_ns', None, None, ),  # 2
    (3, TType.I64, 'user_time_in_ns', None, None, ),  # 3
    (4, TType.I64, 'blocked_count', None, None, ),  # 4
    (5, TType.I64, 'blocked_time_in_ms', None, None, ),  # 5
    (6, TType.BOOL, 'is_in_native', None, None, ),  # 6
)
all_structs.append(TGetJvmThreadsInfoRequest)
TGetJvmThreadsInfoRequest.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'get_complete_info', None, None, ),  # 1
)
all_structs.append(TGetJvmThreadsInfoResponse)
TGetJvmThreadsInfoResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'total_thread_count', None, None, ),  # 1
    (2, TType.I32, 'daemon_thread_count', None, None, ),  # 2
    (3, TType.I32, 'peak_thread_count', None, None, ),  # 3
    (4, TType.LIST, 'threads', (TType.STRUCT, [TJvmThreadInfo, None], False), None, ),  # 4
)
all_structs.append(TGetJMXJsonResponse)
TGetJMXJsonResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jmx_json', 'UTF8', None, ),  # 1
)
all_structs.append(TGetHadoopConfigRequest)
TGetHadoopConfigRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)
all_structs.append(TGetHadoopConfigResponse)
TGetHadoopConfigResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'UTF8', None, ),  # 1
)
all_structs.append(TGetAllHadoopConfigsResponse)
TGetAllHadoopConfigsResponse.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'configs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TGetHadoopGroupsRequest)
TGetHadoopGroupsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', 'UTF8', None, ),  # 1
)
all_structs.append(TGetHadoopGroupsResponse)
TGetHadoopGroupsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'groups', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TBuildTestDescriptorTableParams)
TBuildTestDescriptorTableParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'slot_types', (TType.LIST, (TType.STRUCT, [Types.ttypes.TColumnType, None], False), False), None, ),  # 1
)
all_structs.append(TTestCaseData)
TTestCaseData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'query_stmt', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tables_and_views', (TType.STRUCT, [CatalogObjects.ttypes.TTable, None], False), None, ),  # 2
    (3, TType.LIST, 'dbs', (TType.STRUCT, [CatalogObjects.ttypes.TDatabase, None], False), None, ),  # 3
    (4, TType.STRING, 'testcase_data_path', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'impala_version', 'UTF8', None, ),  # 5
)
all_structs.append(TQueryCompleteContext)
TQueryCompleteContext.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'lineage_string', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
