#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Types.ttypes

from thrift.transport import TTransport
all_structs = []


class TExprNodeType(object):
    NULL_LITERAL = 0
    BOOL_LITERAL = 1
    INT_LITERAL = 2
    FLOAT_LITERAL = 3
    STRING_LITERAL = 4
    DECIMAL_LITERAL = 5
    TIMESTAMP_LITERAL = 6
    CASE_EXPR = 7
    COMPOUND_PRED = 8
    IN_PRED = 9
    IS_NULL_PRED = 10
    LIKE_PRED = 11
    SLOT_REF = 12
    TUPLE_IS_NULL_PRED = 13
    FUNCTION_CALL = 14
    AGGREGATE_EXPR = 15
    IS_NOT_EMPTY_PRED = 16
    KUDU_PARTITION_EXPR = 17
    VALID_TUPLE_ID_EXPR = 18
    DATE_LITERAL = 19

    _VALUES_TO_NAMES = {
        0: "NULL_LITERAL",
        1: "BOOL_LITERAL",
        2: "INT_LITERAL",
        3: "FLOAT_LITERAL",
        4: "STRING_LITERAL",
        5: "DECIMAL_LITERAL",
        6: "TIMESTAMP_LITERAL",
        7: "CASE_EXPR",
        8: "COMPOUND_PRED",
        9: "IN_PRED",
        10: "IS_NULL_PRED",
        11: "LIKE_PRED",
        12: "SLOT_REF",
        13: "TUPLE_IS_NULL_PRED",
        14: "FUNCTION_CALL",
        15: "AGGREGATE_EXPR",
        16: "IS_NOT_EMPTY_PRED",
        17: "KUDU_PARTITION_EXPR",
        18: "VALID_TUPLE_ID_EXPR",
        19: "DATE_LITERAL",
    }

    _NAMES_TO_VALUES = {
        "NULL_LITERAL": 0,
        "BOOL_LITERAL": 1,
        "INT_LITERAL": 2,
        "FLOAT_LITERAL": 3,
        "STRING_LITERAL": 4,
        "DECIMAL_LITERAL": 5,
        "TIMESTAMP_LITERAL": 6,
        "CASE_EXPR": 7,
        "COMPOUND_PRED": 8,
        "IN_PRED": 9,
        "IS_NULL_PRED": 10,
        "LIKE_PRED": 11,
        "SLOT_REF": 12,
        "TUPLE_IS_NULL_PRED": 13,
        "FUNCTION_CALL": 14,
        "AGGREGATE_EXPR": 15,
        "IS_NOT_EMPTY_PRED": 16,
        "KUDU_PARTITION_EXPR": 17,
        "VALID_TUPLE_ID_EXPR": 18,
        "DATE_LITERAL": 19,
    }


class TExtractField(object):
    INVALID_FIELD = 0
    YEAR = 1
    QUARTER = 2
    MONTH = 3
    DAY = 4
    HOUR = 5
    MINUTE = 6
    SECOND = 7
    MILLISECOND = 8
    EPOCH = 9

    _VALUES_TO_NAMES = {
        0: "INVALID_FIELD",
        1: "YEAR",
        2: "QUARTER",
        3: "MONTH",
        4: "DAY",
        5: "HOUR",
        6: "MINUTE",
        7: "SECOND",
        8: "MILLISECOND",
        9: "EPOCH",
    }

    _NAMES_TO_VALUES = {
        "INVALID_FIELD": 0,
        "YEAR": 1,
        "QUARTER": 2,
        "MONTH": 3,
        "DAY": 4,
        "HOUR": 5,
        "MINUTE": 6,
        "SECOND": 7,
        "MILLISECOND": 8,
        "EPOCH": 9,
    }


class TBoolLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBoolLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 1)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCaseExpr(object):
    """
    Attributes:
     - has_case_expr
     - has_else_expr
    """


    def __init__(self, has_case_expr=None, has_else_expr=None,):
        self.has_case_expr = has_case_expr
        self.has_else_expr = has_else_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.has_case_expr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_else_expr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCaseExpr')
        if self.has_case_expr is not None:
            oprot.writeFieldBegin('has_case_expr', TType.BOOL, 1)
            oprot.writeBool(self.has_case_expr)
            oprot.writeFieldEnd()
        if self.has_else_expr is not None:
            oprot.writeFieldBegin('has_else_expr', TType.BOOL, 2)
            oprot.writeBool(self.has_else_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.has_case_expr is None:
            raise TProtocolException(message='Required field has_case_expr is unset!')
        if self.has_else_expr is None:
            raise TProtocolException(message='Required field has_else_expr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDateLiteral(object):
    """
    Attributes:
     - days_since_epoch
     - date_string
    """


    def __init__(self, days_since_epoch=None, date_string=None,):
        self.days_since_epoch = days_since_epoch
        self.date_string = date_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.days_since_epoch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.date_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDateLiteral')
        if self.days_since_epoch is not None:
            oprot.writeFieldBegin('days_since_epoch', TType.I32, 1)
            oprot.writeI32(self.days_since_epoch)
            oprot.writeFieldEnd()
        if self.date_string is not None:
            oprot.writeFieldBegin('date_string', TType.STRING, 2)
            oprot.writeString(self.date_string.encode('utf-8') if sys.version_info[0] == 2 else self.date_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.days_since_epoch is None:
            raise TProtocolException(message='Required field days_since_epoch is unset!')
        if self.date_string is None:
            raise TProtocolException(message='Required field date_string is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDecimalLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDecimalLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFloatLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFloatLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 1)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIntLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIntLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 1)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimestampLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimestampLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInPredicate(object):
    """
    Attributes:
     - is_not_in
    """


    def __init__(self, is_not_in=None,):
        self.is_not_in = is_not_in

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_not_in = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInPredicate')
        if self.is_not_in is not None:
            oprot.writeFieldBegin('is_not_in', TType.BOOL, 1)
            oprot.writeBool(self.is_not_in)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_not_in is None:
            raise TProtocolException(message='Required field is_not_in is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIsNullPredicate(object):
    """
    Attributes:
     - is_not_null
    """


    def __init__(self, is_not_null=None,):
        self.is_not_null = is_not_null

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_not_null = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIsNullPredicate')
        if self.is_not_null is not None:
            oprot.writeFieldBegin('is_not_null', TType.BOOL, 1)
            oprot.writeBool(self.is_not_null)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_not_null is None:
            raise TProtocolException(message='Required field is_not_null is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLiteralPredicate(object):
    """
    Attributes:
     - value
     - is_null
    """


    def __init__(self, value=None, is_null=None,):
        self.value = value
        self.is_null = is_null

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_null = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLiteralPredicate')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 1)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        if self.is_null is not None:
            oprot.writeFieldBegin('is_null', TType.BOOL, 2)
            oprot.writeBool(self.is_null)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.is_null is None:
            raise TProtocolException(message='Required field is_null is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTupleIsNullPredicate(object):
    """
    Attributes:
     - tuple_ids
    """


    def __init__(self, tuple_ids=None,):
        self.tuple_ids = tuple_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tuple_ids = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.tuple_ids.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTupleIsNullPredicate')
        if self.tuple_ids is not None:
            oprot.writeFieldBegin('tuple_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.tuple_ids))
            for iter6 in self.tuple_ids:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_ids is None:
            raise TProtocolException(message='Required field tuple_ids is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSlotRef(object):
    """
    Attributes:
     - slot_id
    """


    def __init__(self, slot_id=None,):
        self.slot_id = slot_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slot_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSlotRef')
        if self.slot_id is not None:
            oprot.writeFieldBegin('slot_id', TType.I32, 1)
            oprot.writeI32(self.slot_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.slot_id is None:
            raise TProtocolException(message='Required field slot_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStringLiteral(object):
    """
    Attributes:
     - value
    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStringLiteral')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAggregateExpr(object):
    """
    Attributes:
     - is_merge_agg
     - arg_types
    """


    def __init__(self, is_merge_agg=None, arg_types=None,):
        self.is_merge_agg = is_merge_agg
        self.arg_types = arg_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_merge_agg = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arg_types = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = Types.ttypes.TColumnType()
                        _elem12.read(iprot)
                        self.arg_types.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAggregateExpr')
        if self.is_merge_agg is not None:
            oprot.writeFieldBegin('is_merge_agg', TType.BOOL, 1)
            oprot.writeBool(self.is_merge_agg)
            oprot.writeFieldEnd()
        if self.arg_types is not None:
            oprot.writeFieldBegin('arg_types', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
            for iter13 in self.arg_types:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_merge_agg is None:
            raise TProtocolException(message='Required field is_merge_agg is unset!')
        if self.arg_types is None:
            raise TProtocolException(message='Required field arg_types is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionExpr(object):
    """
    Attributes:
     - target_table_id
     - referenced_columns
    """


    def __init__(self, target_table_id=None, referenced_columns=None,):
        self.target_table_id = target_table_id
        self.referenced_columns = referenced_columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.target_table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.referenced_columns = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.referenced_columns.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionExpr')
        if self.target_table_id is not None:
            oprot.writeFieldBegin('target_table_id', TType.I32, 1)
            oprot.writeI32(self.target_table_id)
            oprot.writeFieldEnd()
        if self.referenced_columns is not None:
            oprot.writeFieldBegin('referenced_columns', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.referenced_columns))
            for iter20 in self.referenced_columns:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target_table_id is None:
            raise TProtocolException(message='Required field target_table_id is unset!')
        if self.referenced_columns is None:
            raise TProtocolException(message='Required field referenced_columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCastExpr(object):
    """
    Attributes:
     - cast_format
    """


    def __init__(self, cast_format=None,):
        self.cast_format = cast_format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cast_format = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCastExpr')
        if self.cast_format is not None:
            oprot.writeFieldBegin('cast_format', TType.STRING, 1)
            oprot.writeString(self.cast_format.encode('utf-8') if sys.version_info[0] == 2 else self.cast_format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cast_format is None:
            raise TProtocolException(message='Required field cast_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExprNode(object):
    """
    Attributes:
     - node_type
     - type
     - num_children
     - is_constant
     - fn
     - vararg_start_idx
     - bool_literal
     - case_expr
     - date_literal
     - float_literal
     - int_literal
     - in_predicate
     - is_null_pred
     - literal_pred
     - slot_ref
     - string_literal
     - tuple_is_null_pred
     - decimal_literal
     - agg_expr
     - timestamp_literal
     - kudu_partition_expr
     - cast_expr
    """


    def __init__(self, node_type=None, type=None, num_children=None, is_constant=None, fn=None, vararg_start_idx=None, bool_literal=None, case_expr=None, date_literal=None, float_literal=None, int_literal=None, in_predicate=None, is_null_pred=None, literal_pred=None, slot_ref=None, string_literal=None, tuple_is_null_pred=None, decimal_literal=None, agg_expr=None, timestamp_literal=None, kudu_partition_expr=None, cast_expr=None,):
        self.node_type = node_type
        self.type = type
        self.num_children = num_children
        self.is_constant = is_constant
        self.fn = fn
        self.vararg_start_idx = vararg_start_idx
        self.bool_literal = bool_literal
        self.case_expr = case_expr
        self.date_literal = date_literal
        self.float_literal = float_literal
        self.int_literal = int_literal
        self.in_predicate = in_predicate
        self.is_null_pred = is_null_pred
        self.literal_pred = literal_pred
        self.slot_ref = slot_ref
        self.string_literal = string_literal
        self.tuple_is_null_pred = tuple_is_null_pred
        self.decimal_literal = decimal_literal
        self.agg_expr = agg_expr
        self.timestamp_literal = timestamp_literal
        self.kudu_partition_expr = kudu_partition_expr
        self.cast_expr = cast_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.type = Types.ttypes.TColumnType()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_children = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_constant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.vararg_start_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.bool_literal = TBoolLiteral()
                    self.bool_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.case_expr = TCaseExpr()
                    self.case_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.date_literal = TDateLiteral()
                    self.date_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.float_literal = TFloatLiteral()
                    self.float_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.int_literal = TIntLiteral()
                    self.int_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.in_predicate = TInPredicate()
                    self.in_predicate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.is_null_pred = TIsNullPredicate()
                    self.is_null_pred.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.literal_pred = TLiteralPredicate()
                    self.literal_pred.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.slot_ref = TSlotRef()
                    self.slot_ref.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.string_literal = TStringLiteral()
                    self.string_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.tuple_is_null_pred = TTupleIsNullPredicate()
                    self.tuple_is_null_pred.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.decimal_literal = TDecimalLiteral()
                    self.decimal_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.agg_expr = TAggregateExpr()
                    self.agg_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.timestamp_literal = TTimestampLiteral()
                    self.timestamp_literal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.kudu_partition_expr = TKuduPartitionExpr()
                    self.kudu_partition_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.cast_expr = TCastExpr()
                    self.cast_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExprNode')
        if self.node_type is not None:
            oprot.writeFieldBegin('node_type', TType.I32, 1)
            oprot.writeI32(self.node_type)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 2)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        if self.num_children is not None:
            oprot.writeFieldBegin('num_children', TType.I32, 3)
            oprot.writeI32(self.num_children)
            oprot.writeFieldEnd()
        if self.is_constant is not None:
            oprot.writeFieldBegin('is_constant', TType.BOOL, 4)
            oprot.writeBool(self.is_constant)
            oprot.writeFieldEnd()
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 5)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.vararg_start_idx is not None:
            oprot.writeFieldBegin('vararg_start_idx', TType.I32, 6)
            oprot.writeI32(self.vararg_start_idx)
            oprot.writeFieldEnd()
        if self.bool_literal is not None:
            oprot.writeFieldBegin('bool_literal', TType.STRUCT, 7)
            self.bool_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.case_expr is not None:
            oprot.writeFieldBegin('case_expr', TType.STRUCT, 8)
            self.case_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.date_literal is not None:
            oprot.writeFieldBegin('date_literal', TType.STRUCT, 9)
            self.date_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.float_literal is not None:
            oprot.writeFieldBegin('float_literal', TType.STRUCT, 10)
            self.float_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.int_literal is not None:
            oprot.writeFieldBegin('int_literal', TType.STRUCT, 11)
            self.int_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.in_predicate is not None:
            oprot.writeFieldBegin('in_predicate', TType.STRUCT, 12)
            self.in_predicate.write(oprot)
            oprot.writeFieldEnd()
        if self.is_null_pred is not None:
            oprot.writeFieldBegin('is_null_pred', TType.STRUCT, 13)
            self.is_null_pred.write(oprot)
            oprot.writeFieldEnd()
        if self.literal_pred is not None:
            oprot.writeFieldBegin('literal_pred', TType.STRUCT, 14)
            self.literal_pred.write(oprot)
            oprot.writeFieldEnd()
        if self.slot_ref is not None:
            oprot.writeFieldBegin('slot_ref', TType.STRUCT, 15)
            self.slot_ref.write(oprot)
            oprot.writeFieldEnd()
        if self.string_literal is not None:
            oprot.writeFieldBegin('string_literal', TType.STRUCT, 16)
            self.string_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.tuple_is_null_pred is not None:
            oprot.writeFieldBegin('tuple_is_null_pred', TType.STRUCT, 17)
            self.tuple_is_null_pred.write(oprot)
            oprot.writeFieldEnd()
        if self.decimal_literal is not None:
            oprot.writeFieldBegin('decimal_literal', TType.STRUCT, 18)
            self.decimal_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.agg_expr is not None:
            oprot.writeFieldBegin('agg_expr', TType.STRUCT, 19)
            self.agg_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp_literal is not None:
            oprot.writeFieldBegin('timestamp_literal', TType.STRUCT, 20)
            self.timestamp_literal.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_partition_expr is not None:
            oprot.writeFieldBegin('kudu_partition_expr', TType.STRUCT, 21)
            self.kudu_partition_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.cast_expr is not None:
            oprot.writeFieldBegin('cast_expr', TType.STRUCT, 22)
            self.cast_expr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.node_type is None:
            raise TProtocolException(message='Required field node_type is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.num_children is None:
            raise TProtocolException(message='Required field num_children is unset!')
        if self.is_constant is None:
            raise TProtocolException(message='Required field is_constant is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExpr(object):
    """
    Attributes:
     - nodes
    """


    def __init__(self, nodes=None,):
        self.nodes = nodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodes = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TExprNode()
                        _elem26.read(iprot)
                        self.nodes.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExpr')
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodes))
            for iter27 in self.nodes:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nodes is None:
            raise TProtocolException(message='Required field nodes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExprBatch(object):
    """
    Attributes:
     - exprs
    """


    def __init__(self, exprs=None,):
        self.exprs = exprs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.exprs = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = TExpr()
                        _elem33.read(iprot)
                        self.exprs.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExprBatch')
        if self.exprs is not None:
            oprot.writeFieldBegin('exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.exprs))
            for iter34 in self.exprs:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.exprs is None:
            raise TProtocolException(message='Required field exprs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TBoolLiteral)
TBoolLiteral.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'value', None, None, ),  # 1
)
all_structs.append(TCaseExpr)
TCaseExpr.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'has_case_expr', None, None, ),  # 1
    (2, TType.BOOL, 'has_else_expr', None, None, ),  # 2
)
all_structs.append(TDateLiteral)
TDateLiteral.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'days_since_epoch', None, None, ),  # 1
    (2, TType.STRING, 'date_string', 'UTF8', None, ),  # 2
)
all_structs.append(TDecimalLiteral)
TDecimalLiteral.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)
all_structs.append(TFloatLiteral)
TFloatLiteral.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'value', None, None, ),  # 1
)
all_structs.append(TIntLiteral)
TIntLiteral.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'value', None, None, ),  # 1
)
all_structs.append(TTimestampLiteral)
TTimestampLiteral.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)
all_structs.append(TInPredicate)
TInPredicate.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_not_in', None, None, ),  # 1
)
all_structs.append(TIsNullPredicate)
TIsNullPredicate.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_not_null', None, None, ),  # 1
)
all_structs.append(TLiteralPredicate)
TLiteralPredicate.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'value', None, None, ),  # 1
    (2, TType.BOOL, 'is_null', None, None, ),  # 2
)
all_structs.append(TTupleIsNullPredicate)
TTupleIsNullPredicate.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tuple_ids', (TType.I32, None, False), None, ),  # 1
)
all_structs.append(TSlotRef)
TSlotRef.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slot_id', None, None, ),  # 1
)
all_structs.append(TStringLiteral)
TStringLiteral.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'UTF8', None, ),  # 1
)
all_structs.append(TAggregateExpr)
TAggregateExpr.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_merge_agg', None, None, ),  # 1
    (2, TType.LIST, 'arg_types', (TType.STRUCT, [Types.ttypes.TColumnType, None], False), None, ),  # 2
)
all_structs.append(TKuduPartitionExpr)
TKuduPartitionExpr.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'target_table_id', None, None, ),  # 1
    (2, TType.LIST, 'referenced_columns', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(TCastExpr)
TCastExpr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cast_format', 'UTF8', None, ),  # 1
)
all_structs.append(TExprNode)
TExprNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_type', None, None, ),  # 1
    (2, TType.STRUCT, 'type', [Types.ttypes.TColumnType, None], None, ),  # 2
    (3, TType.I32, 'num_children', None, None, ),  # 3
    (4, TType.BOOL, 'is_constant', None, None, ),  # 4
    (5, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 5
    (6, TType.I32, 'vararg_start_idx', None, None, ),  # 6
    (7, TType.STRUCT, 'bool_literal', [TBoolLiteral, None], None, ),  # 7
    (8, TType.STRUCT, 'case_expr', [TCaseExpr, None], None, ),  # 8
    (9, TType.STRUCT, 'date_literal', [TDateLiteral, None], None, ),  # 9
    (10, TType.STRUCT, 'float_literal', [TFloatLiteral, None], None, ),  # 10
    (11, TType.STRUCT, 'int_literal', [TIntLiteral, None], None, ),  # 11
    (12, TType.STRUCT, 'in_predicate', [TInPredicate, None], None, ),  # 12
    (13, TType.STRUCT, 'is_null_pred', [TIsNullPredicate, None], None, ),  # 13
    (14, TType.STRUCT, 'literal_pred', [TLiteralPredicate, None], None, ),  # 14
    (15, TType.STRUCT, 'slot_ref', [TSlotRef, None], None, ),  # 15
    (16, TType.STRUCT, 'string_literal', [TStringLiteral, None], None, ),  # 16
    (17, TType.STRUCT, 'tuple_is_null_pred', [TTupleIsNullPredicate, None], None, ),  # 17
    (18, TType.STRUCT, 'decimal_literal', [TDecimalLiteral, None], None, ),  # 18
    (19, TType.STRUCT, 'agg_expr', [TAggregateExpr, None], None, ),  # 19
    (20, TType.STRUCT, 'timestamp_literal', [TTimestampLiteral, None], None, ),  # 20
    (21, TType.STRUCT, 'kudu_partition_expr', [TKuduPartitionExpr, None], None, ),  # 21
    (22, TType.STRUCT, 'cast_expr', [TCastExpr, None], None, ),  # 22
)
all_structs.append(TExpr)
TExpr.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT, [TExprNode, None], False), None, ),  # 1
)
all_structs.append(TExprBatch)
TExprBatch.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'exprs', (TType.STRUCT, [TExpr, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
