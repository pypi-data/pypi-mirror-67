#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import CatalogObjects.ttypes
import JniCatalog.ttypes
import Types.ttypes
import Status.ttypes
import Results.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes

from thrift.transport import TTransport
all_structs = []


class CatalogServiceVersion(object):
    V1 = 0

    _VALUES_TO_NAMES = {
        0: "V1",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
    }


class CatalogLookupStatus(object):
    OK = 0
    DB_NOT_FOUND = 1
    TABLE_NOT_FOUND = 2
    TABLE_NOT_LOADED = 3
    FUNCTION_NOT_FOUND = 4
    PARTITION_NOT_FOUND = 5

    _VALUES_TO_NAMES = {
        0: "OK",
        1: "DB_NOT_FOUND",
        2: "TABLE_NOT_FOUND",
        3: "TABLE_NOT_LOADED",
        4: "FUNCTION_NOT_FOUND",
        5: "PARTITION_NOT_FOUND",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "DB_NOT_FOUND": 1,
        "TABLE_NOT_FOUND": 2,
        "TABLE_NOT_LOADED": 3,
        "FUNCTION_NOT_FOUND": 4,
        "PARTITION_NOT_FOUND": 5,
    }


class TCatalogServiceRequestHeader(object):
    """
    Attributes:
     - requesting_user
     - redacted_sql_stmt
     - client_ip
    """


    def __init__(self, requesting_user=None, redacted_sql_stmt=None, client_ip=None,):
        self.requesting_user = requesting_user
        self.redacted_sql_stmt = redacted_sql_stmt
        self.client_ip = client_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.redacted_sql_stmt = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.client_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogServiceRequestHeader')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user.encode('utf-8') if sys.version_info[0] == 2 else self.requesting_user)
            oprot.writeFieldEnd()
        if self.redacted_sql_stmt is not None:
            oprot.writeFieldBegin('redacted_sql_stmt', TType.STRING, 2)
            oprot.writeString(self.redacted_sql_stmt.encode('utf-8') if sys.version_info[0] == 2 else self.redacted_sql_stmt)
            oprot.writeFieldEnd()
        if self.client_ip is not None:
            oprot.writeFieldBegin('client_ip', TType.STRING, 3)
            oprot.writeString(self.client_ip.encode('utf-8') if sys.version_info[0] == 2 else self.client_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogUpdateResult(object):
    """
    Attributes:
     - catalog_service_id
     - version
     - status
     - is_invalidate
     - updated_catalog_objects
     - removed_catalog_objects
    """


    def __init__(self, catalog_service_id=None, version=None, status=None, is_invalidate=None, updated_catalog_objects=None, removed_catalog_objects=None,):
        self.catalog_service_id = catalog_service_id
        self.version = version
        self.status = status
        self.is_invalidate = is_invalidate
        self.updated_catalog_objects = updated_catalog_objects
        self.removed_catalog_objects = removed_catalog_objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_invalidate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.updated_catalog_objects = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = CatalogObjects.ttypes.TCatalogObject()
                        _elem5.read(iprot)
                        self.updated_catalog_objects.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.removed_catalog_objects = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = CatalogObjects.ttypes.TCatalogObject()
                        _elem11.read(iprot)
                        self.removed_catalog_objects.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogUpdateResult')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 2)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.is_invalidate is not None:
            oprot.writeFieldBegin('is_invalidate', TType.BOOL, 4)
            oprot.writeBool(self.is_invalidate)
            oprot.writeFieldEnd()
        if self.updated_catalog_objects is not None:
            oprot.writeFieldBegin('updated_catalog_objects', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.updated_catalog_objects))
            for iter12 in self.updated_catalog_objects:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.removed_catalog_objects is not None:
            oprot.writeFieldBegin('removed_catalog_objects', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.removed_catalog_objects))
            for iter13 in self.removed_catalog_objects:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.is_invalidate is None:
            raise TProtocolException(message='Required field is_invalidate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDdlExecRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - ddl_type
     - alter_table_params
     - alter_view_params
     - create_db_params
     - create_table_params
     - create_table_like_params
     - create_view_params
     - create_fn_params
     - drop_db_params
     - drop_table_or_view_params
     - truncate_params
     - drop_fn_params
     - compute_stats_params
     - create_data_source_params
     - drop_data_source_params
     - drop_stats_params
     - create_drop_role_params
     - grant_revoke_role_params
     - grant_revoke_priv_params
     - sync_ddl
     - comment_on_params
     - alter_db_params
     - copy_test_case_params
    """


    def __init__(self, protocol_version=0, header=None, ddl_type=None, alter_table_params=None, alter_view_params=None, create_db_params=None, create_table_params=None, create_table_like_params=None, create_view_params=None, create_fn_params=None, drop_db_params=None, drop_table_or_view_params=None, truncate_params=None, drop_fn_params=None, compute_stats_params=None, create_data_source_params=None, drop_data_source_params=None, drop_stats_params=None, create_drop_role_params=None, grant_revoke_role_params=None, grant_revoke_priv_params=None, sync_ddl=None, comment_on_params=None, alter_db_params=None, copy_test_case_params=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.ddl_type = ddl_type
        self.alter_table_params = alter_table_params
        self.alter_view_params = alter_view_params
        self.create_db_params = create_db_params
        self.create_table_params = create_table_params
        self.create_table_like_params = create_table_like_params
        self.create_view_params = create_view_params
        self.create_fn_params = create_fn_params
        self.drop_db_params = drop_db_params
        self.drop_table_or_view_params = drop_table_or_view_params
        self.truncate_params = truncate_params
        self.drop_fn_params = drop_fn_params
        self.compute_stats_params = compute_stats_params
        self.create_data_source_params = create_data_source_params
        self.drop_data_source_params = drop_data_source_params
        self.drop_stats_params = drop_stats_params
        self.create_drop_role_params = create_drop_role_params
        self.grant_revoke_role_params = grant_revoke_role_params
        self.grant_revoke_priv_params = grant_revoke_priv_params
        self.sync_ddl = sync_ddl
        self.comment_on_params = comment_on_params
        self.alter_db_params = alter_db_params
        self.copy_test_case_params = copy_test_case_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ddl_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.alter_table_params = JniCatalog.ttypes.TAlterTableParams()
                    self.alter_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.alter_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
                    self.alter_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.create_db_params = JniCatalog.ttypes.TCreateDbParams()
                    self.create_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.create_table_params = JniCatalog.ttypes.TCreateTableParams()
                    self.create_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.create_table_like_params = JniCatalog.ttypes.TCreateTableLikeParams()
                    self.create_table_like_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.create_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
                    self.create_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.create_fn_params = JniCatalog.ttypes.TCreateFunctionParams()
                    self.create_fn_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.drop_db_params = JniCatalog.ttypes.TDropDbParams()
                    self.drop_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.drop_table_or_view_params = JniCatalog.ttypes.TDropTableOrViewParams()
                    self.drop_table_or_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.truncate_params = JniCatalog.ttypes.TTruncateParams()
                    self.truncate_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.drop_fn_params = JniCatalog.ttypes.TDropFunctionParams()
                    self.drop_fn_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.compute_stats_params = JniCatalog.ttypes.TComputeStatsParams()
                    self.compute_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.create_data_source_params = JniCatalog.ttypes.TCreateDataSourceParams()
                    self.create_data_source_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.drop_data_source_params = JniCatalog.ttypes.TDropDataSourceParams()
                    self.drop_data_source_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.drop_stats_params = JniCatalog.ttypes.TDropStatsParams()
                    self.drop_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.create_drop_role_params = JniCatalog.ttypes.TCreateDropRoleParams()
                    self.create_drop_role_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.grant_revoke_role_params = JniCatalog.ttypes.TGrantRevokeRoleParams()
                    self.grant_revoke_role_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.grant_revoke_priv_params = JniCatalog.ttypes.TGrantRevokePrivParams()
                    self.grant_revoke_priv_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRUCT:
                    self.comment_on_params = JniCatalog.ttypes.TCommentOnParams()
                    self.comment_on_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRUCT:
                    self.alter_db_params = JniCatalog.ttypes.TAlterDbParams()
                    self.alter_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRUCT:
                    self.copy_test_case_params = JniCatalog.ttypes.TCopyTestCaseReq()
                    self.copy_test_case_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDdlExecRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.ddl_type is not None:
            oprot.writeFieldBegin('ddl_type', TType.I32, 3)
            oprot.writeI32(self.ddl_type)
            oprot.writeFieldEnd()
        if self.alter_table_params is not None:
            oprot.writeFieldBegin('alter_table_params', TType.STRUCT, 4)
            self.alter_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_view_params is not None:
            oprot.writeFieldBegin('alter_view_params', TType.STRUCT, 5)
            self.alter_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_db_params is not None:
            oprot.writeFieldBegin('create_db_params', TType.STRUCT, 6)
            self.create_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_table_params is not None:
            oprot.writeFieldBegin('create_table_params', TType.STRUCT, 7)
            self.create_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_table_like_params is not None:
            oprot.writeFieldBegin('create_table_like_params', TType.STRUCT, 8)
            self.create_table_like_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_view_params is not None:
            oprot.writeFieldBegin('create_view_params', TType.STRUCT, 9)
            self.create_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_fn_params is not None:
            oprot.writeFieldBegin('create_fn_params', TType.STRUCT, 10)
            self.create_fn_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_db_params is not None:
            oprot.writeFieldBegin('drop_db_params', TType.STRUCT, 11)
            self.drop_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_table_or_view_params is not None:
            oprot.writeFieldBegin('drop_table_or_view_params', TType.STRUCT, 12)
            self.drop_table_or_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.truncate_params is not None:
            oprot.writeFieldBegin('truncate_params', TType.STRUCT, 13)
            self.truncate_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_fn_params is not None:
            oprot.writeFieldBegin('drop_fn_params', TType.STRUCT, 14)
            self.drop_fn_params.write(oprot)
            oprot.writeFieldEnd()
        if self.compute_stats_params is not None:
            oprot.writeFieldBegin('compute_stats_params', TType.STRUCT, 15)
            self.compute_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_data_source_params is not None:
            oprot.writeFieldBegin('create_data_source_params', TType.STRUCT, 16)
            self.create_data_source_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_data_source_params is not None:
            oprot.writeFieldBegin('drop_data_source_params', TType.STRUCT, 17)
            self.drop_data_source_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_stats_params is not None:
            oprot.writeFieldBegin('drop_stats_params', TType.STRUCT, 18)
            self.drop_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_drop_role_params is not None:
            oprot.writeFieldBegin('create_drop_role_params', TType.STRUCT, 19)
            self.create_drop_role_params.write(oprot)
            oprot.writeFieldEnd()
        if self.grant_revoke_role_params is not None:
            oprot.writeFieldBegin('grant_revoke_role_params', TType.STRUCT, 20)
            self.grant_revoke_role_params.write(oprot)
            oprot.writeFieldEnd()
        if self.grant_revoke_priv_params is not None:
            oprot.writeFieldBegin('grant_revoke_priv_params', TType.STRUCT, 21)
            self.grant_revoke_priv_params.write(oprot)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 22)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.comment_on_params is not None:
            oprot.writeFieldBegin('comment_on_params', TType.STRUCT, 23)
            self.comment_on_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_db_params is not None:
            oprot.writeFieldBegin('alter_db_params', TType.STRUCT, 24)
            self.alter_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.copy_test_case_params is not None:
            oprot.writeFieldBegin('copy_test_case_params', TType.STRUCT, 25)
            self.copy_test_case_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.ddl_type is None:
            raise TProtocolException(message='Required field ddl_type is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDdlExecResponse(object):
    """
    Attributes:
     - result
     - new_table_created
     - result_set
     - table_name
     - table_create_time
     - table_location
    """


    def __init__(self, result=None, new_table_created=None, result_set=None, table_name=None, table_create_time=None, table_location=None,):
        self.result = result
        self.new_table_created = new_table_created
        self.result_set = result_set
        self.table_name = table_name
        self.table_create_time = table_create_time
        self.table_location = table_location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.new_table_created = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.result_set = Results.ttypes.TResultSet()
                    self.result_set.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.table_create_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.table_location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDdlExecResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.new_table_created is not None:
            oprot.writeFieldBegin('new_table_created', TType.BOOL, 2)
            oprot.writeBool(self.new_table_created)
            oprot.writeFieldEnd()
        if self.result_set is not None:
            oprot.writeFieldBegin('result_set', TType.STRUCT, 3)
            self.result_set.write(oprot)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 4)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.table_create_time is not None:
            oprot.writeFieldBegin('table_create_time', TType.I64, 5)
            oprot.writeI64(self.table_create_time)
            oprot.writeFieldEnd()
        if self.table_location is not None:
            oprot.writeFieldBegin('table_location', TType.STRING, 6)
            oprot.writeString(self.table_location.encode('utf-8') if sys.version_info[0] == 2 else self.table_location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogRequest(object):
    """
    Attributes:
     - protocol_version
     - sync_ddl
     - header
     - target_table
     - db_name
     - created_partitions
     - is_overwrite
     - transaction_id
    """


    def __init__(self, protocol_version=0, sync_ddl=None, header=None, target_table=None, db_name=None, created_partitions=None, is_overwrite=None, transaction_id=None,):
        self.protocol_version = protocol_version
        self.sync_ddl = sync_ddl
        self.header = header
        self.target_table = target_table
        self.db_name = db_name
        self.created_partitions = created_partitions
        self.is_overwrite = is_overwrite
        self.transaction_id = transaction_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.target_table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.created_partitions = set()
                    (_etype17, _size14) = iprot.readSetBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.created_partitions.add(_elem19)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.transaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 2)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.target_table is not None:
            oprot.writeFieldBegin('target_table', TType.STRING, 4)
            oprot.writeString(self.target_table.encode('utf-8') if sys.version_info[0] == 2 else self.target_table)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 5)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.created_partitions is not None:
            oprot.writeFieldBegin('created_partitions', TType.SET, 6)
            oprot.writeSetBegin(TType.STRING, len(self.created_partitions))
            for iter20 in self.created_partitions:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.is_overwrite is not None:
            oprot.writeFieldBegin('is_overwrite', TType.BOOL, 7)
            oprot.writeBool(self.is_overwrite)
            oprot.writeFieldEnd()
        if self.transaction_id is not None:
            oprot.writeFieldBegin('transaction_id', TType.I64, 8)
            oprot.writeI64(self.transaction_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        if self.target_table is None:
            raise TProtocolException(message='Required field target_table is unset!')
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.created_partitions is None:
            raise TProtocolException(message='Required field created_partitions is unset!')
        if self.is_overwrite is None:
            raise TProtocolException(message='Required field is_overwrite is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogResponse(object):
    """
    Attributes:
     - result
    """


    def __init__(self, result=None,):
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResetMetadataRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - is_refresh
     - table_name
     - partition_spec
     - db_name
     - sync_ddl
     - authorization
    """


    def __init__(self, protocol_version=0, header=None, is_refresh=None, table_name=None, partition_spec=None, db_name=None, sync_ddl=None, authorization=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.is_refresh = is_refresh
        self.table_name = table_name
        self.partition_spec = partition_spec
        self.db_name = db_name
        self.sync_ddl = sync_ddl
        self.authorization = authorization

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_refresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem26.read(iprot)
                        self.partition_spec.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.authorization = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResetMetadataRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.is_refresh is not None:
            oprot.writeFieldBegin('is_refresh', TType.BOOL, 3)
            oprot.writeBool(self.is_refresh)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 4)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter27 in self.partition_spec:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 6)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 7)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.authorization is not None:
            oprot.writeFieldBegin('authorization', TType.BOOL, 8)
            oprot.writeBool(self.authorization)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.is_refresh is None:
            raise TProtocolException(message='Required field is_refresh is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResetMetadataResponse(object):
    """
    Attributes:
     - result
    """


    def __init__(self, result=None,):
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResetMetadataResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - db_name
    """


    def __init__(self, protocol_version=0, header=None, db_name=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 2)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsResponse(object):
    """
    Attributes:
     - status
     - functions
    """


    def __init__(self, status=None, functions=None,):
        self.status = status
        self.functions = functions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.functions = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = Types.ttypes.TFunction()
                        _elem33.read(iprot)
                        self.functions.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.functions))
            for iter34 in self.functions:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogInfoSelector(object):
    """
    Attributes:
     - want_db_names
    """


    def __init__(self, want_db_names=None,):
        self.want_db_names = want_db_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_db_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogInfoSelector')
        if self.want_db_names is not None:
            oprot.writeFieldBegin('want_db_names', TType.BOOL, 1)
            oprot.writeBool(self.want_db_names)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialCatalogInfo(object):
    """
    Attributes:
     - db_names
    """


    def __init__(self, db_names=None,):
        self.db_names = db_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.db_names = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.db_names.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialCatalogInfo')
        if self.db_names is not None:
            oprot.writeFieldBegin('db_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.db_names))
            for iter41 in self.db_names:
                oprot.writeString(iter41.encode('utf-8') if sys.version_info[0] == 2 else iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableInfoSelector(object):
    """
    Attributes:
     - want_hms_table
     - partition_ids
     - want_partition_names
     - want_partition_metadata
     - want_partition_files
     - want_stats_for_column_names
     - want_partition_stats
     - want_table_constraints
    """


    def __init__(self, want_hms_table=None, partition_ids=None, want_partition_names=None, want_partition_metadata=None, want_partition_files=None, want_stats_for_column_names=None, want_partition_stats=None, want_table_constraints=None,):
        self.want_hms_table = want_hms_table
        self.partition_ids = partition_ids
        self.want_partition_names = want_partition_names
        self.want_partition_metadata = want_partition_metadata
        self.want_partition_files = want_partition_files
        self.want_stats_for_column_names = want_stats_for_column_names
        self.want_partition_stats = want_partition_stats
        self.want_table_constraints = want_table_constraints

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_hms_table = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_ids = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI64()
                        self.partition_ids.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.want_partition_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.want_partition_metadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.want_partition_files = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.want_stats_for_column_names = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.want_stats_for_column_names.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.want_partition_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.want_table_constraints = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableInfoSelector')
        if self.want_hms_table is not None:
            oprot.writeFieldBegin('want_hms_table', TType.BOOL, 1)
            oprot.writeBool(self.want_hms_table)
            oprot.writeFieldEnd()
        if self.partition_ids is not None:
            oprot.writeFieldBegin('partition_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.partition_ids))
            for iter54 in self.partition_ids:
                oprot.writeI64(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.want_partition_names is not None:
            oprot.writeFieldBegin('want_partition_names', TType.BOOL, 3)
            oprot.writeBool(self.want_partition_names)
            oprot.writeFieldEnd()
        if self.want_partition_metadata is not None:
            oprot.writeFieldBegin('want_partition_metadata', TType.BOOL, 4)
            oprot.writeBool(self.want_partition_metadata)
            oprot.writeFieldEnd()
        if self.want_partition_files is not None:
            oprot.writeFieldBegin('want_partition_files', TType.BOOL, 5)
            oprot.writeBool(self.want_partition_files)
            oprot.writeFieldEnd()
        if self.want_stats_for_column_names is not None:
            oprot.writeFieldBegin('want_stats_for_column_names', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.want_stats_for_column_names))
            for iter55 in self.want_stats_for_column_names:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.want_partition_stats is not None:
            oprot.writeFieldBegin('want_partition_stats', TType.BOOL, 7)
            oprot.writeBool(self.want_partition_stats)
            oprot.writeFieldEnd()
        if self.want_table_constraints is not None:
            oprot.writeFieldBegin('want_table_constraints', TType.BOOL, 8)
            oprot.writeBool(self.want_table_constraints)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialPartitionInfo(object):
    """
    Attributes:
     - id
     - name
     - hms_partition
     - file_descriptors
     - partition_stats
     - has_incremental_stats
    """


    def __init__(self, id=None, name=None, hms_partition=None, file_descriptors=None, partition_stats=None, has_incremental_stats=None,):
        self.id = id
        self.name = name
        self.hms_partition = hms_partition
        self.file_descriptors = file_descriptors
        self.partition_stats = partition_stats
        self.has_incremental_stats = has_incremental_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hms_partition = hive_metastore.ttypes.Partition()
                    self.hms_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.file_descriptors = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = CatalogObjects.ttypes.THdfsFileDesc()
                        _elem61.read(iprot)
                        self.file_descriptors.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.partition_stats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_incremental_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialPartitionInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hms_partition is not None:
            oprot.writeFieldBegin('hms_partition', TType.STRUCT, 3)
            self.hms_partition.write(oprot)
            oprot.writeFieldEnd()
        if self.file_descriptors is not None:
            oprot.writeFieldBegin('file_descriptors', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.file_descriptors))
            for iter62 in self.file_descriptors:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.STRING, 5)
            oprot.writeBinary(self.partition_stats)
            oprot.writeFieldEnd()
        if self.has_incremental_stats is not None:
            oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 6)
            oprot.writeBool(self.has_incremental_stats)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialTableInfo(object):
    """
    Attributes:
     - hms_table
     - partitions
     - column_stats
     - storage_metadata_load_time_ns
     - network_addresses
     - sql_constraints
    """


    def __init__(self, hms_table=None, partitions=None, column_stats=None, storage_metadata_load_time_ns=None, network_addresses=None, sql_constraints=None,):
        self.hms_table = hms_table
        self.partitions = partitions
        self.column_stats = column_stats
        self.storage_metadata_load_time_ns = storage_metadata_load_time_ns
        self.network_addresses = network_addresses
        self.sql_constraints = sql_constraints

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hms_table = hive_metastore.ttypes.Table()
                    self.hms_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = TPartialPartitionInfo()
                        _elem68.read(iprot)
                        self.partitions.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.column_stats = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = hive_metastore.ttypes.ColumnStatisticsObj()
                        _elem74.read(iprot)
                        self.column_stats.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.storage_metadata_load_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.network_addresses = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = Types.ttypes.TNetworkAddress()
                        _elem80.read(iprot)
                        self.network_addresses.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
                    self.sql_constraints.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialTableInfo')
        if self.hms_table is not None:
            oprot.writeFieldBegin('hms_table', TType.STRUCT, 1)
            self.hms_table.write(oprot)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter81 in self.partitions:
                iter81.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_stats is not None:
            oprot.writeFieldBegin('column_stats', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.column_stats))
            for iter82 in self.column_stats:
                iter82.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storage_metadata_load_time_ns is not None:
            oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 4)
            oprot.writeI64(self.storage_metadata_load_time_ns)
            oprot.writeFieldEnd()
        if self.network_addresses is not None:
            oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
            for iter83 in self.network_addresses:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sql_constraints is not None:
            oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 8)
            self.sql_constraints.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDbInfoSelector(object):
    """
    Attributes:
     - want_hms_database
     - want_table_names
     - want_function_names
    """


    def __init__(self, want_hms_database=None, want_table_names=None, want_function_names=None,):
        self.want_hms_database = want_hms_database
        self.want_table_names = want_table_names
        self.want_function_names = want_function_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_hms_database = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.want_table_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.want_function_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDbInfoSelector')
        if self.want_hms_database is not None:
            oprot.writeFieldBegin('want_hms_database', TType.BOOL, 1)
            oprot.writeBool(self.want_hms_database)
            oprot.writeFieldEnd()
        if self.want_table_names is not None:
            oprot.writeFieldBegin('want_table_names', TType.BOOL, 2)
            oprot.writeBool(self.want_table_names)
            oprot.writeFieldEnd()
        if self.want_function_names is not None:
            oprot.writeFieldBegin('want_function_names', TType.BOOL, 3)
            oprot.writeBool(self.want_function_names)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialDbInfo(object):
    """
    Attributes:
     - hms_database
     - table_names
     - function_names
    """


    def __init__(self, hms_database=None, table_names=None, function_names=None,):
        self.hms_database = hms_database
        self.table_names = table_names
        self.function_names = function_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hms_database = hive_metastore.ttypes.Database()
                    self.hms_database.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.table_names = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.table_names.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.function_names = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.function_names.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialDbInfo')
        if self.hms_database is not None:
            oprot.writeFieldBegin('hms_database', TType.STRUCT, 1)
            self.hms_database.write(oprot)
            oprot.writeFieldEnd()
        if self.table_names is not None:
            oprot.writeFieldBegin('table_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.table_names))
            for iter96 in self.table_names:
                oprot.writeString(iter96.encode('utf-8') if sys.version_info[0] == 2 else iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.function_names is not None:
            oprot.writeFieldBegin('function_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.function_names))
            for iter97 in self.function_names:
                oprot.writeString(iter97.encode('utf-8') if sys.version_info[0] == 2 else iter97)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartialCatalogObjectRequest(object):
    """
    Attributes:
     - protocol_version
     - object_desc
     - table_info_selector
     - db_info_selector
     - catalog_info_selector
    """


    def __init__(self, protocol_version=0, object_desc=None, table_info_selector=None, db_info_selector=None, catalog_info_selector=None,):
        self.protocol_version = protocol_version
        self.object_desc = object_desc
        self.table_info_selector = table_info_selector
        self.db_info_selector = db_info_selector
        self.catalog_info_selector = catalog_info_selector

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.object_desc = CatalogObjects.ttypes.TCatalogObject()
                    self.object_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table_info_selector = TTableInfoSelector()
                    self.table_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.db_info_selector = TDbInfoSelector()
                    self.db_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.catalog_info_selector = TCatalogInfoSelector()
                    self.catalog_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartialCatalogObjectRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.object_desc is not None:
            oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
            self.object_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.table_info_selector is not None:
            oprot.writeFieldBegin('table_info_selector', TType.STRUCT, 3)
            self.table_info_selector.write(oprot)
            oprot.writeFieldEnd()
        if self.db_info_selector is not None:
            oprot.writeFieldBegin('db_info_selector', TType.STRUCT, 4)
            self.db_info_selector.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_info_selector is not None:
            oprot.writeFieldBegin('catalog_info_selector', TType.STRUCT, 5)
            self.catalog_info_selector.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_desc is None:
            raise TProtocolException(message='Required field object_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartialCatalogObjectResponse(object):
    """
    Attributes:
     - status
     - lookup_status
     - object_version_number
     - table_info
     - db_info
     - catalog_info
     - functions
    """


    def __init__(self, status=None, lookup_status=0, object_version_number=None, table_info=None, db_info=None, catalog_info=None, functions=None,):
        self.status = status
        self.lookup_status = lookup_status
        self.object_version_number = object_version_number
        self.table_info = table_info
        self.db_info = db_info
        self.catalog_info = catalog_info
        self.functions = functions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.lookup_status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.object_version_number = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.table_info = TPartialTableInfo()
                    self.table_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.db_info = TPartialDbInfo()
                    self.db_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.catalog_info = TPartialCatalogInfo()
                    self.catalog_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.functions = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = Types.ttypes.TFunction()
                        _elem103.read(iprot)
                        self.functions.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartialCatalogObjectResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.lookup_status is not None:
            oprot.writeFieldBegin('lookup_status', TType.I32, 2)
            oprot.writeI32(self.lookup_status)
            oprot.writeFieldEnd()
        if self.object_version_number is not None:
            oprot.writeFieldBegin('object_version_number', TType.I64, 3)
            oprot.writeI64(self.object_version_number)
            oprot.writeFieldEnd()
        if self.table_info is not None:
            oprot.writeFieldBegin('table_info', TType.STRUCT, 4)
            self.table_info.write(oprot)
            oprot.writeFieldEnd()
        if self.db_info is not None:
            oprot.writeFieldBegin('db_info', TType.STRUCT, 5)
            self.db_info.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_info is not None:
            oprot.writeFieldBegin('catalog_info', TType.STRUCT, 6)
            self.catalog_info.write(oprot)
            oprot.writeFieldEnd()
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.functions))
            for iter104 in self.functions:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogObjectRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - object_desc
    """


    def __init__(self, protocol_version=0, header=None, object_desc=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.object_desc = object_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.object_desc = CatalogObjects.ttypes.TCatalogObject()
                    self.object_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogObjectRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.object_desc is not None:
            oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
            self.object_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_desc is None:
            raise TProtocolException(message='Required field object_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogObjectResponse(object):
    """
    Attributes:
     - catalog_object
    """


    def __init__(self, catalog_object=None,):
        self.catalog_object = catalog_object

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_object = CatalogObjects.ttypes.TCatalogObject()
                    self.catalog_object.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogObjectResponse')
        if self.catalog_object is not None:
            oprot.writeFieldBegin('catalog_object', TType.STRUCT, 1)
            self.catalog_object.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_object is None:
            raise TProtocolException(message='Required field catalog_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartitionStatsRequest(object):
    """
    Attributes:
     - protocol_version
     - table_name
    """


    def __init__(self, protocol_version=0, table_name=None,):
        self.protocol_version = protocol_version
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartitionStatsRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartitionStatsResponse(object):
    """
    Attributes:
     - status
     - partition_stats
    """


    def __init__(self, status=None, partition_stats=None,):
        self.status = status
        self.partition_stats = partition_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.partition_stats = {}
                    (_ktype106, _vtype107, _size105) = iprot.readMapBegin()
                    for _i109 in range(_size105):
                        _key110 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val111 = iprot.readBinary()
                        self.partition_stats[_key110] = _val111
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartitionStatsResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partition_stats))
            for kiter112, viter113 in self.partition_stats.items():
                oprot.writeString(kiter112.encode('utf-8') if sys.version_info[0] == 2 else kiter112)
                oprot.writeBinary(viter113)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrioritizeLoadRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - object_descs
    """


    def __init__(self, protocol_version=0, header=None, object_descs=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.object_descs = object_descs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.object_descs = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = CatalogObjects.ttypes.TCatalogObject()
                        _elem119.read(iprot)
                        self.object_descs.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrioritizeLoadRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.object_descs is not None:
            oprot.writeFieldBegin('object_descs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.object_descs))
            for iter120 in self.object_descs:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_descs is None:
            raise TProtocolException(message='Required field object_descs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrioritizeLoadResponse(object):
    """
    Attributes:
     - status
    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrioritizeLoadResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSentryAdminCheckRequest(object):
    """
    Attributes:
     - protocol_version
     - header
    """


    def __init__(self, protocol_version=0, header=None,):
        self.protocol_version = protocol_version
        self.header = header

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSentryAdminCheckRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSentryAdminCheckResponse(object):
    """
    Attributes:
     - status
     - is_admin
    """


    def __init__(self, status=None, is_admin=None,):
        self.status = status
        self.is_admin = is_admin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_admin = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSentryAdminCheckResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.is_admin is not None:
            oprot.writeFieldBegin('is_admin', TType.BOOL, 2)
            oprot.writeBool(self.is_admin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_admin is None:
            raise TProtocolException(message='Required field is_admin is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableUsage(object):
    """
    Attributes:
     - table_name
     - num_usages
    """


    def __init__(self, table_name=None, num_usages=None,):
        self.table_name = table_name
        self.num_usages = num_usages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_usages = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableUsage')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.num_usages is not None:
            oprot.writeFieldBegin('num_usages', TType.I32, 2)
            oprot.writeI32(self.num_usages)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.num_usages is None:
            raise TProtocolException(message='Required field num_usages is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTableUsageRequest(object):
    """
    Attributes:
     - usages
    """


    def __init__(self, usages=None,):
        self.usages = usages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.usages = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = TTableUsage()
                        _elem126.read(iprot)
                        self.usages.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTableUsageRequest')
        if self.usages is not None:
            oprot.writeFieldBegin('usages', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.usages))
            for iter127 in self.usages:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.usages is None:
            raise TProtocolException(message='Required field usages is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTableUsageResponse(object):
    """
    Attributes:
     - status
    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTableUsageResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCatalogServiceRequestHeader)
TCatalogServiceRequestHeader.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'redacted_sql_stmt', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'client_ip', 'UTF8', None, ),  # 3
)
all_structs.append(TCatalogUpdateResult)
TCatalogUpdateResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'version', None, None, ),  # 2
    (3, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 3
    (4, TType.BOOL, 'is_invalidate', None, None, ),  # 4
    (5, TType.LIST, 'updated_catalog_objects', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 5
    (6, TType.LIST, 'removed_catalog_objects', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 6
)
all_structs.append(TDdlExecRequest)
TDdlExecRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.I32, 'ddl_type', None, None, ),  # 3
    (4, TType.STRUCT, 'alter_table_params', [JniCatalog.ttypes.TAlterTableParams, None], None, ),  # 4
    (5, TType.STRUCT, 'alter_view_params', [JniCatalog.ttypes.TCreateOrAlterViewParams, None], None, ),  # 5
    (6, TType.STRUCT, 'create_db_params', [JniCatalog.ttypes.TCreateDbParams, None], None, ),  # 6
    (7, TType.STRUCT, 'create_table_params', [JniCatalog.ttypes.TCreateTableParams, None], None, ),  # 7
    (8, TType.STRUCT, 'create_table_like_params', [JniCatalog.ttypes.TCreateTableLikeParams, None], None, ),  # 8
    (9, TType.STRUCT, 'create_view_params', [JniCatalog.ttypes.TCreateOrAlterViewParams, None], None, ),  # 9
    (10, TType.STRUCT, 'create_fn_params', [JniCatalog.ttypes.TCreateFunctionParams, None], None, ),  # 10
    (11, TType.STRUCT, 'drop_db_params', [JniCatalog.ttypes.TDropDbParams, None], None, ),  # 11
    (12, TType.STRUCT, 'drop_table_or_view_params', [JniCatalog.ttypes.TDropTableOrViewParams, None], None, ),  # 12
    (13, TType.STRUCT, 'truncate_params', [JniCatalog.ttypes.TTruncateParams, None], None, ),  # 13
    (14, TType.STRUCT, 'drop_fn_params', [JniCatalog.ttypes.TDropFunctionParams, None], None, ),  # 14
    (15, TType.STRUCT, 'compute_stats_params', [JniCatalog.ttypes.TComputeStatsParams, None], None, ),  # 15
    (16, TType.STRUCT, 'create_data_source_params', [JniCatalog.ttypes.TCreateDataSourceParams, None], None, ),  # 16
    (17, TType.STRUCT, 'drop_data_source_params', [JniCatalog.ttypes.TDropDataSourceParams, None], None, ),  # 17
    (18, TType.STRUCT, 'drop_stats_params', [JniCatalog.ttypes.TDropStatsParams, None], None, ),  # 18
    (19, TType.STRUCT, 'create_drop_role_params', [JniCatalog.ttypes.TCreateDropRoleParams, None], None, ),  # 19
    (20, TType.STRUCT, 'grant_revoke_role_params', [JniCatalog.ttypes.TGrantRevokeRoleParams, None], None, ),  # 20
    (21, TType.STRUCT, 'grant_revoke_priv_params', [JniCatalog.ttypes.TGrantRevokePrivParams, None], None, ),  # 21
    (22, TType.BOOL, 'sync_ddl', None, None, ),  # 22
    (23, TType.STRUCT, 'comment_on_params', [JniCatalog.ttypes.TCommentOnParams, None], None, ),  # 23
    (24, TType.STRUCT, 'alter_db_params', [JniCatalog.ttypes.TAlterDbParams, None], None, ),  # 24
    (25, TType.STRUCT, 'copy_test_case_params', [JniCatalog.ttypes.TCopyTestCaseReq, None], None, ),  # 25
)
all_structs.append(TDdlExecResponse)
TDdlExecResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
    (2, TType.BOOL, 'new_table_created', None, None, ),  # 2
    (3, TType.STRUCT, 'result_set', [Results.ttypes.TResultSet, None], None, ),  # 3
    (4, TType.STRING, 'table_name', 'UTF8', None, ),  # 4
    (5, TType.I64, 'table_create_time', None, None, ),  # 5
    (6, TType.STRING, 'table_location', 'UTF8', None, ),  # 6
)
all_structs.append(TUpdateCatalogRequest)
TUpdateCatalogRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.BOOL, 'sync_ddl', None, None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
    (4, TType.STRING, 'target_table', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'db_name', 'UTF8', None, ),  # 5
    (6, TType.SET, 'created_partitions', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.BOOL, 'is_overwrite', None, None, ),  # 7
    (8, TType.I64, 'transaction_id', None, None, ),  # 8
)
all_structs.append(TUpdateCatalogResponse)
TUpdateCatalogResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
)
all_structs.append(TResetMetadataRequest)
TResetMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.BOOL, 'is_refresh', None, None, ),  # 3
    (4, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 4
    (5, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 5
    (6, TType.STRING, 'db_name', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'sync_ddl', None, None, ),  # 7
    (8, TType.BOOL, 'authorization', None, None, ),  # 8
)
all_structs.append(TResetMetadataResponse)
TResetMetadataResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
)
all_structs.append(TGetFunctionsRequest)
TGetFunctionsRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRING, 'db_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
)
all_structs.append(TGetFunctionsResponse)
TGetFunctionsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.LIST, 'functions', (TType.STRUCT, [Types.ttypes.TFunction, None], False), None, ),  # 2
)
all_structs.append(TCatalogInfoSelector)
TCatalogInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_db_names', None, None, ),  # 1
)
all_structs.append(TPartialCatalogInfo)
TPartialCatalogInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'db_names', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TTableInfoSelector)
TTableInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_hms_table', None, None, ),  # 1
    (2, TType.LIST, 'partition_ids', (TType.I64, None, False), None, ),  # 2
    (3, TType.BOOL, 'want_partition_names', None, None, ),  # 3
    (4, TType.BOOL, 'want_partition_metadata', None, None, ),  # 4
    (5, TType.BOOL, 'want_partition_files', None, None, ),  # 5
    (6, TType.LIST, 'want_stats_for_column_names', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.BOOL, 'want_partition_stats', None, None, ),  # 7
    (8, TType.BOOL, 'want_table_constraints', None, None, ),  # 8
)
all_structs.append(TPartialPartitionInfo)
TPartialPartitionInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'hms_partition', [hive_metastore.ttypes.Partition, None], None, ),  # 3
    (4, TType.LIST, 'file_descriptors', (TType.STRUCT, [CatalogObjects.ttypes.THdfsFileDesc, None], False), None, ),  # 4
    (5, TType.STRING, 'partition_stats', 'BINARY', None, ),  # 5
    (6, TType.BOOL, 'has_incremental_stats', None, None, ),  # 6
)
all_structs.append(TPartialTableInfo)
TPartialTableInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hms_table', [hive_metastore.ttypes.Table, None], None, ),  # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT, [TPartialPartitionInfo, None], False), None, ),  # 2
    (3, TType.LIST, 'column_stats', (TType.STRUCT, [hive_metastore.ttypes.ColumnStatisticsObj, None], False), None, ),  # 3
    (4, TType.I64, 'storage_metadata_load_time_ns', None, None, ),  # 4
    None,  # 5
    None,  # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT, [Types.ttypes.TNetworkAddress, None], False), None, ),  # 7
    (8, TType.STRUCT, 'sql_constraints', [SqlConstraints.ttypes.TSqlConstraints, None], None, ),  # 8
)
all_structs.append(TDbInfoSelector)
TDbInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_hms_database', None, None, ),  # 1
    (2, TType.BOOL, 'want_table_names', None, None, ),  # 2
    (3, TType.BOOL, 'want_function_names', None, None, ),  # 3
)
all_structs.append(TPartialDbInfo)
TPartialDbInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hms_database', [hive_metastore.ttypes.Database, None], None, ),  # 1
    (2, TType.LIST, 'table_names', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'function_names', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TGetPartialCatalogObjectRequest)
TGetPartialCatalogObjectRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'object_desc', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 2
    (3, TType.STRUCT, 'table_info_selector', [TTableInfoSelector, None], None, ),  # 3
    (4, TType.STRUCT, 'db_info_selector', [TDbInfoSelector, None], None, ),  # 4
    (5, TType.STRUCT, 'catalog_info_selector', [TCatalogInfoSelector, None], None, ),  # 5
)
all_structs.append(TGetPartialCatalogObjectResponse)
TGetPartialCatalogObjectResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.I32, 'lookup_status', None, 0, ),  # 2
    (3, TType.I64, 'object_version_number', None, None, ),  # 3
    (4, TType.STRUCT, 'table_info', [TPartialTableInfo, None], None, ),  # 4
    (5, TType.STRUCT, 'db_info', [TPartialDbInfo, None], None, ),  # 5
    (6, TType.STRUCT, 'catalog_info', [TPartialCatalogInfo, None], None, ),  # 6
    (7, TType.LIST, 'functions', (TType.STRUCT, [Types.ttypes.TFunction, None], False), None, ),  # 7
)
all_structs.append(TGetCatalogObjectRequest)
TGetCatalogObjectRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'object_desc', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
)
all_structs.append(TGetCatalogObjectResponse)
TGetCatalogObjectResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_object', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 1
)
all_structs.append(TGetPartitionStatsRequest)
TGetPartitionStatsRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
)
all_structs.append(TGetPartitionStatsResponse)
TGetPartitionStatsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.MAP, 'partition_stats', (TType.STRING, 'UTF8', TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TPrioritizeLoadRequest)
TPrioritizeLoadRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.LIST, 'object_descs', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 3
)
all_structs.append(TPrioritizeLoadResponse)
TPrioritizeLoadResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
all_structs.append(TSentryAdminCheckRequest)
TSentryAdminCheckRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
)
all_structs.append(TSentryAdminCheckResponse)
TSentryAdminCheckResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.BOOL, 'is_admin', None, None, ),  # 2
)
all_structs.append(TTableUsage)
TTableUsage.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.I32, 'num_usages', None, None, ),  # 2
)
all_structs.append(TUpdateTableUsageRequest)
TUpdateTableUsageRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'usages', (TType.STRUCT, [TTableUsage, None], False), None, ),  # 1
)
all_structs.append(TUpdateTableUsageResponse)
TUpdateTableUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
