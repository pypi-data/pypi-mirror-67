#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import CatalogObjects.ttypes
import Types.ttypes
import Status.ttypes
import TCLIService.ttypes
import hive_metastore.ttypes

from thrift.transport import TTransport
all_structs = []


class TDdlType(object):
    ALTER_TABLE = 0
    ALTER_VIEW = 1
    CREATE_DATABASE = 2
    CREATE_TABLE = 3
    CREATE_TABLE_AS_SELECT = 4
    CREATE_TABLE_LIKE = 5
    CREATE_VIEW = 6
    CREATE_FUNCTION = 7
    COMPUTE_STATS = 8
    DROP_DATABASE = 9
    DROP_TABLE = 10
    DROP_VIEW = 11
    DROP_FUNCTION = 12
    CREATE_DATA_SOURCE = 13
    DROP_DATA_SOURCE = 14
    DROP_STATS = 15
    CREATE_ROLE = 16
    DROP_ROLE = 17
    GRANT_ROLE = 18
    REVOKE_ROLE = 19
    GRANT_PRIVILEGE = 20
    REVOKE_PRIVILEGE = 21
    TRUNCATE_TABLE = 22
    COMMENT_ON = 23
    ALTER_DATABASE = 24
    COPY_TESTCASE = 25

    _VALUES_TO_NAMES = {
        0: "ALTER_TABLE",
        1: "ALTER_VIEW",
        2: "CREATE_DATABASE",
        3: "CREATE_TABLE",
        4: "CREATE_TABLE_AS_SELECT",
        5: "CREATE_TABLE_LIKE",
        6: "CREATE_VIEW",
        7: "CREATE_FUNCTION",
        8: "COMPUTE_STATS",
        9: "DROP_DATABASE",
        10: "DROP_TABLE",
        11: "DROP_VIEW",
        12: "DROP_FUNCTION",
        13: "CREATE_DATA_SOURCE",
        14: "DROP_DATA_SOURCE",
        15: "DROP_STATS",
        16: "CREATE_ROLE",
        17: "DROP_ROLE",
        18: "GRANT_ROLE",
        19: "REVOKE_ROLE",
        20: "GRANT_PRIVILEGE",
        21: "REVOKE_PRIVILEGE",
        22: "TRUNCATE_TABLE",
        23: "COMMENT_ON",
        24: "ALTER_DATABASE",
        25: "COPY_TESTCASE",
    }

    _NAMES_TO_VALUES = {
        "ALTER_TABLE": 0,
        "ALTER_VIEW": 1,
        "CREATE_DATABASE": 2,
        "CREATE_TABLE": 3,
        "CREATE_TABLE_AS_SELECT": 4,
        "CREATE_TABLE_LIKE": 5,
        "CREATE_VIEW": 6,
        "CREATE_FUNCTION": 7,
        "COMPUTE_STATS": 8,
        "DROP_DATABASE": 9,
        "DROP_TABLE": 10,
        "DROP_VIEW": 11,
        "DROP_FUNCTION": 12,
        "CREATE_DATA_SOURCE": 13,
        "DROP_DATA_SOURCE": 14,
        "DROP_STATS": 15,
        "CREATE_ROLE": 16,
        "DROP_ROLE": 17,
        "GRANT_ROLE": 18,
        "REVOKE_ROLE": 19,
        "GRANT_PRIVILEGE": 20,
        "REVOKE_PRIVILEGE": 21,
        "TRUNCATE_TABLE": 22,
        "COMMENT_ON": 23,
        "ALTER_DATABASE": 24,
        "COPY_TESTCASE": 25,
    }


class TOwnerType(object):
    USER = 0
    ROLE = 1

    _VALUES_TO_NAMES = {
        0: "USER",
        1: "ROLE",
    }

    _NAMES_TO_VALUES = {
        "USER": 0,
        "ROLE": 1,
    }


class TAlterDbType(object):
    SET_OWNER = 0

    _VALUES_TO_NAMES = {
        0: "SET_OWNER",
    }

    _NAMES_TO_VALUES = {
        "SET_OWNER": 0,
    }


class TAlterTableType(object):
    ADD_COLUMNS = 0
    REPLACE_COLUMNS = 1
    ADD_PARTITION = 2
    ADD_DROP_RANGE_PARTITION = 3
    ALTER_COLUMN = 4
    DROP_COLUMN = 5
    DROP_PARTITION = 6
    RENAME_TABLE = 7
    RENAME_VIEW = 8
    SET_FILE_FORMAT = 9
    SET_LOCATION = 10
    SET_TBL_PROPERTIES = 11
    UPDATE_STATS = 12
    SET_CACHED = 13
    RECOVER_PARTITIONS = 14
    SET_ROW_FORMAT = 15
    SET_OWNER = 16

    _VALUES_TO_NAMES = {
        0: "ADD_COLUMNS",
        1: "REPLACE_COLUMNS",
        2: "ADD_PARTITION",
        3: "ADD_DROP_RANGE_PARTITION",
        4: "ALTER_COLUMN",
        5: "DROP_COLUMN",
        6: "DROP_PARTITION",
        7: "RENAME_TABLE",
        8: "RENAME_VIEW",
        9: "SET_FILE_FORMAT",
        10: "SET_LOCATION",
        11: "SET_TBL_PROPERTIES",
        12: "UPDATE_STATS",
        13: "SET_CACHED",
        14: "RECOVER_PARTITIONS",
        15: "SET_ROW_FORMAT",
        16: "SET_OWNER",
    }

    _NAMES_TO_VALUES = {
        "ADD_COLUMNS": 0,
        "REPLACE_COLUMNS": 1,
        "ADD_PARTITION": 2,
        "ADD_DROP_RANGE_PARTITION": 3,
        "ALTER_COLUMN": 4,
        "DROP_COLUMN": 5,
        "DROP_PARTITION": 6,
        "RENAME_TABLE": 7,
        "RENAME_VIEW": 8,
        "SET_FILE_FORMAT": 9,
        "SET_LOCATION": 10,
        "SET_TBL_PROPERTIES": 11,
        "UPDATE_STATS": 12,
        "SET_CACHED": 13,
        "RECOVER_PARTITIONS": 14,
        "SET_ROW_FORMAT": 15,
        "SET_OWNER": 16,
    }


class TRangePartitionOperationType(object):
    ADD = 0
    DROP = 1

    _VALUES_TO_NAMES = {
        0: "ADD",
        1: "DROP",
    }

    _NAMES_TO_VALUES = {
        "ADD": 0,
        "DROP": 1,
    }


class TAlterDbSetOwnerParams(object):
    """
    Attributes:
     - owner_type
     - owner_name
     - server_name
    """


    def __init__(self, owner_type=None, owner_name=None, server_name=None,):
        self.owner_type = owner_type
        self.owner_name = owner_name
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.owner_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterDbSetOwnerParams')
        if self.owner_type is not None:
            oprot.writeFieldBegin('owner_type', TType.I32, 1)
            oprot.writeI32(self.owner_type)
            oprot.writeFieldEnd()
        if self.owner_name is not None:
            oprot.writeFieldBegin('owner_name', TType.STRING, 2)
            oprot.writeString(self.owner_name.encode('utf-8') if sys.version_info[0] == 2 else self.owner_name)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 3)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.owner_type is None:
            raise TProtocolException(message='Required field owner_type is unset!')
        if self.owner_name is None:
            raise TProtocolException(message='Required field owner_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterDbParams(object):
    """
    Attributes:
     - alter_type
     - db
     - set_owner_params
    """


    def __init__(self, alter_type=None, db=None, set_owner_params=None,):
        self.alter_type = alter_type
        self.db = db
        self.set_owner_params = set_owner_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.alter_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.set_owner_params = TAlterDbSetOwnerParams()
                    self.set_owner_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterDbParams')
        if self.alter_type is not None:
            oprot.writeFieldBegin('alter_type', TType.I32, 1)
            oprot.writeI32(self.alter_type)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.set_owner_params is not None:
            oprot.writeFieldBegin('set_owner_params', TType.STRUCT, 3)
            self.set_owner_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.alter_type is None:
            raise TProtocolException(message='Required field alter_type is unset!')
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDbParams(object):
    """
    Attributes:
     - db
     - comment
     - location
     - if_not_exists
     - owner
     - server_name
    """


    def __init__(self, db=None, comment=None, location=None, if_not_exists=None, owner=None, server_name=None,):
        self.db = db
        self.comment = comment
        self.location = location
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.owner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 2)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 3)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 5)
            oprot.writeString(self.owner.encode('utf-8') if sys.version_info[0] == 2 else self.owner)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 6)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDataSourceParams(object):
    """
    Attributes:
     - data_source
     - if_not_exists
    """


    def __init__(self, data_source=None, if_not_exists=None,):
        self.data_source = data_source
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data_source = CatalogObjects.ttypes.TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDataSourceParams')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropDataSourceParams(object):
    """
    Attributes:
     - data_source
     - if_exists
    """


    def __init__(self, data_source=None, if_exists=None,):
        self.data_source = data_source
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data_source = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropDataSourceParams')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRING, 1)
            oprot.writeString(self.data_source.encode('utf-8') if sys.version_info[0] == 2 else self.data_source)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropStatsParams(object):
    """
    Attributes:
     - table_name
     - partition_set
    """


    def __init__(self, table_name=None, partition_set=None,):
        self.table_name = table_name
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = []
                        (_etype9, _size6) = iprot.readListBegin()
                        for _i10 in range(_size6):
                            _elem11 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem11.read(iprot)
                            _elem5.append(_elem11)
                        iprot.readListEnd()
                        self.partition_set.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter12 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter12))
                for iter13 in iter12:
                    iter13.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionParams(object):
    """
    Attributes:
     - fn
     - if_not_exists
    """


    def __init__(self, fn=None, if_not_exists=None,):
        self.fn = fn
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionParams')
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 1)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn is None:
            raise TProtocolException(message='Required field fn is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableRowFormat(object):
    """
    Attributes:
     - field_terminator
     - line_terminator
     - escaped_by
    """


    def __init__(self, field_terminator=None, line_terminator=None, escaped_by=None,):
        self.field_terminator = field_terminator
        self.line_terminator = line_terminator
        self.escaped_by = escaped_by

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.field_terminator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.line_terminator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.escaped_by = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableRowFormat')
        if self.field_terminator is not None:
            oprot.writeFieldBegin('field_terminator', TType.STRING, 1)
            oprot.writeString(self.field_terminator.encode('utf-8') if sys.version_info[0] == 2 else self.field_terminator)
            oprot.writeFieldEnd()
        if self.line_terminator is not None:
            oprot.writeFieldBegin('line_terminator', TType.STRING, 2)
            oprot.writeString(self.line_terminator.encode('utf-8') if sys.version_info[0] == 2 else self.line_terminator)
            oprot.writeFieldEnd()
        if self.escaped_by is not None:
            oprot.writeFieldBegin('escaped_by', TType.STRING, 3)
            oprot.writeString(self.escaped_by.encode('utf-8') if sys.version_info[0] == 2 else self.escaped_by)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsCachingOp(object):
    """
    Attributes:
     - set_cached
     - cache_pool_name
     - replication
    """


    def __init__(self, set_cached=None, cache_pool_name=None, replication=None,):
        self.set_cached = set_cached
        self.cache_pool_name = cache_pool_name
        self.replication = replication

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.set_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cache_pool_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.replication = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsCachingOp')
        if self.set_cached is not None:
            oprot.writeFieldBegin('set_cached', TType.BOOL, 1)
            oprot.writeBool(self.set_cached)
            oprot.writeFieldEnd()
        if self.cache_pool_name is not None:
            oprot.writeFieldBegin('cache_pool_name', TType.STRING, 2)
            oprot.writeString(self.cache_pool_name.encode('utf-8') if sys.version_info[0] == 2 else self.cache_pool_name)
            oprot.writeFieldEnd()
        if self.replication is not None:
            oprot.writeFieldBegin('replication', TType.I16, 3)
            oprot.writeI16(self.replication)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.set_cached is None:
            raise TProtocolException(message='Required field set_cached is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableOrViewRenameParams(object):
    """
    Attributes:
     - new_table_name
    """


    def __init__(self, new_table_name=None,):
        self.new_table_name = new_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_table_name = CatalogObjects.ttypes.TTableName()
                    self.new_table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableOrViewRenameParams')
        if self.new_table_name is not None:
            oprot.writeFieldBegin('new_table_name', TType.STRUCT, 1)
            self.new_table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.new_table_name is None:
            raise TProtocolException(message='Required field new_table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddColsParams(object):
    """
    Attributes:
     - columns
     - if_not_exists
    """


    def __init__(self, columns=None, if_not_exists=None,):
        self.columns = columns
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = CatalogObjects.ttypes.TColumn()
                        _elem19.read(iprot)
                        self.columns.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddColsParams')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter20 in self.columns:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableReplaceColsParams(object):
    """
    Attributes:
     - columns
    """


    def __init__(self, columns=None,):
        self.columns = columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = CatalogObjects.ttypes.TColumn()
                        _elem26.read(iprot)
                        self.columns.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableReplaceColsParams')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter27 in self.columns:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionDef(object):
    """
    Attributes:
     - partition_spec
     - location
     - cache_op
    """


    def __init__(self, partition_spec=None, location=None, cache_op=None,):
        self.partition_spec = partition_spec
        self.location = location
        self.cache_op = cache_op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem33.read(iprot)
                        self.partition_spec.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionDef')
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter34 in self.partition_spec:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 2)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 3)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_spec is None:
            raise TProtocolException(message='Required field partition_spec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddPartitionParams(object):
    """
    Attributes:
     - if_not_exists
     - partitions
    """


    def __init__(self, if_not_exists=None, partitions=None,):
        self.if_not_exists = if_not_exists
        self.partitions = partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = TPartitionDef()
                        _elem40.read(iprot)
                        self.partitions.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddPartitionParams')
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 1)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter41 in self.partitions:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddDropRangePartitionParams(object):
    """
    Attributes:
     - range_partition_spec
     - ignore_errors
     - type
    """


    def __init__(self, range_partition_spec=None, ignore_errors=None, type=None,):
        self.range_partition_spec = range_partition_spec
        self.ignore_errors = ignore_errors
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.range_partition_spec = CatalogObjects.ttypes.TRangePartition()
                    self.range_partition_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ignore_errors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddDropRangePartitionParams')
        if self.range_partition_spec is not None:
            oprot.writeFieldBegin('range_partition_spec', TType.STRUCT, 1)
            self.range_partition_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.ignore_errors is not None:
            oprot.writeFieldBegin('ignore_errors', TType.BOOL, 2)
            oprot.writeBool(self.ignore_errors)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.range_partition_spec is None:
            raise TProtocolException(message='Required field range_partition_spec is unset!')
        if self.ignore_errors is None:
            raise TProtocolException(message='Required field ignore_errors is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableDropColParams(object):
    """
    Attributes:
     - col_name
    """


    def __init__(self, col_name=None,):
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableDropColParams')
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 1)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.col_name is None:
            raise TProtocolException(message='Required field col_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableDropPartitionParams(object):
    """
    Attributes:
     - partition_set
     - if_exists
     - purge
    """


    def __init__(self, partition_set=None, if_exists=None, purge=None,):
        self.partition_set = partition_set
        self.if_exists = if_exists
        self.purge = purge

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = []
                        (_etype51, _size48) = iprot.readListBegin()
                        for _i52 in range(_size48):
                            _elem53 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem53.read(iprot)
                            _elem47.append(_elem53)
                        iprot.readListEnd()
                        self.partition_set.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.purge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableDropPartitionParams')
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter54 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter54))
                for iter55 in iter54:
                    iter55.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.purge is not None:
            oprot.writeFieldBegin('purge', TType.BOOL, 3)
            oprot.writeBool(self.purge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_set is None:
            raise TProtocolException(message='Required field partition_set is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.purge is None:
            raise TProtocolException(message='Required field purge is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAlterColParams(object):
    """
    Attributes:
     - col_name
     - new_col_def
    """


    def __init__(self, col_name=None, new_col_def=None,):
        self.col_name = col_name
        self.new_col_def = new_col_def

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.new_col_def = CatalogObjects.ttypes.TColumn()
                    self.new_col_def.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAlterColParams')
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 1)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        if self.new_col_def is not None:
            oprot.writeFieldBegin('new_col_def', TType.STRUCT, 2)
            self.new_col_def.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.col_name is None:
            raise TProtocolException(message='Required field col_name is unset!')
        if self.new_col_def is None:
            raise TProtocolException(message='Required field new_col_def is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetTblPropertiesParams(object):
    """
    Attributes:
     - target
     - properties
     - partition_set
    """


    def __init__(self, target=None, properties=None, partition_set=None,):
        self.target = target
        self.properties = properties
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.target = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype57, _vtype58, _size56) = iprot.readMapBegin()
                    for _i60 in range(_size56):
                        _key61 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val62 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key61] = _val62
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = []
                        (_etype72, _size69) = iprot.readListBegin()
                        for _i73 in range(_size69):
                            _elem74 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem74.read(iprot)
                            _elem68.append(_elem74)
                        iprot.readListEnd()
                        self.partition_set.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetTblPropertiesParams')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.I32, 1)
            oprot.writeI32(self.target)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter75, viter76 in self.properties.items():
                oprot.writeString(kiter75.encode('utf-8') if sys.version_info[0] == 2 else kiter75)
                oprot.writeString(viter76.encode('utf-8') if sys.version_info[0] == 2 else viter76)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter77 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter77))
                for iter78 in iter77:
                    iter78.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target is None:
            raise TProtocolException(message='Required field target is unset!')
        if self.properties is None:
            raise TProtocolException(message='Required field properties is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetFileFormatParams(object):
    """
    Attributes:
     - file_format
     - partition_set
    """


    def __init__(self, file_format=None, partition_set=None,):
        self.file_format = file_format
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = []
                        (_etype88, _size85) = iprot.readListBegin()
                        for _i89 in range(_size85):
                            _elem90 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem90.read(iprot)
                            _elem84.append(_elem90)
                        iprot.readListEnd()
                        self.partition_set.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetFileFormatParams')
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 1)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter91 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter91))
                for iter92 in iter91:
                    iter92.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_format is None:
            raise TProtocolException(message='Required field file_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetRowFormatParams(object):
    """
    Attributes:
     - row_format
     - partition_set
    """


    def __init__(self, row_format=None, partition_set=None,):
        self.row_format = row_format
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.row_format = TTableRowFormat()
                    self.row_format.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = []
                        (_etype102, _size99) = iprot.readListBegin()
                        for _i103 in range(_size99):
                            _elem104 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem104.read(iprot)
                            _elem98.append(_elem104)
                        iprot.readListEnd()
                        self.partition_set.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetRowFormatParams')
        if self.row_format is not None:
            oprot.writeFieldBegin('row_format', TType.STRUCT, 1)
            self.row_format.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter105 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter105))
                for iter106 in iter105:
                    iter106.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row_format is None:
            raise TProtocolException(message='Required field row_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetLocationParams(object):
    """
    Attributes:
     - location
     - partition_spec
    """


    def __init__(self, location=None, partition_spec=None,):
        self.location = location
        self.partition_spec = partition_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem112.read(iprot)
                        self.partition_spec.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetLocationParams')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 1)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter113 in self.partition_spec:
                iter113.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableOrViewSetOwnerParams(object):
    """
    Attributes:
     - owner_type
     - owner_name
     - server_name
    """


    def __init__(self, owner_type=None, owner_name=None, server_name=None,):
        self.owner_type = owner_type
        self.owner_name = owner_name
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.owner_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableOrViewSetOwnerParams')
        if self.owner_type is not None:
            oprot.writeFieldBegin('owner_type', TType.I32, 1)
            oprot.writeI32(self.owner_type)
            oprot.writeFieldEnd()
        if self.owner_name is not None:
            oprot.writeFieldBegin('owner_name', TType.STRING, 2)
            oprot.writeString(self.owner_name.encode('utf-8') if sys.version_info[0] == 2 else self.owner_name)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 3)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.owner_type is None:
            raise TProtocolException(message='Required field owner_type is unset!')
        if self.owner_name is None:
            raise TProtocolException(message='Required field owner_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableUpdateStatsParams(object):
    """
    Attributes:
     - table_name
     - table_stats
     - partition_stats
     - column_stats
     - expect_all_partitions
     - is_incremental
    """


    def __init__(self, table_name=None, table_stats=None, partition_stats=None, column_stats=None, expect_all_partitions=None, is_incremental=None,):
        self.table_name = table_name
        self.table_stats = table_stats
        self.partition_stats = partition_stats
        self.column_stats = column_stats
        self.expect_all_partitions = expect_all_partitions
        self.is_incremental = is_incremental

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_stats = CatalogObjects.ttypes.TTableStats()
                    self.table_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.partition_stats = {}
                    (_ktype115, _vtype116, _size114) = iprot.readMapBegin()
                    for _i118 in range(_size114):
                        _key119 = []
                        (_etype124, _size121) = iprot.readListBegin()
                        for _i125 in range(_size121):
                            _elem126 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _key119.append(_elem126)
                        iprot.readListEnd()
                        _val120 = CatalogObjects.ttypes.TPartitionStats()
                        _val120.read(iprot)
                        self.partition_stats[_key119] = _val120
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.column_stats = {}
                    (_ktype128, _vtype129, _size127) = iprot.readMapBegin()
                    for _i131 in range(_size127):
                        _key132 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val133 = CatalogObjects.ttypes.TColumnStats()
                        _val133.read(iprot)
                        self.column_stats[_key132] = _val133
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.expect_all_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_incremental = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableUpdateStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.table_stats is not None:
            oprot.writeFieldBegin('table_stats', TType.STRUCT, 2)
            self.table_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.MAP, 3)
            oprot.writeMapBegin(TType.LIST, TType.STRUCT, len(self.partition_stats))
            for kiter134, viter135 in self.partition_stats.items():
                oprot.writeListBegin(TType.STRING, len(kiter134))
                for iter136 in kiter134:
                    oprot.writeString(iter136.encode('utf-8') if sys.version_info[0] == 2 else iter136)
                oprot.writeListEnd()
                viter135.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.column_stats is not None:
            oprot.writeFieldBegin('column_stats', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.column_stats))
            for kiter137, viter138 in self.column_stats.items():
                oprot.writeString(kiter137.encode('utf-8') if sys.version_info[0] == 2 else kiter137)
                viter138.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.expect_all_partitions is not None:
            oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 5)
            oprot.writeBool(self.expect_all_partitions)
            oprot.writeFieldEnd()
        if self.is_incremental is not None:
            oprot.writeFieldBegin('is_incremental', TType.BOOL, 6)
            oprot.writeBool(self.is_incremental)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetCachedParams(object):
    """
    Attributes:
     - cache_op
     - partition_set
    """


    def __init__(self, cache_op=None, partition_set=None,):
        self.cache_op = cache_op
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = []
                        (_etype148, _size145) = iprot.readListBegin()
                        for _i149 in range(_size145):
                            _elem150 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem150.read(iprot)
                            _elem144.append(_elem150)
                        iprot.readListEnd()
                        self.partition_set.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetCachedParams')
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 1)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter151 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter151))
                for iter152 in iter151:
                    iter152.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cache_op is None:
            raise TProtocolException(message='Required field cache_op is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableParams(object):
    """
    Attributes:
     - alter_type
     - table_name
     - rename_params
     - add_cols_params
     - add_partition_params
     - alter_col_params
     - drop_col_params
     - drop_partition_params
     - set_file_format_params
     - set_location_params
     - set_tbl_properties_params
     - update_stats_params
     - set_cached_params
     - add_drop_range_partition_params
     - set_row_format_params
     - set_owner_params
     - replace_cols_params
    """


    def __init__(self, alter_type=None, table_name=None, rename_params=None, add_cols_params=None, add_partition_params=None, alter_col_params=None, drop_col_params=None, drop_partition_params=None, set_file_format_params=None, set_location_params=None, set_tbl_properties_params=None, update_stats_params=None, set_cached_params=None, add_drop_range_partition_params=None, set_row_format_params=None, set_owner_params=None, replace_cols_params=None,):
        self.alter_type = alter_type
        self.table_name = table_name
        self.rename_params = rename_params
        self.add_cols_params = add_cols_params
        self.add_partition_params = add_partition_params
        self.alter_col_params = alter_col_params
        self.drop_col_params = drop_col_params
        self.drop_partition_params = drop_partition_params
        self.set_file_format_params = set_file_format_params
        self.set_location_params = set_location_params
        self.set_tbl_properties_params = set_tbl_properties_params
        self.update_stats_params = update_stats_params
        self.set_cached_params = set_cached_params
        self.add_drop_range_partition_params = add_drop_range_partition_params
        self.set_row_format_params = set_row_format_params
        self.set_owner_params = set_owner_params
        self.replace_cols_params = replace_cols_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.alter_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.rename_params = TAlterTableOrViewRenameParams()
                    self.rename_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.add_cols_params = TAlterTableAddColsParams()
                    self.add_cols_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.add_partition_params = TAlterTableAddPartitionParams()
                    self.add_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.alter_col_params = TAlterTableAlterColParams()
                    self.alter_col_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.drop_col_params = TAlterTableDropColParams()
                    self.drop_col_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.drop_partition_params = TAlterTableDropPartitionParams()
                    self.drop_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.set_file_format_params = TAlterTableSetFileFormatParams()
                    self.set_file_format_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.set_location_params = TAlterTableSetLocationParams()
                    self.set_location_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.set_tbl_properties_params = TAlterTableSetTblPropertiesParams()
                    self.set_tbl_properties_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.update_stats_params = TAlterTableUpdateStatsParams()
                    self.update_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.set_cached_params = TAlterTableSetCachedParams()
                    self.set_cached_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.add_drop_range_partition_params = TAlterTableAddDropRangePartitionParams()
                    self.add_drop_range_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.set_row_format_params = TAlterTableSetRowFormatParams()
                    self.set_row_format_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.set_owner_params = TAlterTableOrViewSetOwnerParams()
                    self.set_owner_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.replace_cols_params = TAlterTableReplaceColsParams()
                    self.replace_cols_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableParams')
        if self.alter_type is not None:
            oprot.writeFieldBegin('alter_type', TType.I32, 1)
            oprot.writeI32(self.alter_type)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.rename_params is not None:
            oprot.writeFieldBegin('rename_params', TType.STRUCT, 3)
            self.rename_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_cols_params is not None:
            oprot.writeFieldBegin('add_cols_params', TType.STRUCT, 4)
            self.add_cols_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_partition_params is not None:
            oprot.writeFieldBegin('add_partition_params', TType.STRUCT, 5)
            self.add_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_col_params is not None:
            oprot.writeFieldBegin('alter_col_params', TType.STRUCT, 6)
            self.alter_col_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_col_params is not None:
            oprot.writeFieldBegin('drop_col_params', TType.STRUCT, 7)
            self.drop_col_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_partition_params is not None:
            oprot.writeFieldBegin('drop_partition_params', TType.STRUCT, 8)
            self.drop_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_file_format_params is not None:
            oprot.writeFieldBegin('set_file_format_params', TType.STRUCT, 9)
            self.set_file_format_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_location_params is not None:
            oprot.writeFieldBegin('set_location_params', TType.STRUCT, 10)
            self.set_location_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_tbl_properties_params is not None:
            oprot.writeFieldBegin('set_tbl_properties_params', TType.STRUCT, 11)
            self.set_tbl_properties_params.write(oprot)
            oprot.writeFieldEnd()
        if self.update_stats_params is not None:
            oprot.writeFieldBegin('update_stats_params', TType.STRUCT, 12)
            self.update_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_cached_params is not None:
            oprot.writeFieldBegin('set_cached_params', TType.STRUCT, 13)
            self.set_cached_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_drop_range_partition_params is not None:
            oprot.writeFieldBegin('add_drop_range_partition_params', TType.STRUCT, 14)
            self.add_drop_range_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_row_format_params is not None:
            oprot.writeFieldBegin('set_row_format_params', TType.STRUCT, 15)
            self.set_row_format_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_owner_params is not None:
            oprot.writeFieldBegin('set_owner_params', TType.STRUCT, 16)
            self.set_owner_params.write(oprot)
            oprot.writeFieldEnd()
        if self.replace_cols_params is not None:
            oprot.writeFieldBegin('replace_cols_params', TType.STRUCT, 17)
            self.replace_cols_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.alter_type is None:
            raise TProtocolException(message='Required field alter_type is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTableLikeParams(object):
    """
    Attributes:
     - table_name
     - src_table_name
     - is_external
     - if_not_exists
     - owner
     - file_format
     - comment
     - location
     - sort_columns
     - server_name
     - sorting_order
    """


    def __init__(self, table_name=None, src_table_name=None, is_external=None, if_not_exists=None, owner=None, file_format=None, comment=None, location=None, sort_columns=None, server_name=None, sorting_order=None,):
        self.table_name = table_name
        self.src_table_name = src_table_name
        self.is_external = is_external
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.file_format = file_format
        self.comment = comment
        self.location = location
        self.sort_columns = sort_columns
        self.server_name = server_name
        self.sorting_order = sorting_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.src_table_name = CatalogObjects.ttypes.TTableName()
                    self.src_table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_external = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.owner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.sort_columns = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.sort_columns.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTableLikeParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.src_table_name is not None:
            oprot.writeFieldBegin('src_table_name', TType.STRUCT, 2)
            self.src_table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.is_external is not None:
            oprot.writeFieldBegin('is_external', TType.BOOL, 3)
            oprot.writeBool(self.is_external)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 5)
            oprot.writeString(self.owner.encode('utf-8') if sys.version_info[0] == 2 else self.owner)
            oprot.writeFieldEnd()
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 6)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 7)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 8)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.sort_columns is not None:
            oprot.writeFieldBegin('sort_columns', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.sort_columns))
            for iter159 in self.sort_columns:
                oprot.writeString(iter159.encode('utf-8') if sys.version_info[0] == 2 else iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 10)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 11)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.src_table_name is None:
            raise TProtocolException(message='Required field src_table_name is unset!')
        if self.is_external is None:
            raise TProtocolException(message='Required field is_external is unset!')
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTableParams(object):
    """
    Attributes:
     - table_name
     - columns
     - partition_columns
     - file_format
     - is_external
     - if_not_exists
     - owner
     - row_format
     - comment
     - location
     - table_properties
     - serde_properties
     - cache_op
     - partition_by
     - primary_key_column_names
     - sort_columns
     - server_name
     - sorting_order
     - primary_keys
     - foreign_keys
    """


    def __init__(self, table_name=None, columns=None, partition_columns=None, file_format=None, is_external=None, if_not_exists=None, owner=None, row_format=None, comment=None, location=None, table_properties=None, serde_properties=None, cache_op=None, partition_by=None, primary_key_column_names=None, sort_columns=None, server_name=None, sorting_order=None, primary_keys=None, foreign_keys=None,):
        self.table_name = table_name
        self.columns = columns
        self.partition_columns = partition_columns
        self.file_format = file_format
        self.is_external = is_external
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.row_format = row_format
        self.comment = comment
        self.location = location
        self.table_properties = table_properties
        self.serde_properties = serde_properties
        self.cache_op = cache_op
        self.partition_by = partition_by
        self.primary_key_column_names = primary_key_column_names
        self.sort_columns = sort_columns
        self.server_name = server_name
        self.sorting_order = sorting_order
        self.primary_keys = primary_keys
        self.foreign_keys = foreign_keys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = CatalogObjects.ttypes.TColumn()
                        _elem165.read(iprot)
                        self.columns.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partition_columns = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = CatalogObjects.ttypes.TColumn()
                        _elem171.read(iprot)
                        self.partition_columns.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_external = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.owner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.row_format = TTableRowFormat()
                    self.row_format.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.MAP:
                    self.table_properties = {}
                    (_ktype173, _vtype174, _size172) = iprot.readMapBegin()
                    for _i176 in range(_size172):
                        _key177 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val178 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.table_properties[_key177] = _val178
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.serde_properties = {}
                    (_ktype180, _vtype181, _size179) = iprot.readMapBegin()
                    for _i183 in range(_size179):
                        _key184 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val185 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.serde_properties[_key184] = _val185
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.partition_by = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = CatalogObjects.ttypes.TKuduPartitionParam()
                        _elem191.read(iprot)
                        self.partition_by.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.primary_key_column_names = []
                    (_etype195, _size192) = iprot.readListBegin()
                    for _i196 in range(_size192):
                        _elem197 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.primary_key_column_names.append(_elem197)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.sort_columns = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.sort_columns.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.LIST:
                    self.primary_keys = []
                    (_etype207, _size204) = iprot.readListBegin()
                    for _i208 in range(_size204):
                        _elem209 = hive_metastore.ttypes.SQLPrimaryKey()
                        _elem209.read(iprot)
                        self.primary_keys.append(_elem209)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.LIST:
                    self.foreign_keys = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = hive_metastore.ttypes.SQLForeignKey()
                        _elem215.read(iprot)
                        self.foreign_keys.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTableParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter216 in self.columns:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_columns is not None:
            oprot.writeFieldBegin('partition_columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_columns))
            for iter217 in self.partition_columns:
                iter217.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 4)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.is_external is not None:
            oprot.writeFieldBegin('is_external', TType.BOOL, 5)
            oprot.writeBool(self.is_external)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 6)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 7)
            oprot.writeString(self.owner.encode('utf-8') if sys.version_info[0] == 2 else self.owner)
            oprot.writeFieldEnd()
        if self.row_format is not None:
            oprot.writeFieldBegin('row_format', TType.STRUCT, 8)
            self.row_format.write(oprot)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 9)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 10)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.table_properties is not None:
            oprot.writeFieldBegin('table_properties', TType.MAP, 11)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.table_properties))
            for kiter218, viter219 in self.table_properties.items():
                oprot.writeString(kiter218.encode('utf-8') if sys.version_info[0] == 2 else kiter218)
                oprot.writeString(viter219.encode('utf-8') if sys.version_info[0] == 2 else viter219)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.serde_properties is not None:
            oprot.writeFieldBegin('serde_properties', TType.MAP, 12)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.serde_properties))
            for kiter220, viter221 in self.serde_properties.items():
                oprot.writeString(kiter220.encode('utf-8') if sys.version_info[0] == 2 else kiter220)
                oprot.writeString(viter221.encode('utf-8') if sys.version_info[0] == 2 else viter221)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 13)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_by is not None:
            oprot.writeFieldBegin('partition_by', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
            for iter222 in self.partition_by:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.primary_key_column_names is not None:
            oprot.writeFieldBegin('primary_key_column_names', TType.LIST, 15)
            oprot.writeListBegin(TType.STRING, len(self.primary_key_column_names))
            for iter223 in self.primary_key_column_names:
                oprot.writeString(iter223.encode('utf-8') if sys.version_info[0] == 2 else iter223)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_columns is not None:
            oprot.writeFieldBegin('sort_columns', TType.LIST, 16)
            oprot.writeListBegin(TType.STRING, len(self.sort_columns))
            for iter224 in self.sort_columns:
                oprot.writeString(iter224.encode('utf-8') if sys.version_info[0] == 2 else iter224)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 17)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 18)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        if self.primary_keys is not None:
            oprot.writeFieldBegin('primary_keys', TType.LIST, 19)
            oprot.writeListBegin(TType.STRUCT, len(self.primary_keys))
            for iter225 in self.primary_keys:
                iter225.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.foreign_keys is not None:
            oprot.writeFieldBegin('foreign_keys', TType.LIST, 20)
            oprot.writeListBegin(TType.STRUCT, len(self.foreign_keys))
            for iter226 in self.foreign_keys:
                iter226.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.file_format is None:
            raise TProtocolException(message='Required field file_format is unset!')
        if self.is_external is None:
            raise TProtocolException(message='Required field is_external is unset!')
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateOrAlterViewParams(object):
    """
    Attributes:
     - view_name
     - columns
     - owner
     - original_view_def
     - expanded_view_def
     - comment
     - if_not_exists
     - server_name
    """


    def __init__(self, view_name=None, columns=None, owner=None, original_view_def=None, expanded_view_def=None, comment=None, if_not_exists=None, server_name=None,):
        self.view_name = view_name
        self.columns = columns
        self.owner = owner
        self.original_view_def = original_view_def
        self.expanded_view_def = expanded_view_def
        self.comment = comment
        self.if_not_exists = if_not_exists
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.view_name = CatalogObjects.ttypes.TTableName()
                    self.view_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = CatalogObjects.ttypes.TColumn()
                        _elem232.read(iprot)
                        self.columns.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.owner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.original_view_def = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.expanded_view_def = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateOrAlterViewParams')
        if self.view_name is not None:
            oprot.writeFieldBegin('view_name', TType.STRUCT, 1)
            self.view_name.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter233 in self.columns:
                iter233.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 3)
            oprot.writeString(self.owner.encode('utf-8') if sys.version_info[0] == 2 else self.owner)
            oprot.writeFieldEnd()
        if self.original_view_def is not None:
            oprot.writeFieldBegin('original_view_def', TType.STRING, 4)
            oprot.writeString(self.original_view_def.encode('utf-8') if sys.version_info[0] == 2 else self.original_view_def)
            oprot.writeFieldEnd()
        if self.expanded_view_def is not None:
            oprot.writeFieldBegin('expanded_view_def', TType.STRING, 5)
            oprot.writeString(self.expanded_view_def.encode('utf-8') if sys.version_info[0] == 2 else self.expanded_view_def)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 6)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 7)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 8)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.view_name is None:
            raise TProtocolException(message='Required field view_name is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.original_view_def is None:
            raise TProtocolException(message='Required field original_view_def is unset!')
        if self.expanded_view_def is None:
            raise TProtocolException(message='Required field expanded_view_def is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TComputeStatsParams(object):
    """
    Attributes:
     - table_name
     - tbl_stats_query
     - col_stats_query
     - is_incremental
     - existing_part_stats
     - expected_partitions
     - expect_all_partitions
     - num_partition_cols
     - total_file_bytes
    """


    def __init__(self, table_name=None, tbl_stats_query=None, col_stats_query=None, is_incremental=None, existing_part_stats=None, expected_partitions=None, expect_all_partitions=None, num_partition_cols=None, total_file_bytes=None,):
        self.table_name = table_name
        self.tbl_stats_query = tbl_stats_query
        self.col_stats_query = col_stats_query
        self.is_incremental = is_incremental
        self.existing_part_stats = existing_part_stats
        self.expected_partitions = expected_partitions
        self.expect_all_partitions = expect_all_partitions
        self.num_partition_cols = num_partition_cols
        self.total_file_bytes = total_file_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_stats_query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_stats_query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_incremental = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.existing_part_stats = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = CatalogObjects.ttypes.TPartitionStats()
                        _elem239.read(iprot)
                        self.existing_part_stats.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.expected_partitions = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = []
                        (_etype249, _size246) = iprot.readListBegin()
                        for _i250 in range(_size246):
                            _elem251 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _elem245.append(_elem251)
                        iprot.readListEnd()
                        self.expected_partitions.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.expect_all_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.num_partition_cols = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.total_file_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TComputeStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_stats_query is not None:
            oprot.writeFieldBegin('tbl_stats_query', TType.STRING, 2)
            oprot.writeString(self.tbl_stats_query.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_stats_query)
            oprot.writeFieldEnd()
        if self.col_stats_query is not None:
            oprot.writeFieldBegin('col_stats_query', TType.STRING, 3)
            oprot.writeString(self.col_stats_query.encode('utf-8') if sys.version_info[0] == 2 else self.col_stats_query)
            oprot.writeFieldEnd()
        if self.is_incremental is not None:
            oprot.writeFieldBegin('is_incremental', TType.BOOL, 4)
            oprot.writeBool(self.is_incremental)
            oprot.writeFieldEnd()
        if self.existing_part_stats is not None:
            oprot.writeFieldBegin('existing_part_stats', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.existing_part_stats))
            for iter252 in self.existing_part_stats:
                iter252.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expected_partitions is not None:
            oprot.writeFieldBegin('expected_partitions', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.expected_partitions))
            for iter253 in self.expected_partitions:
                oprot.writeListBegin(TType.STRING, len(iter253))
                for iter254 in iter253:
                    oprot.writeString(iter254.encode('utf-8') if sys.version_info[0] == 2 else iter254)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expect_all_partitions is not None:
            oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 7)
            oprot.writeBool(self.expect_all_partitions)
            oprot.writeFieldEnd()
        if self.num_partition_cols is not None:
            oprot.writeFieldBegin('num_partition_cols', TType.I32, 8)
            oprot.writeI32(self.num_partition_cols)
            oprot.writeFieldEnd()
        if self.total_file_bytes is not None:
            oprot.writeFieldBegin('total_file_bytes', TType.I64, 9)
            oprot.writeI64(self.total_file_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDropRoleParams(object):
    """
    Attributes:
     - is_drop
     - role_name
    """


    def __init__(self, is_drop=None, role_name=None,):
        self.is_drop = is_drop
        self.role_name = role_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_drop = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDropRoleParams')
        if self.is_drop is not None:
            oprot.writeFieldBegin('is_drop', TType.BOOL, 1)
            oprot.writeBool(self.is_drop)
            oprot.writeFieldEnd()
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 2)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_drop is None:
            raise TProtocolException(message='Required field is_drop is unset!')
        if self.role_name is None:
            raise TProtocolException(message='Required field role_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGrantRevokeRoleParams(object):
    """
    Attributes:
     - role_names
     - group_names
     - is_grant
    """


    def __init__(self, role_names=None, group_names=None, is_grant=None,):
        self.role_names = role_names
        self.group_names = group_names
        self.is_grant = is_grant

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.role_names = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.role_names.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_grant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGrantRevokeRoleParams')
        if self.role_names is not None:
            oprot.writeFieldBegin('role_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.role_names))
            for iter267 in self.role_names:
                oprot.writeString(iter267.encode('utf-8') if sys.version_info[0] == 2 else iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter268 in self.group_names:
                oprot.writeString(iter268.encode('utf-8') if sys.version_info[0] == 2 else iter268)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_grant is not None:
            oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
            oprot.writeBool(self.is_grant)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.role_names is None:
            raise TProtocolException(message='Required field role_names is unset!')
        if self.group_names is None:
            raise TProtocolException(message='Required field group_names is unset!')
        if self.is_grant is None:
            raise TProtocolException(message='Required field is_grant is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGrantRevokePrivParams(object):
    """
    Attributes:
     - privileges
     - principal_name
     - is_grant
     - has_grant_opt
     - principal_type
    """


    def __init__(self, privileges=None, principal_name=None, is_grant=None, has_grant_opt=None, principal_type=None,):
        self.privileges = privileges
        self.principal_name = principal_name
        self.is_grant = is_grant
        self.has_grant_opt = has_grant_opt
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.privileges = []
                    (_etype272, _size269) = iprot.readListBegin()
                    for _i273 in range(_size269):
                        _elem274 = CatalogObjects.ttypes.TPrivilege()
                        _elem274.read(iprot)
                        self.privileges.append(_elem274)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_grant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.has_grant_opt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGrantRevokePrivParams')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.privileges))
            for iter275 in self.privileges:
                iter275.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.is_grant is not None:
            oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
            oprot.writeBool(self.is_grant)
            oprot.writeFieldEnd()
        if self.has_grant_opt is not None:
            oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
            oprot.writeBool(self.has_grant_opt)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 5)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.privileges is None:
            raise TProtocolException(message='Required field privileges is unset!')
        if self.principal_name is None:
            raise TProtocolException(message='Required field principal_name is unset!')
        if self.is_grant is None:
            raise TProtocolException(message='Required field is_grant is unset!')
        if self.has_grant_opt is None:
            raise TProtocolException(message='Required field has_grant_opt is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropDbParams(object):
    """
    Attributes:
     - db
     - if_exists
     - cascade
     - server_name
    """


    def __init__(self, db=None, if_exists=None, cascade=None, server_name=None,):
        self.db = db
        self.if_exists = if_exists
        self.cascade = cascade
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 3)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 4)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.cascade is None:
            raise TProtocolException(message='Required field cascade is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTableOrViewParams(object):
    """
    Attributes:
     - table_name
     - if_exists
     - purge
     - is_table
     - server_name
    """


    def __init__(self, table_name=None, if_exists=None, purge=None, is_table=None, server_name=None,):
        self.table_name = table_name
        self.if_exists = if_exists
        self.purge = purge
        self.is_table = is_table
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.purge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_table = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTableOrViewParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.purge is not None:
            oprot.writeFieldBegin('purge', TType.BOOL, 3)
            oprot.writeBool(self.purge)
            oprot.writeFieldEnd()
        if self.is_table is not None:
            oprot.writeFieldBegin('is_table', TType.BOOL, 4)
            oprot.writeBool(self.is_table)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 5)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.purge is None:
            raise TProtocolException(message='Required field purge is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTruncateParams(object):
    """
    Attributes:
     - table_name
     - if_exists
    """


    def __init__(self, table_name=None, if_exists=None,):
        self.table_name = table_name
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTruncateParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionParams(object):
    """
    Attributes:
     - fn_name
     - arg_types
     - if_exists
     - signature
    """


    def __init__(self, fn_name=None, arg_types=None, if_exists=None, signature=None,):
        self.fn_name = fn_name
        self.arg_types = arg_types
        self.if_exists = if_exists
        self.signature = signature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn_name = Types.ttypes.TFunctionName()
                    self.fn_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arg_types = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = Types.ttypes.TColumnType()
                        _elem281.read(iprot)
                        self.arg_types.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.signature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionParams')
        if self.fn_name is not None:
            oprot.writeFieldBegin('fn_name', TType.STRUCT, 1)
            self.fn_name.write(oprot)
            oprot.writeFieldEnd()
        if self.arg_types is not None:
            oprot.writeFieldBegin('arg_types', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
            for iter282 in self.arg_types:
                iter282.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.signature is not None:
            oprot.writeFieldBegin('signature', TType.STRING, 4)
            oprot.writeString(self.signature.encode('utf-8') if sys.version_info[0] == 2 else self.signature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn_name is None:
            raise TProtocolException(message='Required field fn_name is unset!')
        if self.arg_types is None:
            raise TProtocolException(message='Required field arg_types is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableUsageMetrics(object):
    """
    Attributes:
     - table_name
     - memory_estimate_bytes
     - num_metadata_operations
     - num_files
     - median_table_loading_ns
     - max_table_loading_ns
     - num_table_loading
     - p75_loading_time_ns
     - p95_loading_time_ns
     - p99_loading_time_ns
    """


    def __init__(self, table_name=None, memory_estimate_bytes=None, num_metadata_operations=None, num_files=None, median_table_loading_ns=None, max_table_loading_ns=None, num_table_loading=None, p75_loading_time_ns=None, p95_loading_time_ns=None, p99_loading_time_ns=None,):
        self.table_name = table_name
        self.memory_estimate_bytes = memory_estimate_bytes
        self.num_metadata_operations = num_metadata_operations
        self.num_files = num_files
        self.median_table_loading_ns = median_table_loading_ns
        self.max_table_loading_ns = max_table_loading_ns
        self.num_table_loading = num_table_loading
        self.p75_loading_time_ns = p75_loading_time_ns
        self.p95_loading_time_ns = p95_loading_time_ns
        self.p99_loading_time_ns = p99_loading_time_ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.memory_estimate_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_metadata_operations = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_files = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.median_table_loading_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_table_loading_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.num_table_loading = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.p75_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.p95_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.p99_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableUsageMetrics')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.memory_estimate_bytes is not None:
            oprot.writeFieldBegin('memory_estimate_bytes', TType.I64, 2)
            oprot.writeI64(self.memory_estimate_bytes)
            oprot.writeFieldEnd()
        if self.num_metadata_operations is not None:
            oprot.writeFieldBegin('num_metadata_operations', TType.I64, 3)
            oprot.writeI64(self.num_metadata_operations)
            oprot.writeFieldEnd()
        if self.num_files is not None:
            oprot.writeFieldBegin('num_files', TType.I64, 4)
            oprot.writeI64(self.num_files)
            oprot.writeFieldEnd()
        if self.median_table_loading_ns is not None:
            oprot.writeFieldBegin('median_table_loading_ns', TType.I64, 5)
            oprot.writeI64(self.median_table_loading_ns)
            oprot.writeFieldEnd()
        if self.max_table_loading_ns is not None:
            oprot.writeFieldBegin('max_table_loading_ns', TType.I64, 6)
            oprot.writeI64(self.max_table_loading_ns)
            oprot.writeFieldEnd()
        if self.num_table_loading is not None:
            oprot.writeFieldBegin('num_table_loading', TType.I64, 7)
            oprot.writeI64(self.num_table_loading)
            oprot.writeFieldEnd()
        if self.p75_loading_time_ns is not None:
            oprot.writeFieldBegin('p75_loading_time_ns', TType.I64, 8)
            oprot.writeI64(self.p75_loading_time_ns)
            oprot.writeFieldEnd()
        if self.p95_loading_time_ns is not None:
            oprot.writeFieldBegin('p95_loading_time_ns', TType.I64, 9)
            oprot.writeI64(self.p95_loading_time_ns)
            oprot.writeFieldEnd()
        if self.p99_loading_time_ns is not None:
            oprot.writeFieldBegin('p99_loading_time_ns', TType.I64, 10)
            oprot.writeI64(self.p99_loading_time_ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogUsageResponse(object):
    """
    Attributes:
     - large_tables
     - frequently_accessed_tables
     - high_file_count_tables
     - long_metadata_loading_tables
    """


    def __init__(self, large_tables=None, frequently_accessed_tables=None, high_file_count_tables=None, long_metadata_loading_tables=None,):
        self.large_tables = large_tables
        self.frequently_accessed_tables = frequently_accessed_tables
        self.high_file_count_tables = high_file_count_tables
        self.long_metadata_loading_tables = long_metadata_loading_tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.large_tables = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = TTableUsageMetrics()
                        _elem288.read(iprot)
                        self.large_tables.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.frequently_accessed_tables = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = TTableUsageMetrics()
                        _elem294.read(iprot)
                        self.frequently_accessed_tables.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.high_file_count_tables = []
                    (_etype298, _size295) = iprot.readListBegin()
                    for _i299 in range(_size295):
                        _elem300 = TTableUsageMetrics()
                        _elem300.read(iprot)
                        self.high_file_count_tables.append(_elem300)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.long_metadata_loading_tables = []
                    (_etype304, _size301) = iprot.readListBegin()
                    for _i305 in range(_size301):
                        _elem306 = TTableUsageMetrics()
                        _elem306.read(iprot)
                        self.long_metadata_loading_tables.append(_elem306)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogUsageResponse')
        if self.large_tables is not None:
            oprot.writeFieldBegin('large_tables', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.large_tables))
            for iter307 in self.large_tables:
                iter307.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.frequently_accessed_tables is not None:
            oprot.writeFieldBegin('frequently_accessed_tables', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.frequently_accessed_tables))
            for iter308 in self.frequently_accessed_tables:
                iter308.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.high_file_count_tables is not None:
            oprot.writeFieldBegin('high_file_count_tables', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.high_file_count_tables))
            for iter309 in self.high_file_count_tables:
                iter309.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.long_metadata_loading_tables is not None:
            oprot.writeFieldBegin('long_metadata_loading_tables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.long_metadata_loading_tables))
            for iter310 in self.long_metadata_loading_tables:
                iter310.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.large_tables is None:
            raise TProtocolException(message='Required field large_tables is unset!')
        if self.frequently_accessed_tables is None:
            raise TProtocolException(message='Required field frequently_accessed_tables is unset!')
        if self.high_file_count_tables is None:
            raise TProtocolException(message='Required field high_file_count_tables is unset!')
        if self.long_metadata_loading_tables is None:
            raise TProtocolException(message='Required field long_metadata_loading_tables is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOperationUsageCounter(object):
    """
    Attributes:
     - catalog_op_name
     - table_name
     - op_counter
    """


    def __init__(self, catalog_op_name=None, table_name=None, op_counter=None,):
        self.catalog_op_name = catalog_op_name
        self.table_name = table_name
        self.op_counter = op_counter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalog_op_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.op_counter = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOperationUsageCounter')
        if self.catalog_op_name is not None:
            oprot.writeFieldBegin('catalog_op_name', TType.STRING, 1)
            oprot.writeString(self.catalog_op_name.encode('utf-8') if sys.version_info[0] == 2 else self.catalog_op_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.op_counter is not None:
            oprot.writeFieldBegin('op_counter', TType.I64, 3)
            oprot.writeI64(self.op_counter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_op_name is None:
            raise TProtocolException(message='Required field catalog_op_name is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetOperationUsageResponse(object):
    """
    Attributes:
     - catalog_op_counters
    """


    def __init__(self, catalog_op_counters=None,):
        self.catalog_op_counters = catalog_op_counters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.catalog_op_counters = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = TOperationUsageCounter()
                        _elem316.read(iprot)
                        self.catalog_op_counters.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetOperationUsageResponse')
        if self.catalog_op_counters is not None:
            oprot.writeFieldBegin('catalog_op_counters', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.catalog_op_counters))
            for iter317 in self.catalog_op_counters:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_op_counters is None:
            raise TProtocolException(message='Required field catalog_op_counters is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnName(object):
    """
    Attributes:
     - table_name
     - column_name
    """


    def __init__(self, table_name=None, column_name=None,):
        self.table_name = table_name
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnName')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 2)
            oprot.writeString(self.column_name.encode('utf-8') if sys.version_info[0] == 2 else self.column_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.column_name is None:
            raise TProtocolException(message='Required field column_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommentOnParams(object):
    """
    Attributes:
     - comment
     - db
     - table_name
     - column_name
    """


    def __init__(self, comment=None, db=None, table_name=None, column_name=None,):
        self.comment = comment
        self.db = db
        self.table_name = table_name
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.column_name = TColumnName()
                    self.column_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommentOnParams')
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 1)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 3)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRUCT, 4)
            self.column_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventProcessorMetrics(object):
    """
    Attributes:
     - status
     - events_received
     - events_skipped
     - events_fetch_duration_mean
     - events_process_duration_mean
     - events_received_1min_rate
     - events_received_5min_rate
     - events_received_15min_rate
     - events_skipped_per_poll_mean
     - last_synced_event_id
    """


    def __init__(self, status=None, events_received=None, events_skipped=None, events_fetch_duration_mean=None, events_process_duration_mean=None, events_received_1min_rate=None, events_received_5min_rate=None, events_received_15min_rate=None, events_skipped_per_poll_mean=None, last_synced_event_id=None,):
        self.status = status
        self.events_received = events_received
        self.events_skipped = events_skipped
        self.events_fetch_duration_mean = events_fetch_duration_mean
        self.events_process_duration_mean = events_process_duration_mean
        self.events_received_1min_rate = events_received_1min_rate
        self.events_received_5min_rate = events_received_5min_rate
        self.events_received_15min_rate = events_received_15min_rate
        self.events_skipped_per_poll_mean = events_skipped_per_poll_mean
        self.last_synced_event_id = last_synced_event_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.events_received = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.events_skipped = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.events_fetch_duration_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.events_process_duration_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.events_received_1min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.events_received_5min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.events_received_15min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.events_skipped_per_poll_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.last_synced_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventProcessorMetrics')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 1)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.events_received is not None:
            oprot.writeFieldBegin('events_received', TType.I64, 2)
            oprot.writeI64(self.events_received)
            oprot.writeFieldEnd()
        if self.events_skipped is not None:
            oprot.writeFieldBegin('events_skipped', TType.I64, 3)
            oprot.writeI64(self.events_skipped)
            oprot.writeFieldEnd()
        if self.events_fetch_duration_mean is not None:
            oprot.writeFieldBegin('events_fetch_duration_mean', TType.DOUBLE, 4)
            oprot.writeDouble(self.events_fetch_duration_mean)
            oprot.writeFieldEnd()
        if self.events_process_duration_mean is not None:
            oprot.writeFieldBegin('events_process_duration_mean', TType.DOUBLE, 5)
            oprot.writeDouble(self.events_process_duration_mean)
            oprot.writeFieldEnd()
        if self.events_received_1min_rate is not None:
            oprot.writeFieldBegin('events_received_1min_rate', TType.DOUBLE, 6)
            oprot.writeDouble(self.events_received_1min_rate)
            oprot.writeFieldEnd()
        if self.events_received_5min_rate is not None:
            oprot.writeFieldBegin('events_received_5min_rate', TType.DOUBLE, 7)
            oprot.writeDouble(self.events_received_5min_rate)
            oprot.writeFieldEnd()
        if self.events_received_15min_rate is not None:
            oprot.writeFieldBegin('events_received_15min_rate', TType.DOUBLE, 8)
            oprot.writeDouble(self.events_received_15min_rate)
            oprot.writeFieldEnd()
        if self.events_skipped_per_poll_mean is not None:
            oprot.writeFieldBegin('events_skipped_per_poll_mean', TType.DOUBLE, 9)
            oprot.writeDouble(self.events_skipped_per_poll_mean)
            oprot.writeFieldEnd()
        if self.last_synced_event_id is not None:
            oprot.writeFieldBegin('last_synced_event_id', TType.I64, 10)
            oprot.writeI64(self.last_synced_event_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogServerMetricsResponse(object):
    """
    Attributes:
     - catalog_partial_fetch_rpc_queue_len
     - event_metrics
    """


    def __init__(self, catalog_partial_fetch_rpc_queue_len=None, event_metrics=None,):
        self.catalog_partial_fetch_rpc_queue_len = catalog_partial_fetch_rpc_queue_len
        self.event_metrics = event_metrics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.catalog_partial_fetch_rpc_queue_len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.event_metrics = TEventProcessorMetrics()
                    self.event_metrics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogServerMetricsResponse')
        if self.catalog_partial_fetch_rpc_queue_len is not None:
            oprot.writeFieldBegin('catalog_partial_fetch_rpc_queue_len', TType.I32, 1)
            oprot.writeI32(self.catalog_partial_fetch_rpc_queue_len)
            oprot.writeFieldEnd()
        if self.event_metrics is not None:
            oprot.writeFieldBegin('event_metrics', TType.STRUCT, 2)
            self.event_metrics.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_partial_fetch_rpc_queue_len is None:
            raise TProtocolException(message='Required field catalog_partial_fetch_rpc_queue_len is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCopyTestCaseReq(object):
    """
    Attributes:
     - input_path
    """


    def __init__(self, input_path=None,):
        self.input_path = input_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.input_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCopyTestCaseReq')
        if self.input_path is not None:
            oprot.writeFieldBegin('input_path', TType.STRING, 1)
            oprot.writeString(self.input_path.encode('utf-8') if sys.version_info[0] == 2 else self.input_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_path is None:
            raise TProtocolException(message='Required field input_path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventProcessorMetricsSummaryResponse(object):
    """
    Attributes:
     - summary
    """


    def __init__(self, summary=None,):
        self.summary = summary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.summary = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventProcessorMetricsSummaryResponse')
        if self.summary is not None:
            oprot.writeFieldBegin('summary', TType.STRING, 1)
            oprot.writeString(self.summary.encode('utf-8') if sys.version_info[0] == 2 else self.summary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.summary is None:
            raise TProtocolException(message='Required field summary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TAlterDbSetOwnerParams)
TAlterDbSetOwnerParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'owner_type', None, None, ),  # 1
    (2, TType.STRING, 'owner_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'server_name', 'UTF8', None, ),  # 3
)
all_structs.append(TAlterDbParams)
TAlterDbParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'alter_type', None, None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'set_owner_params', [TAlterDbSetOwnerParams, None], None, ),  # 3
)
all_structs.append(TCreateDbParams)
TCreateDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'comment', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'location', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ),  # 4
    (5, TType.STRING, 'owner', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'server_name', 'UTF8', None, ),  # 6
)
all_structs.append(TCreateDataSourceParams)
TCreateDataSourceParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'data_source', [CatalogObjects.ttypes.TDataSource, None], None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TDropDataSourceParams)
TDropDataSourceParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data_source', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
)
all_structs.append(TDropStatsParams)
TDropStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TCreateFunctionParams)
TCreateFunctionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TTableRowFormat)
TTableRowFormat.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'field_terminator', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'line_terminator', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'escaped_by', 'UTF8', None, ),  # 3
)
all_structs.append(THdfsCachingOp)
THdfsCachingOp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'set_cached', None, None, ),  # 1
    (2, TType.STRING, 'cache_pool_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'replication', None, None, ),  # 3
)
all_structs.append(TAlterTableOrViewRenameParams)
TAlterTableOrViewRenameParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'new_table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
)
all_structs.append(TAlterTableAddColsParams)
TAlterTableAddColsParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TAlterTableReplaceColsParams)
TAlterTableReplaceColsParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 1
)
all_structs.append(TPartitionDef)
TPartitionDef.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 1
    (2, TType.STRING, 'location', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 3
)
all_structs.append(TAlterTableAddPartitionParams)
TAlterTableAddPartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'if_not_exists', None, None, ),  # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT, [TPartitionDef, None], False), None, ),  # 2
)
all_structs.append(TAlterTableAddDropRangePartitionParams)
TAlterTableAddDropRangePartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'range_partition_spec', [CatalogObjects.ttypes.TRangePartition, None], None, ),  # 1
    (2, TType.BOOL, 'ignore_errors', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)
all_structs.append(TAlterTableDropColParams)
TAlterTableDropColParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'col_name', 'UTF8', None, ),  # 1
)
all_structs.append(TAlterTableDropPartitionParams)
TAlterTableDropPartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'purge', None, None, ),  # 3
)
all_structs.append(TAlterTableAlterColParams)
TAlterTableAlterColParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'col_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'new_col_def', [CatalogObjects.ttypes.TColumn, None], None, ),  # 2
)
all_structs.append(TAlterTableSetTblPropertiesParams)
TAlterTableSetTblPropertiesParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'target', None, None, ),  # 1
    (2, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 3
)
all_structs.append(TAlterTableSetFileFormatParams)
TAlterTableSetFileFormatParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'file_format', None, None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableSetRowFormatParams)
TAlterTableSetRowFormatParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'row_format', [TTableRowFormat, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableSetLocationParams)
TAlterTableSetLocationParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'location', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 2
)
all_structs.append(TAlterTableOrViewSetOwnerParams)
TAlterTableOrViewSetOwnerParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'owner_type', None, None, ),  # 1
    (2, TType.STRING, 'owner_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'server_name', 'UTF8', None, ),  # 3
)
all_structs.append(TAlterTableUpdateStatsParams)
TAlterTableUpdateStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRUCT, 'table_stats', [CatalogObjects.ttypes.TTableStats, None], None, ),  # 2
    (3, TType.MAP, 'partition_stats', (TType.LIST, (TType.STRING, 'UTF8', False), TType.STRUCT, [CatalogObjects.ttypes.TPartitionStats, None], False), None, ),  # 3
    (4, TType.MAP, 'column_stats', (TType.STRING, 'UTF8', TType.STRUCT, [CatalogObjects.ttypes.TColumnStats, None], False), None, ),  # 4
    (5, TType.BOOL, 'expect_all_partitions', None, None, ),  # 5
    (6, TType.BOOL, 'is_incremental', None, None, ),  # 6
)
all_structs.append(TAlterTableSetCachedParams)
TAlterTableSetCachedParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableParams)
TAlterTableParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'alter_type', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRUCT, 'rename_params', [TAlterTableOrViewRenameParams, None], None, ),  # 3
    (4, TType.STRUCT, 'add_cols_params', [TAlterTableAddColsParams, None], None, ),  # 4
    (5, TType.STRUCT, 'add_partition_params', [TAlterTableAddPartitionParams, None], None, ),  # 5
    (6, TType.STRUCT, 'alter_col_params', [TAlterTableAlterColParams, None], None, ),  # 6
    (7, TType.STRUCT, 'drop_col_params', [TAlterTableDropColParams, None], None, ),  # 7
    (8, TType.STRUCT, 'drop_partition_params', [TAlterTableDropPartitionParams, None], None, ),  # 8
    (9, TType.STRUCT, 'set_file_format_params', [TAlterTableSetFileFormatParams, None], None, ),  # 9
    (10, TType.STRUCT, 'set_location_params', [TAlterTableSetLocationParams, None], None, ),  # 10
    (11, TType.STRUCT, 'set_tbl_properties_params', [TAlterTableSetTblPropertiesParams, None], None, ),  # 11
    (12, TType.STRUCT, 'update_stats_params', [TAlterTableUpdateStatsParams, None], None, ),  # 12
    (13, TType.STRUCT, 'set_cached_params', [TAlterTableSetCachedParams, None], None, ),  # 13
    (14, TType.STRUCT, 'add_drop_range_partition_params', [TAlterTableAddDropRangePartitionParams, None], None, ),  # 14
    (15, TType.STRUCT, 'set_row_format_params', [TAlterTableSetRowFormatParams, None], None, ),  # 15
    (16, TType.STRUCT, 'set_owner_params', [TAlterTableOrViewSetOwnerParams, None], None, ),  # 16
    (17, TType.STRUCT, 'replace_cols_params', [TAlterTableReplaceColsParams, None], None, ),  # 17
)
all_structs.append(TCreateTableLikeParams)
TCreateTableLikeParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRUCT, 'src_table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.BOOL, 'is_external', None, None, ),  # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ),  # 4
    (5, TType.STRING, 'owner', 'UTF8', None, ),  # 5
    (6, TType.I32, 'file_format', None, None, ),  # 6
    (7, TType.STRING, 'comment', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'location', 'UTF8', None, ),  # 8
    (9, TType.LIST, 'sort_columns', (TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.STRING, 'server_name', 'UTF8', None, ),  # 10
    (11, TType.I32, 'sorting_order', None, None, ),  # 11
)
all_structs.append(TCreateTableParams)
TCreateTableParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 2
    (3, TType.LIST, 'partition_columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 3
    (4, TType.I32, 'file_format', None, None, ),  # 4
    (5, TType.BOOL, 'is_external', None, None, ),  # 5
    (6, TType.BOOL, 'if_not_exists', None, None, ),  # 6
    (7, TType.STRING, 'owner', 'UTF8', None, ),  # 7
    (8, TType.STRUCT, 'row_format', [TTableRowFormat, None], None, ),  # 8
    (9, TType.STRING, 'comment', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'location', 'UTF8', None, ),  # 10
    (11, TType.MAP, 'table_properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 11
    (12, TType.MAP, 'serde_properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 13
    (14, TType.LIST, 'partition_by', (TType.STRUCT, [CatalogObjects.ttypes.TKuduPartitionParam, None], False), None, ),  # 14
    (15, TType.LIST, 'primary_key_column_names', (TType.STRING, 'UTF8', False), None, ),  # 15
    (16, TType.LIST, 'sort_columns', (TType.STRING, 'UTF8', False), None, ),  # 16
    (17, TType.STRING, 'server_name', 'UTF8', None, ),  # 17
    (18, TType.I32, 'sorting_order', None, None, ),  # 18
    (19, TType.LIST, 'primary_keys', (TType.STRUCT, [hive_metastore.ttypes.SQLPrimaryKey, None], False), None, ),  # 19
    (20, TType.LIST, 'foreign_keys', (TType.STRUCT, [hive_metastore.ttypes.SQLForeignKey, None], False), None, ),  # 20
)
all_structs.append(TCreateOrAlterViewParams)
TCreateOrAlterViewParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'view_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 2
    (3, TType.STRING, 'owner', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'original_view_def', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'expanded_view_def', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'comment', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'if_not_exists', None, None, ),  # 7
    (8, TType.STRING, 'server_name', 'UTF8', None, ),  # 8
)
all_structs.append(TComputeStatsParams)
TComputeStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'tbl_stats_query', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'col_stats_query', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'is_incremental', None, None, ),  # 4
    (5, TType.LIST, 'existing_part_stats', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionStats, None], False), None, ),  # 5
    (6, TType.LIST, 'expected_partitions', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 6
    (7, TType.BOOL, 'expect_all_partitions', None, None, ),  # 7
    (8, TType.I32, 'num_partition_cols', None, None, ),  # 8
    (9, TType.I64, 'total_file_bytes', None, None, ),  # 9
)
all_structs.append(TCreateDropRoleParams)
TCreateDropRoleParams.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_drop', None, None, ),  # 1
    (2, TType.STRING, 'role_name', 'UTF8', None, ),  # 2
)
all_structs.append(TGrantRevokeRoleParams)
TGrantRevokeRoleParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'role_names', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.BOOL, 'is_grant', None, None, ),  # 3
)
all_structs.append(TGrantRevokePrivParams)
TGrantRevokePrivParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT, [CatalogObjects.ttypes.TPrivilege, None], False), None, ),  # 1
    (2, TType.STRING, 'principal_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'is_grant', None, None, ),  # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ),  # 4
    (5, TType.I32, 'principal_type', None, None, ),  # 5
)
all_structs.append(TDropDbParams)
TDropDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'cascade', None, None, ),  # 3
    (4, TType.STRING, 'server_name', 'UTF8', None, ),  # 4
)
all_structs.append(TDropTableOrViewParams)
TDropTableOrViewParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'purge', None, None, ),  # 3
    (4, TType.BOOL, 'is_table', None, None, ),  # 4
    (5, TType.STRING, 'server_name', 'UTF8', None, ),  # 5
)
all_structs.append(TTruncateParams)
TTruncateParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
)
all_structs.append(TDropFunctionParams)
TDropFunctionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn_name', [Types.ttypes.TFunctionName, None], None, ),  # 1
    (2, TType.LIST, 'arg_types', (TType.STRUCT, [Types.ttypes.TColumnType, None], False), None, ),  # 2
    (3, TType.BOOL, 'if_exists', None, None, ),  # 3
    (4, TType.STRING, 'signature', 'UTF8', None, ),  # 4
)
all_structs.append(TTableUsageMetrics)
TTableUsageMetrics.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.I64, 'memory_estimate_bytes', None, None, ),  # 2
    (3, TType.I64, 'num_metadata_operations', None, None, ),  # 3
    (4, TType.I64, 'num_files', None, None, ),  # 4
    (5, TType.I64, 'median_table_loading_ns', None, None, ),  # 5
    (6, TType.I64, 'max_table_loading_ns', None, None, ),  # 6
    (7, TType.I64, 'num_table_loading', None, None, ),  # 7
    (8, TType.I64, 'p75_loading_time_ns', None, None, ),  # 8
    (9, TType.I64, 'p95_loading_time_ns', None, None, ),  # 9
    (10, TType.I64, 'p99_loading_time_ns', None, None, ),  # 10
)
all_structs.append(TGetCatalogUsageResponse)
TGetCatalogUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'large_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 1
    (2, TType.LIST, 'frequently_accessed_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 2
    (3, TType.LIST, 'high_file_count_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 3
    (4, TType.LIST, 'long_metadata_loading_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 4
)
all_structs.append(TOperationUsageCounter)
TOperationUsageCounter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'catalog_op_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.I64, 'op_counter', None, None, ),  # 3
)
all_structs.append(TGetOperationUsageResponse)
TGetOperationUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'catalog_op_counters', (TType.STRUCT, [TOperationUsageCounter, None], False), None, ),  # 1
)
all_structs.append(TColumnName)
TColumnName.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'column_name', 'UTF8', None, ),  # 2
)
all_structs.append(TCommentOnParams)
TCommentOnParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'comment', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 3
    (4, TType.STRUCT, 'column_name', [TColumnName, None], None, ),  # 4
)
all_structs.append(TEventProcessorMetrics)
TEventProcessorMetrics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'status', 'UTF8', None, ),  # 1
    (2, TType.I64, 'events_received', None, None, ),  # 2
    (3, TType.I64, 'events_skipped', None, None, ),  # 3
    (4, TType.DOUBLE, 'events_fetch_duration_mean', None, None, ),  # 4
    (5, TType.DOUBLE, 'events_process_duration_mean', None, None, ),  # 5
    (6, TType.DOUBLE, 'events_received_1min_rate', None, None, ),  # 6
    (7, TType.DOUBLE, 'events_received_5min_rate', None, None, ),  # 7
    (8, TType.DOUBLE, 'events_received_15min_rate', None, None, ),  # 8
    (9, TType.DOUBLE, 'events_skipped_per_poll_mean', None, None, ),  # 9
    (10, TType.I64, 'last_synced_event_id', None, None, ),  # 10
)
all_structs.append(TGetCatalogServerMetricsResponse)
TGetCatalogServerMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'catalog_partial_fetch_rpc_queue_len', None, None, ),  # 1
    (2, TType.STRUCT, 'event_metrics', [TEventProcessorMetrics, None], None, ),  # 2
)
all_structs.append(TCopyTestCaseReq)
TCopyTestCaseReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'input_path', 'UTF8', None, ),  # 1
)
all_structs.append(TEventProcessorMetricsSummaryResponse)
TEventProcessorMetricsSummaryResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'summary', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
