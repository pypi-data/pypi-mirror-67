#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import CatalogObjects.ttypes
import ExecStats.ttypes
import Exprs.ttypes
import Types.ttypes
import ExternalDataSource.ttypes
import ResourceProfile.ttypes

from thrift.transport import TTransport
all_structs = []


class TPlanNodeType(object):
    HDFS_SCAN_NODE = 0
    HBASE_SCAN_NODE = 1
    HASH_JOIN_NODE = 2
    AGGREGATION_NODE = 3
    SORT_NODE = 4
    EMPTY_SET_NODE = 5
    EXCHANGE_NODE = 6
    UNION_NODE = 7
    SELECT_NODE = 8
    NESTED_LOOP_JOIN_NODE = 9
    DATA_SOURCE_NODE = 10
    ANALYTIC_EVAL_NODE = 11
    SINGULAR_ROW_SRC_NODE = 12
    UNNEST_NODE = 13
    SUBPLAN_NODE = 14
    KUDU_SCAN_NODE = 15
    CARDINALITY_CHECK_NODE = 16
    MULTI_AGGREGATION_NODE = 17

    _VALUES_TO_NAMES = {
        0: "HDFS_SCAN_NODE",
        1: "HBASE_SCAN_NODE",
        2: "HASH_JOIN_NODE",
        3: "AGGREGATION_NODE",
        4: "SORT_NODE",
        5: "EMPTY_SET_NODE",
        6: "EXCHANGE_NODE",
        7: "UNION_NODE",
        8: "SELECT_NODE",
        9: "NESTED_LOOP_JOIN_NODE",
        10: "DATA_SOURCE_NODE",
        11: "ANALYTIC_EVAL_NODE",
        12: "SINGULAR_ROW_SRC_NODE",
        13: "UNNEST_NODE",
        14: "SUBPLAN_NODE",
        15: "KUDU_SCAN_NODE",
        16: "CARDINALITY_CHECK_NODE",
        17: "MULTI_AGGREGATION_NODE",
    }

    _NAMES_TO_VALUES = {
        "HDFS_SCAN_NODE": 0,
        "HBASE_SCAN_NODE": 1,
        "HASH_JOIN_NODE": 2,
        "AGGREGATION_NODE": 3,
        "SORT_NODE": 4,
        "EMPTY_SET_NODE": 5,
        "EXCHANGE_NODE": 6,
        "UNION_NODE": 7,
        "SELECT_NODE": 8,
        "NESTED_LOOP_JOIN_NODE": 9,
        "DATA_SOURCE_NODE": 10,
        "ANALYTIC_EVAL_NODE": 11,
        "SINGULAR_ROW_SRC_NODE": 12,
        "UNNEST_NODE": 13,
        "SUBPLAN_NODE": 14,
        "KUDU_SCAN_NODE": 15,
        "CARDINALITY_CHECK_NODE": 16,
        "MULTI_AGGREGATION_NODE": 17,
    }


class TExecNodePhase(object):
    PREPARE = 0
    PREPARE_SCANNER = 1
    OPEN = 2
    GETNEXT = 3
    GETNEXT_SCANNER = 4
    CLOSE = 5
    SCANNER_ERROR = 6
    INVALID = 7

    _VALUES_TO_NAMES = {
        0: "PREPARE",
        1: "PREPARE_SCANNER",
        2: "OPEN",
        3: "GETNEXT",
        4: "GETNEXT_SCANNER",
        5: "CLOSE",
        6: "SCANNER_ERROR",
        7: "INVALID",
    }

    _NAMES_TO_VALUES = {
        "PREPARE": 0,
        "PREPARE_SCANNER": 1,
        "OPEN": 2,
        "GETNEXT": 3,
        "GETNEXT_SCANNER": 4,
        "CLOSE": 5,
        "SCANNER_ERROR": 6,
        "INVALID": 7,
    }


class TDebugAction(object):
    WAIT = 0
    FAIL = 1
    INJECT_ERROR_LOG = 2
    MEM_LIMIT_EXCEEDED = 3
    SET_DENY_RESERVATION_PROBABILITY = 4
    DELAY = 5

    _VALUES_TO_NAMES = {
        0: "WAIT",
        1: "FAIL",
        2: "INJECT_ERROR_LOG",
        3: "MEM_LIMIT_EXCEEDED",
        4: "SET_DENY_RESERVATION_PROBABILITY",
        5: "DELAY",
    }

    _NAMES_TO_VALUES = {
        "WAIT": 0,
        "FAIL": 1,
        "INJECT_ERROR_LOG": 2,
        "MEM_LIMIT_EXCEEDED": 3,
        "SET_DENY_RESERVATION_PROBABILITY": 4,
        "DELAY": 5,
    }


class TReplicaPreference(object):
    CACHE_LOCAL = 0
    CACHE_RACK = 1
    DISK_LOCAL = 2
    DISK_RACK = 3
    REMOTE = 4

    _VALUES_TO_NAMES = {
        0: "CACHE_LOCAL",
        1: "CACHE_RACK",
        2: "DISK_LOCAL",
        3: "DISK_RACK",
        4: "REMOTE",
    }

    _NAMES_TO_VALUES = {
        "CACHE_LOCAL": 0,
        "CACHE_RACK": 1,
        "DISK_LOCAL": 2,
        "DISK_RACK": 3,
        "REMOTE": 4,
    }


class TRuntimeFilterType(object):
    BLOOM = 0
    MIN_MAX = 1

    _VALUES_TO_NAMES = {
        0: "BLOOM",
        1: "MIN_MAX",
    }

    _NAMES_TO_VALUES = {
        "BLOOM": 0,
        "MIN_MAX": 1,
    }


class TJoinOp(object):
    INNER_JOIN = 0
    LEFT_OUTER_JOIN = 1
    LEFT_SEMI_JOIN = 2
    LEFT_ANTI_JOIN = 3
    NULL_AWARE_LEFT_ANTI_JOIN = 4
    RIGHT_OUTER_JOIN = 5
    RIGHT_SEMI_JOIN = 6
    RIGHT_ANTI_JOIN = 7
    FULL_OUTER_JOIN = 8
    CROSS_JOIN = 9

    _VALUES_TO_NAMES = {
        0: "INNER_JOIN",
        1: "LEFT_OUTER_JOIN",
        2: "LEFT_SEMI_JOIN",
        3: "LEFT_ANTI_JOIN",
        4: "NULL_AWARE_LEFT_ANTI_JOIN",
        5: "RIGHT_OUTER_JOIN",
        6: "RIGHT_SEMI_JOIN",
        7: "RIGHT_ANTI_JOIN",
        8: "FULL_OUTER_JOIN",
        9: "CROSS_JOIN",
    }

    _NAMES_TO_VALUES = {
        "INNER_JOIN": 0,
        "LEFT_OUTER_JOIN": 1,
        "LEFT_SEMI_JOIN": 2,
        "LEFT_ANTI_JOIN": 3,
        "NULL_AWARE_LEFT_ANTI_JOIN": 4,
        "RIGHT_OUTER_JOIN": 5,
        "RIGHT_SEMI_JOIN": 6,
        "RIGHT_ANTI_JOIN": 7,
        "FULL_OUTER_JOIN": 8,
        "CROSS_JOIN": 9,
    }


class TSortType(object):
    TOTAL = 0
    TOPN = 1
    PARTIAL = 2

    _VALUES_TO_NAMES = {
        0: "TOTAL",
        1: "TOPN",
        2: "PARTIAL",
    }

    _NAMES_TO_VALUES = {
        "TOTAL": 0,
        "TOPN": 1,
        "PARTIAL": 2,
    }


class TAnalyticWindowType(object):
    RANGE = 0
    ROWS = 1

    _VALUES_TO_NAMES = {
        0: "RANGE",
        1: "ROWS",
    }

    _NAMES_TO_VALUES = {
        "RANGE": 0,
        "ROWS": 1,
    }


class TAnalyticWindowBoundaryType(object):
    CURRENT_ROW = 0
    PRECEDING = 1
    FOLLOWING = 2

    _VALUES_TO_NAMES = {
        0: "CURRENT_ROW",
        1: "PRECEDING",
        2: "FOLLOWING",
    }

    _NAMES_TO_VALUES = {
        "CURRENT_ROW": 0,
        "PRECEDING": 1,
        "FOLLOWING": 2,
    }


class TRuntimeFilterTargetDesc(object):
    """
    Attributes:
     - node_id
     - target_expr
     - is_bound_by_partition_columns
     - target_expr_slotids
     - is_local_target
     - kudu_col_name
     - kudu_col_type
    """


    def __init__(self, node_id=None, target_expr=None, is_bound_by_partition_columns=None, target_expr_slotids=None, is_local_target=None, kudu_col_name=None, kudu_col_type=None,):
        self.node_id = node_id
        self.target_expr = target_expr
        self.is_bound_by_partition_columns = is_bound_by_partition_columns
        self.target_expr_slotids = target_expr_slotids
        self.is_local_target = is_local_target
        self.kudu_col_name = kudu_col_name
        self.kudu_col_type = kudu_col_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.target_expr = Exprs.ttypes.TExpr()
                    self.target_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_bound_by_partition_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.target_expr_slotids = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.target_expr_slotids.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_local_target = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.kudu_col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.kudu_col_type = Types.ttypes.TColumnType()
                    self.kudu_col_type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterTargetDesc')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.target_expr is not None:
            oprot.writeFieldBegin('target_expr', TType.STRUCT, 2)
            self.target_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.is_bound_by_partition_columns is not None:
            oprot.writeFieldBegin('is_bound_by_partition_columns', TType.BOOL, 3)
            oprot.writeBool(self.is_bound_by_partition_columns)
            oprot.writeFieldEnd()
        if self.target_expr_slotids is not None:
            oprot.writeFieldBegin('target_expr_slotids', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.target_expr_slotids))
            for iter6 in self.target_expr_slotids:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_local_target is not None:
            oprot.writeFieldBegin('is_local_target', TType.BOOL, 5)
            oprot.writeBool(self.is_local_target)
            oprot.writeFieldEnd()
        if self.kudu_col_name is not None:
            oprot.writeFieldBegin('kudu_col_name', TType.STRING, 6)
            oprot.writeString(self.kudu_col_name.encode('utf-8') if sys.version_info[0] == 2 else self.kudu_col_name)
            oprot.writeFieldEnd()
        if self.kudu_col_type is not None:
            oprot.writeFieldBegin('kudu_col_type', TType.STRUCT, 7)
            self.kudu_col_type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target_expr is None:
            raise TProtocolException(message='Required field target_expr is unset!')
        if self.is_bound_by_partition_columns is None:
            raise TProtocolException(message='Required field is_bound_by_partition_columns is unset!')
        if self.target_expr_slotids is None:
            raise TProtocolException(message='Required field target_expr_slotids is unset!')
        if self.is_local_target is None:
            raise TProtocolException(message='Required field is_local_target is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeFilterDesc(object):
    """
    Attributes:
     - filter_id
     - src_expr
     - targets
     - planid_to_target_ndx
     - is_broadcast_join
     - has_local_targets
     - has_remote_targets
     - applied_on_partition_columns
     - ndv_estimate
     - type
     - filter_size_bytes
     - src_node_id
    """


    def __init__(self, filter_id=None, src_expr=None, targets=None, planid_to_target_ndx=None, is_broadcast_join=None, has_local_targets=None, has_remote_targets=None, applied_on_partition_columns=None, ndv_estimate=None, type=None, filter_size_bytes=None, src_node_id=None,):
        self.filter_id = filter_id
        self.src_expr = src_expr
        self.targets = targets
        self.planid_to_target_ndx = planid_to_target_ndx
        self.is_broadcast_join = is_broadcast_join
        self.has_local_targets = has_local_targets
        self.has_remote_targets = has_remote_targets
        self.applied_on_partition_columns = applied_on_partition_columns
        self.ndv_estimate = ndv_estimate
        self.type = type
        self.filter_size_bytes = filter_size_bytes
        self.src_node_id = src_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.filter_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.src_expr = Exprs.ttypes.TExpr()
                    self.src_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.targets = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TRuntimeFilterTargetDesc()
                        _elem12.read(iprot)
                        self.targets.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.planid_to_target_ndx = {}
                    (_ktype14, _vtype15, _size13) = iprot.readMapBegin()
                    for _i17 in range(_size13):
                        _key18 = iprot.readI32()
                        _val19 = iprot.readI32()
                        self.planid_to_target_ndx[_key18] = _val19
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_broadcast_join = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_local_targets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.has_remote_targets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.applied_on_partition_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.ndv_estimate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.filter_size_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterDesc')
        if self.filter_id is not None:
            oprot.writeFieldBegin('filter_id', TType.I32, 1)
            oprot.writeI32(self.filter_id)
            oprot.writeFieldEnd()
        if self.src_expr is not None:
            oprot.writeFieldBegin('src_expr', TType.STRUCT, 2)
            self.src_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.targets))
            for iter20 in self.targets:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.planid_to_target_ndx is not None:
            oprot.writeFieldBegin('planid_to_target_ndx', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.planid_to_target_ndx))
            for kiter21, viter22 in self.planid_to_target_ndx.items():
                oprot.writeI32(kiter21)
                oprot.writeI32(viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.is_broadcast_join is not None:
            oprot.writeFieldBegin('is_broadcast_join', TType.BOOL, 5)
            oprot.writeBool(self.is_broadcast_join)
            oprot.writeFieldEnd()
        if self.has_local_targets is not None:
            oprot.writeFieldBegin('has_local_targets', TType.BOOL, 6)
            oprot.writeBool(self.has_local_targets)
            oprot.writeFieldEnd()
        if self.has_remote_targets is not None:
            oprot.writeFieldBegin('has_remote_targets', TType.BOOL, 7)
            oprot.writeBool(self.has_remote_targets)
            oprot.writeFieldEnd()
        if self.applied_on_partition_columns is not None:
            oprot.writeFieldBegin('applied_on_partition_columns', TType.BOOL, 8)
            oprot.writeBool(self.applied_on_partition_columns)
            oprot.writeFieldEnd()
        if self.ndv_estimate is not None:
            oprot.writeFieldBegin('ndv_estimate', TType.I64, 9)
            oprot.writeI64(self.ndv_estimate)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 10)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.filter_size_bytes is not None:
            oprot.writeFieldBegin('filter_size_bytes', TType.I64, 11)
            oprot.writeI64(self.filter_size_bytes)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 12)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.filter_id is None:
            raise TProtocolException(message='Required field filter_id is unset!')
        if self.src_expr is None:
            raise TProtocolException(message='Required field src_expr is unset!')
        if self.targets is None:
            raise TProtocolException(message='Required field targets is unset!')
        if self.planid_to_target_ndx is None:
            raise TProtocolException(message='Required field planid_to_target_ndx is unset!')
        if self.is_broadcast_join is None:
            raise TProtocolException(message='Required field is_broadcast_join is unset!')
        if self.has_local_targets is None:
            raise TProtocolException(message='Required field has_local_targets is unset!')
        if self.has_remote_targets is None:
            raise TProtocolException(message='Required field has_remote_targets is unset!')
        if self.applied_on_partition_columns is None:
            raise TProtocolException(message='Required field applied_on_partition_columns is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsFileSplit(object):
    """
    Attributes:
     - relative_path
     - offset
     - length
     - partition_id
     - file_length
     - file_compression
     - mtime
     - is_erasure_coded
     - partition_path_hash
    """


    def __init__(self, relative_path=None, offset=None, length=None, partition_id=None, file_length=None, file_compression=None, mtime=None, is_erasure_coded=None, partition_path_hash=None,):
        self.relative_path = relative_path
        self.offset = offset
        self.length = length
        self.partition_id = partition_id
        self.file_length = file_length
        self.file_compression = file_compression
        self.mtime = mtime
        self.is_erasure_coded = is_erasure_coded
        self.partition_path_hash = partition_path_hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.relative_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.partition_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.file_length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.file_compression = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.mtime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.is_erasure_coded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.partition_path_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsFileSplit')
        if self.relative_path is not None:
            oprot.writeFieldBegin('relative_path', TType.STRING, 1)
            oprot.writeString(self.relative_path.encode('utf-8') if sys.version_info[0] == 2 else self.relative_path)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I64, 3)
            oprot.writeI64(self.length)
            oprot.writeFieldEnd()
        if self.partition_id is not None:
            oprot.writeFieldBegin('partition_id', TType.I64, 4)
            oprot.writeI64(self.partition_id)
            oprot.writeFieldEnd()
        if self.file_length is not None:
            oprot.writeFieldBegin('file_length', TType.I64, 5)
            oprot.writeI64(self.file_length)
            oprot.writeFieldEnd()
        if self.file_compression is not None:
            oprot.writeFieldBegin('file_compression', TType.I32, 6)
            oprot.writeI32(self.file_compression)
            oprot.writeFieldEnd()
        if self.mtime is not None:
            oprot.writeFieldBegin('mtime', TType.I64, 7)
            oprot.writeI64(self.mtime)
            oprot.writeFieldEnd()
        if self.is_erasure_coded is not None:
            oprot.writeFieldBegin('is_erasure_coded', TType.BOOL, 8)
            oprot.writeBool(self.is_erasure_coded)
            oprot.writeFieldEnd()
        if self.partition_path_hash is not None:
            oprot.writeFieldBegin('partition_path_hash', TType.I32, 9)
            oprot.writeI32(self.partition_path_hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.relative_path is None:
            raise TProtocolException(message='Required field relative_path is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.length is None:
            raise TProtocolException(message='Required field length is unset!')
        if self.partition_id is None:
            raise TProtocolException(message='Required field partition_id is unset!')
        if self.file_length is None:
            raise TProtocolException(message='Required field file_length is unset!')
        if self.file_compression is None:
            raise TProtocolException(message='Required field file_compression is unset!')
        if self.mtime is None:
            raise TProtocolException(message='Required field mtime is unset!')
        if self.is_erasure_coded is None:
            raise TProtocolException(message='Required field is_erasure_coded is unset!')
        if self.partition_path_hash is None:
            raise TProtocolException(message='Required field partition_path_hash is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseKeyRange(object):
    """
    Attributes:
     - startKey
     - stopKey
    """


    def __init__(self, startKey=None, stopKey=None,):
        self.startKey = startKey
        self.stopKey = stopKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.startKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stopKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseKeyRange')
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.STRING, 1)
            oprot.writeString(self.startKey.encode('utf-8') if sys.version_info[0] == 2 else self.startKey)
            oprot.writeFieldEnd()
        if self.stopKey is not None:
            oprot.writeFieldBegin('stopKey', TType.STRING, 2)
            oprot.writeString(self.stopKey.encode('utf-8') if sys.version_info[0] == 2 else self.stopKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFileSplitGeneratorSpec(object):
    """
    Attributes:
     - file_desc
     - max_block_size
     - is_splittable
     - partition_id
     - partition_path_hash
    """


    def __init__(self, file_desc=None, max_block_size=None, is_splittable=None, partition_id=None, partition_path_hash=None,):
        self.file_desc = file_desc
        self.max_block_size = max_block_size
        self.is_splittable = is_splittable
        self.partition_id = partition_id
        self.partition_path_hash = partition_path_hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.file_desc = CatalogObjects.ttypes.THdfsFileDesc()
                    self.file_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_block_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_splittable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.partition_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.partition_path_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFileSplitGeneratorSpec')
        if self.file_desc is not None:
            oprot.writeFieldBegin('file_desc', TType.STRUCT, 1)
            self.file_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.max_block_size is not None:
            oprot.writeFieldBegin('max_block_size', TType.I64, 2)
            oprot.writeI64(self.max_block_size)
            oprot.writeFieldEnd()
        if self.is_splittable is not None:
            oprot.writeFieldBegin('is_splittable', TType.BOOL, 3)
            oprot.writeBool(self.is_splittable)
            oprot.writeFieldEnd()
        if self.partition_id is not None:
            oprot.writeFieldBegin('partition_id', TType.I64, 4)
            oprot.writeI64(self.partition_id)
            oprot.writeFieldEnd()
        if self.partition_path_hash is not None:
            oprot.writeFieldBegin('partition_path_hash', TType.I32, 5)
            oprot.writeI32(self.partition_path_hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_desc is None:
            raise TProtocolException(message='Required field file_desc is unset!')
        if self.max_block_size is None:
            raise TProtocolException(message='Required field max_block_size is unset!')
        if self.is_splittable is None:
            raise TProtocolException(message='Required field is_splittable is unset!')
        if self.partition_id is None:
            raise TProtocolException(message='Required field partition_id is unset!')
        if self.partition_path_hash is None:
            raise TProtocolException(message='Required field partition_path_hash is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TScanRange(object):
    """
    Attributes:
     - hdfs_file_split
     - hbase_key_range
     - kudu_scan_token
    """


    def __init__(self, hdfs_file_split=None, hbase_key_range=None, kudu_scan_token=None,):
        self.hdfs_file_split = hdfs_file_split
        self.hbase_key_range = hbase_key_range
        self.kudu_scan_token = kudu_scan_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hdfs_file_split = THdfsFileSplit()
                    self.hdfs_file_split.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.hbase_key_range = THBaseKeyRange()
                    self.hbase_key_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.kudu_scan_token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TScanRange')
        if self.hdfs_file_split is not None:
            oprot.writeFieldBegin('hdfs_file_split', TType.STRUCT, 1)
            self.hdfs_file_split.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_key_range is not None:
            oprot.writeFieldBegin('hbase_key_range', TType.STRUCT, 2)
            self.hbase_key_range.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_scan_token is not None:
            oprot.writeFieldBegin('kudu_scan_token', TType.STRING, 3)
            oprot.writeBinary(self.kudu_scan_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsScanNode(object):
    """
    Attributes:
     - tuple_id
     - collection_conjuncts
     - replica_preference
     - random_replica
     - skip_header_line_count
     - use_mt_scan_node
     - min_max_conjuncts
     - min_max_tuple_id
     - dictionary_filter_conjuncts
     - parquet_count_star_slot_offset
    """


    def __init__(self, tuple_id=None, collection_conjuncts=None, replica_preference=None, random_replica=None, skip_header_line_count=None, use_mt_scan_node=None, min_max_conjuncts=None, min_max_tuple_id=None, dictionary_filter_conjuncts=None, parquet_count_star_slot_offset=None,):
        self.tuple_id = tuple_id
        self.collection_conjuncts = collection_conjuncts
        self.replica_preference = replica_preference
        self.random_replica = random_replica
        self.skip_header_line_count = skip_header_line_count
        self.use_mt_scan_node = use_mt_scan_node
        self.min_max_conjuncts = min_max_conjuncts
        self.min_max_tuple_id = min_max_tuple_id
        self.dictionary_filter_conjuncts = dictionary_filter_conjuncts
        self.parquet_count_star_slot_offset = parquet_count_star_slot_offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.collection_conjuncts = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readI32()
                        _val29 = []
                        (_etype33, _size30) = iprot.readListBegin()
                        for _i34 in range(_size30):
                            _elem35 = Exprs.ttypes.TExpr()
                            _elem35.read(iprot)
                            _val29.append(_elem35)
                        iprot.readListEnd()
                        self.collection_conjuncts[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.replica_preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.random_replica = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.skip_header_line_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.use_mt_scan_node = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.min_max_conjuncts = []
                    (_etype39, _size36) = iprot.readListBegin()
                    for _i40 in range(_size36):
                        _elem41 = Exprs.ttypes.TExpr()
                        _elem41.read(iprot)
                        self.min_max_conjuncts.append(_elem41)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.min_max_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.dictionary_filter_conjuncts = {}
                    (_ktype43, _vtype44, _size42) = iprot.readMapBegin()
                    for _i46 in range(_size42):
                        _key47 = iprot.readI32()
                        _val48 = []
                        (_etype52, _size49) = iprot.readListBegin()
                        for _i53 in range(_size49):
                            _elem54 = iprot.readI32()
                            _val48.append(_elem54)
                        iprot.readListEnd()
                        self.dictionary_filter_conjuncts[_key47] = _val48
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.parquet_count_star_slot_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.collection_conjuncts is not None:
            oprot.writeFieldBegin('collection_conjuncts', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.collection_conjuncts))
            for kiter55, viter56 in self.collection_conjuncts.items():
                oprot.writeI32(kiter55)
                oprot.writeListBegin(TType.STRUCT, len(viter56))
                for iter57 in viter56:
                    iter57.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.replica_preference is not None:
            oprot.writeFieldBegin('replica_preference', TType.I32, 3)
            oprot.writeI32(self.replica_preference)
            oprot.writeFieldEnd()
        if self.random_replica is not None:
            oprot.writeFieldBegin('random_replica', TType.BOOL, 4)
            oprot.writeBool(self.random_replica)
            oprot.writeFieldEnd()
        if self.skip_header_line_count is not None:
            oprot.writeFieldBegin('skip_header_line_count', TType.I32, 5)
            oprot.writeI32(self.skip_header_line_count)
            oprot.writeFieldEnd()
        if self.use_mt_scan_node is not None:
            oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 6)
            oprot.writeBool(self.use_mt_scan_node)
            oprot.writeFieldEnd()
        if self.min_max_conjuncts is not None:
            oprot.writeFieldBegin('min_max_conjuncts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.min_max_conjuncts))
            for iter58 in self.min_max_conjuncts:
                iter58.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.min_max_tuple_id is not None:
            oprot.writeFieldBegin('min_max_tuple_id', TType.I32, 8)
            oprot.writeI32(self.min_max_tuple_id)
            oprot.writeFieldEnd()
        if self.dictionary_filter_conjuncts is not None:
            oprot.writeFieldBegin('dictionary_filter_conjuncts', TType.MAP, 9)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.dictionary_filter_conjuncts))
            for kiter59, viter60 in self.dictionary_filter_conjuncts.items():
                oprot.writeI32(kiter59)
                oprot.writeListBegin(TType.I32, len(viter60))
                for iter61 in viter60:
                    oprot.writeI32(iter61)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.parquet_count_star_slot_offset is not None:
            oprot.writeFieldBegin('parquet_count_star_slot_offset', TType.I32, 10)
            oprot.writeI32(self.parquet_count_star_slot_offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSourceScanNode(object):
    """
    Attributes:
     - tuple_id
     - data_source
     - init_string
     - accepted_predicates
    """


    def __init__(self, tuple_id=None, data_source=None, init_string=None, accepted_predicates=None,):
        self.tuple_id = tuple_id
        self.data_source = data_source
        self.init_string = init_string
        self.accepted_predicates = accepted_predicates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.data_source = CatalogObjects.ttypes.TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.init_string = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.accepted_predicates = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = []
                        (_etype71, _size68) = iprot.readListBegin()
                        for _i72 in range(_size68):
                            _elem73 = ExternalDataSource.ttypes.TBinaryPredicate()
                            _elem73.read(iprot)
                            _elem67.append(_elem73)
                        iprot.readListEnd()
                        self.accepted_predicates.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSourceScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 2)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.init_string is not None:
            oprot.writeFieldBegin('init_string', TType.STRING, 3)
            oprot.writeString(self.init_string.encode('utf-8') if sys.version_info[0] == 2 else self.init_string)
            oprot.writeFieldEnd()
        if self.accepted_predicates is not None:
            oprot.writeFieldBegin('accepted_predicates', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.accepted_predicates))
            for iter74 in self.accepted_predicates:
                oprot.writeListBegin(TType.STRUCT, len(iter74))
                for iter75 in iter74:
                    iter75.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        if self.init_string is None:
            raise TProtocolException(message='Required field init_string is unset!')
        if self.accepted_predicates is None:
            raise TProtocolException(message='Required field accepted_predicates is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseFilter(object):
    """
    Attributes:
     - family
     - qualifier
     - op_ordinal
     - filter_constant
    """


    def __init__(self, family=None, qualifier=None, op_ordinal=None, filter_constant=None,):
        self.family = family
        self.qualifier = qualifier
        self.op_ordinal = op_ordinal
        self.filter_constant = filter_constant

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.family = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.op_ordinal = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filter_constant = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseFilter')
        if self.family is not None:
            oprot.writeFieldBegin('family', TType.STRING, 1)
            oprot.writeString(self.family.encode('utf-8') if sys.version_info[0] == 2 else self.family)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeString(self.qualifier.encode('utf-8') if sys.version_info[0] == 2 else self.qualifier)
            oprot.writeFieldEnd()
        if self.op_ordinal is not None:
            oprot.writeFieldBegin('op_ordinal', TType.I32, 3)
            oprot.writeI32(self.op_ordinal)
            oprot.writeFieldEnd()
        if self.filter_constant is not None:
            oprot.writeFieldBegin('filter_constant', TType.STRING, 4)
            oprot.writeString(self.filter_constant.encode('utf-8') if sys.version_info[0] == 2 else self.filter_constant)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.family is None:
            raise TProtocolException(message='Required field family is unset!')
        if self.op_ordinal is None:
            raise TProtocolException(message='Required field op_ordinal is unset!')
        if self.filter_constant is None:
            raise TProtocolException(message='Required field filter_constant is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseScanNode(object):
    """
    Attributes:
     - tuple_id
     - table_name
     - filters
     - suggested_max_caching
    """


    def __init__(self, tuple_id=None, table_name=None, filters=None, suggested_max_caching=None,):
        self.tuple_id = tuple_id
        self.table_name = table_name
        self.filters = filters
        self.suggested_max_caching = suggested_max_caching

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.filters = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = THBaseFilter()
                        _elem81.read(iprot)
                        self.filters.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.suggested_max_caching = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.filters is not None:
            oprot.writeFieldBegin('filters', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.filters))
            for iter82 in self.filters:
                iter82.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.suggested_max_caching is not None:
            oprot.writeFieldBegin('suggested_max_caching', TType.I32, 4)
            oprot.writeI32(self.suggested_max_caching)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduScanNode(object):
    """
    Attributes:
     - tuple_id
     - use_mt_scan_node
     - count_star_slot_offset
    """


    def __init__(self, tuple_id=None, use_mt_scan_node=None, count_star_slot_offset=None,):
        self.tuple_id = tuple_id
        self.use_mt_scan_node = use_mt_scan_node
        self.count_star_slot_offset = count_star_slot_offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.use_mt_scan_node = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count_star_slot_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.use_mt_scan_node is not None:
            oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 2)
            oprot.writeBool(self.use_mt_scan_node)
            oprot.writeFieldEnd()
        if self.count_star_slot_offset is not None:
            oprot.writeFieldBegin('count_star_slot_offset', TType.I32, 3)
            oprot.writeI32(self.count_star_slot_offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEqJoinCondition(object):
    """
    Attributes:
     - left
     - right
     - is_not_distinct_from
    """


    def __init__(self, left=None, right=None, is_not_distinct_from=None,):
        self.left = left
        self.right = right
        self.is_not_distinct_from = is_not_distinct_from

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.left = Exprs.ttypes.TExpr()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.right = Exprs.ttypes.TExpr()
                    self.right.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_not_distinct_from = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEqJoinCondition')
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 1)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.STRUCT, 2)
            self.right.write(oprot)
            oprot.writeFieldEnd()
        if self.is_not_distinct_from is not None:
            oprot.writeFieldBegin('is_not_distinct_from', TType.BOOL, 3)
            oprot.writeBool(self.is_not_distinct_from)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.left is None:
            raise TProtocolException(message='Required field left is unset!')
        if self.right is None:
            raise TProtocolException(message='Required field right is unset!')
        if self.is_not_distinct_from is None:
            raise TProtocolException(message='Required field is_not_distinct_from is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THashJoinNode(object):
    """
    Attributes:
     - eq_join_conjuncts
     - other_join_conjuncts
     - hash_seed
    """


    def __init__(self, eq_join_conjuncts=None, other_join_conjuncts=None, hash_seed=None,):
        self.eq_join_conjuncts = eq_join_conjuncts
        self.other_join_conjuncts = other_join_conjuncts
        self.hash_seed = hash_seed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.eq_join_conjuncts = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = TEqJoinCondition()
                        _elem88.read(iprot)
                        self.eq_join_conjuncts.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.other_join_conjuncts = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = Exprs.ttypes.TExpr()
                        _elem94.read(iprot)
                        self.other_join_conjuncts.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.hash_seed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THashJoinNode')
        if self.eq_join_conjuncts is not None:
            oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
            for iter95 in self.eq_join_conjuncts:
                iter95.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.other_join_conjuncts is not None:
            oprot.writeFieldBegin('other_join_conjuncts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.other_join_conjuncts))
            for iter96 in self.other_join_conjuncts:
                iter96.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hash_seed is not None:
            oprot.writeFieldBegin('hash_seed', TType.I32, 3)
            oprot.writeI32(self.hash_seed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.eq_join_conjuncts is None:
            raise TProtocolException(message='Required field eq_join_conjuncts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNestedLoopJoinNode(object):
    """
    Attributes:
     - join_conjuncts
    """


    def __init__(self, join_conjuncts=None,):
        self.join_conjuncts = join_conjuncts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.join_conjuncts = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = Exprs.ttypes.TExpr()
                        _elem102.read(iprot)
                        self.join_conjuncts.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNestedLoopJoinNode')
        if self.join_conjuncts is not None:
            oprot.writeFieldBegin('join_conjuncts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.join_conjuncts))
            for iter103 in self.join_conjuncts:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJoinNode(object):
    """
    Attributes:
     - join_op
     - build_tuples
     - nullable_build_tuples
     - hash_join_node
     - nested_loop_join_node
    """


    def __init__(self, join_op=None, build_tuples=None, nullable_build_tuples=None, hash_join_node=None, nested_loop_join_node=None,):
        self.join_op = join_op
        self.build_tuples = build_tuples
        self.nullable_build_tuples = nullable_build_tuples
        self.hash_join_node = hash_join_node
        self.nested_loop_join_node = nested_loop_join_node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.join_op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.build_tuples = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iprot.readI32()
                        self.build_tuples.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nullable_build_tuples = []
                    (_etype113, _size110) = iprot.readListBegin()
                    for _i114 in range(_size110):
                        _elem115 = iprot.readBool()
                        self.nullable_build_tuples.append(_elem115)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.hash_join_node = THashJoinNode()
                    self.hash_join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.nested_loop_join_node = TNestedLoopJoinNode()
                    self.nested_loop_join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJoinNode')
        if self.join_op is not None:
            oprot.writeFieldBegin('join_op', TType.I32, 1)
            oprot.writeI32(self.join_op)
            oprot.writeFieldEnd()
        if self.build_tuples is not None:
            oprot.writeFieldBegin('build_tuples', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.build_tuples))
            for iter116 in self.build_tuples:
                oprot.writeI32(iter116)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullable_build_tuples is not None:
            oprot.writeFieldBegin('nullable_build_tuples', TType.LIST, 3)
            oprot.writeListBegin(TType.BOOL, len(self.nullable_build_tuples))
            for iter117 in self.nullable_build_tuples:
                oprot.writeBool(iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hash_join_node is not None:
            oprot.writeFieldBegin('hash_join_node', TType.STRUCT, 4)
            self.hash_join_node.write(oprot)
            oprot.writeFieldEnd()
        if self.nested_loop_join_node is not None:
            oprot.writeFieldBegin('nested_loop_join_node', TType.STRUCT, 5)
            self.nested_loop_join_node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.join_op is None:
            raise TProtocolException(message='Required field join_op is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAggregator(object):
    """
    Attributes:
     - grouping_exprs
     - aggregate_functions
     - intermediate_tuple_id
     - output_tuple_id
     - need_finalize
     - use_streaming_preaggregation
     - resource_profile
    """


    def __init__(self, grouping_exprs=None, aggregate_functions=None, intermediate_tuple_id=None, output_tuple_id=None, need_finalize=None, use_streaming_preaggregation=None, resource_profile=None,):
        self.grouping_exprs = grouping_exprs
        self.aggregate_functions = aggregate_functions
        self.intermediate_tuple_id = intermediate_tuple_id
        self.output_tuple_id = output_tuple_id
        self.need_finalize = need_finalize
        self.use_streaming_preaggregation = use_streaming_preaggregation
        self.resource_profile = resource_profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.grouping_exprs = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = Exprs.ttypes.TExpr()
                        _elem123.read(iprot)
                        self.grouping_exprs.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.aggregate_functions = []
                    (_etype127, _size124) = iprot.readListBegin()
                    for _i128 in range(_size124):
                        _elem129 = Exprs.ttypes.TExpr()
                        _elem129.read(iprot)
                        self.aggregate_functions.append(_elem129)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.intermediate_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.output_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_finalize = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.use_streaming_preaggregation = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAggregator')
        if self.grouping_exprs is not None:
            oprot.writeFieldBegin('grouping_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.grouping_exprs))
            for iter130 in self.grouping_exprs:
                iter130.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregate_functions is not None:
            oprot.writeFieldBegin('aggregate_functions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregate_functions))
            for iter131 in self.aggregate_functions:
                iter131.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.intermediate_tuple_id is not None:
            oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 3)
            oprot.writeI32(self.intermediate_tuple_id)
            oprot.writeFieldEnd()
        if self.output_tuple_id is not None:
            oprot.writeFieldBegin('output_tuple_id', TType.I32, 4)
            oprot.writeI32(self.output_tuple_id)
            oprot.writeFieldEnd()
        if self.need_finalize is not None:
            oprot.writeFieldBegin('need_finalize', TType.BOOL, 5)
            oprot.writeBool(self.need_finalize)
            oprot.writeFieldEnd()
        if self.use_streaming_preaggregation is not None:
            oprot.writeFieldBegin('use_streaming_preaggregation', TType.BOOL, 6)
            oprot.writeBool(self.use_streaming_preaggregation)
            oprot.writeFieldEnd()
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 7)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aggregate_functions is None:
            raise TProtocolException(message='Required field aggregate_functions is unset!')
        if self.intermediate_tuple_id is None:
            raise TProtocolException(message='Required field intermediate_tuple_id is unset!')
        if self.output_tuple_id is None:
            raise TProtocolException(message='Required field output_tuple_id is unset!')
        if self.need_finalize is None:
            raise TProtocolException(message='Required field need_finalize is unset!')
        if self.use_streaming_preaggregation is None:
            raise TProtocolException(message='Required field use_streaming_preaggregation is unset!')
        if self.resource_profile is None:
            raise TProtocolException(message='Required field resource_profile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAggregationNode(object):
    """
    Attributes:
     - aggregators
     - estimated_input_cardinality
     - replicate_input
    """


    def __init__(self, aggregators=None, estimated_input_cardinality=None, replicate_input=None,):
        self.aggregators = aggregators
        self.estimated_input_cardinality = estimated_input_cardinality
        self.replicate_input = replicate_input

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.aggregators = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = TAggregator()
                        _elem137.read(iprot)
                        self.aggregators.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.estimated_input_cardinality = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.replicate_input = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAggregationNode')
        if self.aggregators is not None:
            oprot.writeFieldBegin('aggregators', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregators))
            for iter138 in self.aggregators:
                iter138.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.estimated_input_cardinality is not None:
            oprot.writeFieldBegin('estimated_input_cardinality', TType.I64, 2)
            oprot.writeI64(self.estimated_input_cardinality)
            oprot.writeFieldEnd()
        if self.replicate_input is not None:
            oprot.writeFieldBegin('replicate_input', TType.BOOL, 3)
            oprot.writeBool(self.replicate_input)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aggregators is None:
            raise TProtocolException(message='Required field aggregators is unset!')
        if self.estimated_input_cardinality is None:
            raise TProtocolException(message='Required field estimated_input_cardinality is unset!')
        if self.replicate_input is None:
            raise TProtocolException(message='Required field replicate_input is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSortInfo(object):
    """
    Attributes:
     - ordering_exprs
     - is_asc_order
     - nulls_first
     - sort_tuple_slot_exprs
     - sorting_order
    """


    def __init__(self, ordering_exprs=None, is_asc_order=None, nulls_first=None, sort_tuple_slot_exprs=None, sorting_order=None,):
        self.ordering_exprs = ordering_exprs
        self.is_asc_order = is_asc_order
        self.nulls_first = nulls_first
        self.sort_tuple_slot_exprs = sort_tuple_slot_exprs
        self.sorting_order = sorting_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ordering_exprs = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = Exprs.ttypes.TExpr()
                        _elem144.read(iprot)
                        self.ordering_exprs.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.is_asc_order = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = iprot.readBool()
                        self.is_asc_order.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nulls_first = []
                    (_etype154, _size151) = iprot.readListBegin()
                    for _i155 in range(_size151):
                        _elem156 = iprot.readBool()
                        self.nulls_first.append(_elem156)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sort_tuple_slot_exprs = []
                    (_etype160, _size157) = iprot.readListBegin()
                    for _i161 in range(_size157):
                        _elem162 = Exprs.ttypes.TExpr()
                        _elem162.read(iprot)
                        self.sort_tuple_slot_exprs.append(_elem162)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSortInfo')
        if self.ordering_exprs is not None:
            oprot.writeFieldBegin('ordering_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.ordering_exprs))
            for iter163 in self.ordering_exprs:
                iter163.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_asc_order is not None:
            oprot.writeFieldBegin('is_asc_order', TType.LIST, 2)
            oprot.writeListBegin(TType.BOOL, len(self.is_asc_order))
            for iter164 in self.is_asc_order:
                oprot.writeBool(iter164)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nulls_first is not None:
            oprot.writeFieldBegin('nulls_first', TType.LIST, 3)
            oprot.writeListBegin(TType.BOOL, len(self.nulls_first))
            for iter165 in self.nulls_first:
                oprot.writeBool(iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_tuple_slot_exprs is not None:
            oprot.writeFieldBegin('sort_tuple_slot_exprs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.sort_tuple_slot_exprs))
            for iter166 in self.sort_tuple_slot_exprs:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 5)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ordering_exprs is None:
            raise TProtocolException(message='Required field ordering_exprs is unset!')
        if self.is_asc_order is None:
            raise TProtocolException(message='Required field is_asc_order is unset!')
        if self.nulls_first is None:
            raise TProtocolException(message='Required field nulls_first is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSortNode(object):
    """
    Attributes:
     - sort_info
     - type
     - offset
    """


    def __init__(self, sort_info=None, type=None, offset=None,):
        self.sort_info = sort_info
        self.type = type
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sort_info = TSortInfo()
                    self.sort_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSortNode')
        if self.sort_info is not None:
            oprot.writeFieldBegin('sort_info', TType.STRUCT, 1)
            self.sort_info.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sort_info is None:
            raise TProtocolException(message='Required field sort_info is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticWindowBoundary(object):
    """
    Attributes:
     - type
     - range_offset_predicate
     - rows_offset_value
    """


    def __init__(self, type=None, range_offset_predicate=None, rows_offset_value=None,):
        self.type = type
        self.range_offset_predicate = range_offset_predicate
        self.rows_offset_value = rows_offset_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.range_offset_predicate = Exprs.ttypes.TExpr()
                    self.range_offset_predicate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.rows_offset_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticWindowBoundary')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.range_offset_predicate is not None:
            oprot.writeFieldBegin('range_offset_predicate', TType.STRUCT, 2)
            self.range_offset_predicate.write(oprot)
            oprot.writeFieldEnd()
        if self.rows_offset_value is not None:
            oprot.writeFieldBegin('rows_offset_value', TType.I64, 3)
            oprot.writeI64(self.rows_offset_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticWindow(object):
    """
    Attributes:
     - type
     - window_start
     - window_end
    """


    def __init__(self, type=None, window_start=None, window_end=None,):
        self.type = type
        self.window_start = window_start
        self.window_end = window_end

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.window_start = TAnalyticWindowBoundary()
                    self.window_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.window_end = TAnalyticWindowBoundary()
                    self.window_end.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticWindow')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.window_start is not None:
            oprot.writeFieldBegin('window_start', TType.STRUCT, 2)
            self.window_start.write(oprot)
            oprot.writeFieldEnd()
        if self.window_end is not None:
            oprot.writeFieldBegin('window_end', TType.STRUCT, 3)
            self.window_end.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticNode(object):
    """
    Attributes:
     - partition_exprs
     - order_by_exprs
     - analytic_functions
     - window
     - intermediate_tuple_id
     - output_tuple_id
     - buffered_tuple_id
     - partition_by_eq
     - order_by_eq
    """


    def __init__(self, partition_exprs=None, order_by_exprs=None, analytic_functions=None, window=None, intermediate_tuple_id=None, output_tuple_id=None, buffered_tuple_id=None, partition_by_eq=None, order_by_eq=None,):
        self.partition_exprs = partition_exprs
        self.order_by_exprs = order_by_exprs
        self.analytic_functions = analytic_functions
        self.window = window
        self.intermediate_tuple_id = intermediate_tuple_id
        self.output_tuple_id = output_tuple_id
        self.buffered_tuple_id = buffered_tuple_id
        self.partition_by_eq = partition_by_eq
        self.order_by_eq = order_by_eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_exprs = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = Exprs.ttypes.TExpr()
                        _elem172.read(iprot)
                        self.partition_exprs.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.order_by_exprs = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = Exprs.ttypes.TExpr()
                        _elem178.read(iprot)
                        self.order_by_exprs.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.analytic_functions = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = Exprs.ttypes.TExpr()
                        _elem184.read(iprot)
                        self.analytic_functions.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.window = TAnalyticWindow()
                    self.window.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.intermediate_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.output_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.buffered_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.partition_by_eq = Exprs.ttypes.TExpr()
                    self.partition_by_eq.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.order_by_eq = Exprs.ttypes.TExpr()
                    self.order_by_eq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticNode')
        if self.partition_exprs is not None:
            oprot.writeFieldBegin('partition_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_exprs))
            for iter185 in self.partition_exprs:
                iter185.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.order_by_exprs is not None:
            oprot.writeFieldBegin('order_by_exprs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.order_by_exprs))
            for iter186 in self.order_by_exprs:
                iter186.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.analytic_functions is not None:
            oprot.writeFieldBegin('analytic_functions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.analytic_functions))
            for iter187 in self.analytic_functions:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.window is not None:
            oprot.writeFieldBegin('window', TType.STRUCT, 4)
            self.window.write(oprot)
            oprot.writeFieldEnd()
        if self.intermediate_tuple_id is not None:
            oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 5)
            oprot.writeI32(self.intermediate_tuple_id)
            oprot.writeFieldEnd()
        if self.output_tuple_id is not None:
            oprot.writeFieldBegin('output_tuple_id', TType.I32, 6)
            oprot.writeI32(self.output_tuple_id)
            oprot.writeFieldEnd()
        if self.buffered_tuple_id is not None:
            oprot.writeFieldBegin('buffered_tuple_id', TType.I32, 7)
            oprot.writeI32(self.buffered_tuple_id)
            oprot.writeFieldEnd()
        if self.partition_by_eq is not None:
            oprot.writeFieldBegin('partition_by_eq', TType.STRUCT, 8)
            self.partition_by_eq.write(oprot)
            oprot.writeFieldEnd()
        if self.order_by_eq is not None:
            oprot.writeFieldBegin('order_by_eq', TType.STRUCT, 9)
            self.order_by_eq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_exprs is None:
            raise TProtocolException(message='Required field partition_exprs is unset!')
        if self.order_by_exprs is None:
            raise TProtocolException(message='Required field order_by_exprs is unset!')
        if self.analytic_functions is None:
            raise TProtocolException(message='Required field analytic_functions is unset!')
        if self.intermediate_tuple_id is None:
            raise TProtocolException(message='Required field intermediate_tuple_id is unset!')
        if self.output_tuple_id is None:
            raise TProtocolException(message='Required field output_tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnionNode(object):
    """
    Attributes:
     - tuple_id
     - result_expr_lists
     - const_expr_lists
     - first_materialized_child_idx
    """


    def __init__(self, tuple_id=None, result_expr_lists=None, const_expr_lists=None, first_materialized_child_idx=None,):
        self.tuple_id = tuple_id
        self.result_expr_lists = result_expr_lists
        self.const_expr_lists = const_expr_lists
        self.first_materialized_child_idx = first_materialized_child_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.result_expr_lists = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = []
                        (_etype197, _size194) = iprot.readListBegin()
                        for _i198 in range(_size194):
                            _elem199 = Exprs.ttypes.TExpr()
                            _elem199.read(iprot)
                            _elem193.append(_elem199)
                        iprot.readListEnd()
                        self.result_expr_lists.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.const_expr_lists = []
                    (_etype203, _size200) = iprot.readListBegin()
                    for _i204 in range(_size200):
                        _elem205 = []
                        (_etype209, _size206) = iprot.readListBegin()
                        for _i210 in range(_size206):
                            _elem211 = Exprs.ttypes.TExpr()
                            _elem211.read(iprot)
                            _elem205.append(_elem211)
                        iprot.readListEnd()
                        self.const_expr_lists.append(_elem205)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.first_materialized_child_idx = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnionNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.result_expr_lists is not None:
            oprot.writeFieldBegin('result_expr_lists', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.result_expr_lists))
            for iter212 in self.result_expr_lists:
                oprot.writeListBegin(TType.STRUCT, len(iter212))
                for iter213 in iter212:
                    iter213.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.const_expr_lists is not None:
            oprot.writeFieldBegin('const_expr_lists', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.const_expr_lists))
            for iter214 in self.const_expr_lists:
                oprot.writeListBegin(TType.STRUCT, len(iter214))
                for iter215 in iter214:
                    iter215.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.first_materialized_child_idx is not None:
            oprot.writeFieldBegin('first_materialized_child_idx', TType.I64, 4)
            oprot.writeI64(self.first_materialized_child_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.result_expr_lists is None:
            raise TProtocolException(message='Required field result_expr_lists is unset!')
        if self.const_expr_lists is None:
            raise TProtocolException(message='Required field const_expr_lists is unset!')
        if self.first_materialized_child_idx is None:
            raise TProtocolException(message='Required field first_materialized_child_idx is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExchangeNode(object):
    """
    Attributes:
     - input_row_tuples
     - sort_info
     - offset
    """


    def __init__(self, input_row_tuples=None, sort_info=None, offset=None,):
        self.input_row_tuples = input_row_tuples
        self.sort_info = sort_info
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.input_row_tuples = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = iprot.readI32()
                        self.input_row_tuples.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sort_info = TSortInfo()
                    self.sort_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExchangeNode')
        if self.input_row_tuples is not None:
            oprot.writeFieldBegin('input_row_tuples', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.input_row_tuples))
            for iter222 in self.input_row_tuples:
                oprot.writeI32(iter222)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_info is not None:
            oprot.writeFieldBegin('sort_info', TType.STRUCT, 2)
            self.sort_info.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_row_tuples is None:
            raise TProtocolException(message='Required field input_row_tuples is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnnestNode(object):
    """
    Attributes:
     - collection_expr
    """


    def __init__(self, collection_expr=None,):
        self.collection_expr = collection_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.collection_expr = Exprs.ttypes.TExpr()
                    self.collection_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnnestNode')
        if self.collection_expr is not None:
            oprot.writeFieldBegin('collection_expr', TType.STRUCT, 1)
            self.collection_expr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.collection_expr is None:
            raise TProtocolException(message='Required field collection_expr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCardinalityCheckNode(object):
    """
    Attributes:
     - display_statement
    """


    def __init__(self, display_statement=None,):
        self.display_statement = display_statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.display_statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCardinalityCheckNode')
        if self.display_statement is not None:
            oprot.writeFieldBegin('display_statement', TType.STRING, 1)
            oprot.writeString(self.display_statement.encode('utf-8') if sys.version_info[0] == 2 else self.display_statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.display_statement is None:
            raise TProtocolException(message='Required field display_statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipelineMembership(object):
    """
    Attributes:
     - pipe_id
     - height
     - phase
    """


    def __init__(self, pipe_id=None, height=None, phase=None,):
        self.pipe_id = pipe_id
        self.height = height
        self.phase = phase

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.pipe_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.phase = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipelineMembership')
        if self.pipe_id is not None:
            oprot.writeFieldBegin('pipe_id', TType.I32, 1)
            oprot.writeI32(self.pipe_id)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I32, 2)
            oprot.writeI32(self.height)
            oprot.writeFieldEnd()
        if self.phase is not None:
            oprot.writeFieldBegin('phase', TType.I32, 3)
            oprot.writeI32(self.phase)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipe_id is None:
            raise TProtocolException(message='Required field pipe_id is unset!')
        if self.height is None:
            raise TProtocolException(message='Required field height is unset!')
        if self.phase is None:
            raise TProtocolException(message='Required field phase is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanNode(object):
    """
    Attributes:
     - node_id
     - node_type
     - num_children
     - limit
     - row_tuples
     - nullable_tuples
     - conjuncts
     - disable_codegen
     - pipelines
     - hdfs_scan_node
     - hbase_scan_node
     - kudu_scan_node
     - data_source_node
     - join_node
     - agg_node
     - sort_node
     - union_node
     - exchange_node
     - analytic_node
     - unnest_node
     - label
     - label_detail
     - estimated_stats
     - runtime_filters
     - resource_profile
     - cardinality_check_node
    """


    def __init__(self, node_id=None, node_type=None, num_children=None, limit=None, row_tuples=None, nullable_tuples=None, conjuncts=None, disable_codegen=None, pipelines=None, hdfs_scan_node=None, hbase_scan_node=None, kudu_scan_node=None, data_source_node=None, join_node=None, agg_node=None, sort_node=None, union_node=None, exchange_node=None, analytic_node=None, unnest_node=None, label=None, label_detail=None, estimated_stats=None, runtime_filters=None, resource_profile=None, cardinality_check_node=None,):
        self.node_id = node_id
        self.node_type = node_type
        self.num_children = num_children
        self.limit = limit
        self.row_tuples = row_tuples
        self.nullable_tuples = nullable_tuples
        self.conjuncts = conjuncts
        self.disable_codegen = disable_codegen
        self.pipelines = pipelines
        self.hdfs_scan_node = hdfs_scan_node
        self.hbase_scan_node = hbase_scan_node
        self.kudu_scan_node = kudu_scan_node
        self.data_source_node = data_source_node
        self.join_node = join_node
        self.agg_node = agg_node
        self.sort_node = sort_node
        self.union_node = union_node
        self.exchange_node = exchange_node
        self.analytic_node = analytic_node
        self.unnest_node = unnest_node
        self.label = label
        self.label_detail = label_detail
        self.estimated_stats = estimated_stats
        self.runtime_filters = runtime_filters
        self.resource_profile = resource_profile
        self.cardinality_check_node = cardinality_check_node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_children = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.row_tuples = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readI32()
                        self.row_tuples.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.nullable_tuples = []
                    (_etype232, _size229) = iprot.readListBegin()
                    for _i233 in range(_size229):
                        _elem234 = iprot.readBool()
                        self.nullable_tuples.append(_elem234)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.conjuncts = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = Exprs.ttypes.TExpr()
                        _elem240.read(iprot)
                        self.conjuncts.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.disable_codegen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.LIST:
                    self.pipelines = []
                    (_etype244, _size241) = iprot.readListBegin()
                    for _i245 in range(_size241):
                        _elem246 = TPipelineMembership()
                        _elem246.read(iprot)
                        self.pipelines.append(_elem246)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.hdfs_scan_node = THdfsScanNode()
                    self.hdfs_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.hbase_scan_node = THBaseScanNode()
                    self.hbase_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.kudu_scan_node = TKuduScanNode()
                    self.kudu_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.data_source_node = TDataSourceScanNode()
                    self.data_source_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.join_node = TJoinNode()
                    self.join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.agg_node = TAggregationNode()
                    self.agg_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.sort_node = TSortNode()
                    self.sort_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.union_node = TUnionNode()
                    self.union_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.exchange_node = TExchangeNode()
                    self.exchange_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.analytic_node = TAnalyticNode()
                    self.analytic_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.unnest_node = TUnnestNode()
                    self.unnest_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRING:
                    self.label_detail = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRUCT:
                    self.estimated_stats = ExecStats.ttypes.TExecStats()
                    self.estimated_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.LIST:
                    self.runtime_filters = []
                    (_etype250, _size247) = iprot.readListBegin()
                    for _i251 in range(_size247):
                        _elem252 = TRuntimeFilterDesc()
                        _elem252.read(iprot)
                        self.runtime_filters.append(_elem252)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRUCT:
                    self.cardinality_check_node = TCardinalityCheckNode()
                    self.cardinality_check_node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanNode')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.node_type is not None:
            oprot.writeFieldBegin('node_type', TType.I32, 2)
            oprot.writeI32(self.node_type)
            oprot.writeFieldEnd()
        if self.num_children is not None:
            oprot.writeFieldBegin('num_children', TType.I32, 3)
            oprot.writeI32(self.num_children)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.row_tuples is not None:
            oprot.writeFieldBegin('row_tuples', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.row_tuples))
            for iter253 in self.row_tuples:
                oprot.writeI32(iter253)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullable_tuples is not None:
            oprot.writeFieldBegin('nullable_tuples', TType.LIST, 6)
            oprot.writeListBegin(TType.BOOL, len(self.nullable_tuples))
            for iter254 in self.nullable_tuples:
                oprot.writeBool(iter254)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.conjuncts is not None:
            oprot.writeFieldBegin('conjuncts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.conjuncts))
            for iter255 in self.conjuncts:
                iter255.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.disable_codegen is not None:
            oprot.writeFieldBegin('disable_codegen', TType.BOOL, 8)
            oprot.writeBool(self.disable_codegen)
            oprot.writeFieldEnd()
        if self.hdfs_scan_node is not None:
            oprot.writeFieldBegin('hdfs_scan_node', TType.STRUCT, 9)
            self.hdfs_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_scan_node is not None:
            oprot.writeFieldBegin('hbase_scan_node', TType.STRUCT, 10)
            self.hbase_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_scan_node is not None:
            oprot.writeFieldBegin('kudu_scan_node', TType.STRUCT, 11)
            self.kudu_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source_node is not None:
            oprot.writeFieldBegin('data_source_node', TType.STRUCT, 12)
            self.data_source_node.write(oprot)
            oprot.writeFieldEnd()
        if self.join_node is not None:
            oprot.writeFieldBegin('join_node', TType.STRUCT, 13)
            self.join_node.write(oprot)
            oprot.writeFieldEnd()
        if self.agg_node is not None:
            oprot.writeFieldBegin('agg_node', TType.STRUCT, 15)
            self.agg_node.write(oprot)
            oprot.writeFieldEnd()
        if self.sort_node is not None:
            oprot.writeFieldBegin('sort_node', TType.STRUCT, 16)
            self.sort_node.write(oprot)
            oprot.writeFieldEnd()
        if self.union_node is not None:
            oprot.writeFieldBegin('union_node', TType.STRUCT, 17)
            self.union_node.write(oprot)
            oprot.writeFieldEnd()
        if self.exchange_node is not None:
            oprot.writeFieldBegin('exchange_node', TType.STRUCT, 18)
            self.exchange_node.write(oprot)
            oprot.writeFieldEnd()
        if self.analytic_node is not None:
            oprot.writeFieldBegin('analytic_node', TType.STRUCT, 19)
            self.analytic_node.write(oprot)
            oprot.writeFieldEnd()
        if self.unnest_node is not None:
            oprot.writeFieldBegin('unnest_node', TType.STRUCT, 20)
            self.unnest_node.write(oprot)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 21)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.label_detail is not None:
            oprot.writeFieldBegin('label_detail', TType.STRING, 22)
            oprot.writeString(self.label_detail.encode('utf-8') if sys.version_info[0] == 2 else self.label_detail)
            oprot.writeFieldEnd()
        if self.estimated_stats is not None:
            oprot.writeFieldBegin('estimated_stats', TType.STRUCT, 23)
            self.estimated_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.runtime_filters is not None:
            oprot.writeFieldBegin('runtime_filters', TType.LIST, 24)
            oprot.writeListBegin(TType.STRUCT, len(self.runtime_filters))
            for iter256 in self.runtime_filters:
                iter256.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 25)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        if self.cardinality_check_node is not None:
            oprot.writeFieldBegin('cardinality_check_node', TType.STRUCT, 26)
            self.cardinality_check_node.write(oprot)
            oprot.writeFieldEnd()
        if self.pipelines is not None:
            oprot.writeFieldBegin('pipelines', TType.LIST, 27)
            oprot.writeListBegin(TType.STRUCT, len(self.pipelines))
            for iter257 in self.pipelines:
                iter257.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.node_id is None:
            raise TProtocolException(message='Required field node_id is unset!')
        if self.node_type is None:
            raise TProtocolException(message='Required field node_type is unset!')
        if self.num_children is None:
            raise TProtocolException(message='Required field num_children is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        if self.row_tuples is None:
            raise TProtocolException(message='Required field row_tuples is unset!')
        if self.nullable_tuples is None:
            raise TProtocolException(message='Required field nullable_tuples is unset!')
        if self.disable_codegen is None:
            raise TProtocolException(message='Required field disable_codegen is unset!')
        if self.pipelines is None:
            raise TProtocolException(message='Required field pipelines is unset!')
        if self.resource_profile is None:
            raise TProtocolException(message='Required field resource_profile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlan(object):
    """
    Attributes:
     - nodes
    """


    def __init__(self, nodes=None,):
        self.nodes = nodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodes = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = TPlanNode()
                        _elem263.read(iprot)
                        self.nodes.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlan')
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodes))
            for iter264 in self.nodes:
                iter264.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nodes is None:
            raise TProtocolException(message='Required field nodes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TRuntimeFilterTargetDesc)
TRuntimeFilterTargetDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'target_expr', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.BOOL, 'is_bound_by_partition_columns', None, None, ),  # 3
    (4, TType.LIST, 'target_expr_slotids', (TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'is_local_target', None, None, ),  # 5
    (6, TType.STRING, 'kudu_col_name', 'UTF8', None, ),  # 6
    (7, TType.STRUCT, 'kudu_col_type', [Types.ttypes.TColumnType, None], None, ),  # 7
)
all_structs.append(TRuntimeFilterDesc)
TRuntimeFilterDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'filter_id', None, None, ),  # 1
    (2, TType.STRUCT, 'src_expr', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.LIST, 'targets', (TType.STRUCT, [TRuntimeFilterTargetDesc, None], False), None, ),  # 3
    (4, TType.MAP, 'planid_to_target_ndx', (TType.I32, None, TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'is_broadcast_join', None, None, ),  # 5
    (6, TType.BOOL, 'has_local_targets', None, None, ),  # 6
    (7, TType.BOOL, 'has_remote_targets', None, None, ),  # 7
    (8, TType.BOOL, 'applied_on_partition_columns', None, None, ),  # 8
    (9, TType.I64, 'ndv_estimate', None, None, ),  # 9
    (10, TType.I32, 'type', None, None, ),  # 10
    (11, TType.I64, 'filter_size_bytes', None, None, ),  # 11
    (12, TType.I32, 'src_node_id', None, None, ),  # 12
)
all_structs.append(THdfsFileSplit)
THdfsFileSplit.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'relative_path', 'UTF8', None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I64, 'length', None, None, ),  # 3
    (4, TType.I64, 'partition_id', None, None, ),  # 4
    (5, TType.I64, 'file_length', None, None, ),  # 5
    (6, TType.I32, 'file_compression', None, None, ),  # 6
    (7, TType.I64, 'mtime', None, None, ),  # 7
    (8, TType.BOOL, 'is_erasure_coded', None, None, ),  # 8
    (9, TType.I32, 'partition_path_hash', None, None, ),  # 9
)
all_structs.append(THBaseKeyRange)
THBaseKeyRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'startKey', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'stopKey', 'UTF8', None, ),  # 2
)
all_structs.append(TFileSplitGeneratorSpec)
TFileSplitGeneratorSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'file_desc', [CatalogObjects.ttypes.THdfsFileDesc, None], None, ),  # 1
    (2, TType.I64, 'max_block_size', None, None, ),  # 2
    (3, TType.BOOL, 'is_splittable', None, None, ),  # 3
    (4, TType.I64, 'partition_id', None, None, ),  # 4
    (5, TType.I32, 'partition_path_hash', None, None, ),  # 5
)
all_structs.append(TScanRange)
TScanRange.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hdfs_file_split', [THdfsFileSplit, None], None, ),  # 1
    (2, TType.STRUCT, 'hbase_key_range', [THBaseKeyRange, None], None, ),  # 2
    (3, TType.STRING, 'kudu_scan_token', 'BINARY', None, ),  # 3
)
all_structs.append(THdfsScanNode)
THdfsScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.MAP, 'collection_conjuncts', (TType.I32, None, TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 2
    (3, TType.I32, 'replica_preference', None, None, ),  # 3
    (4, TType.BOOL, 'random_replica', None, None, ),  # 4
    (5, TType.I32, 'skip_header_line_count', None, None, ),  # 5
    (6, TType.BOOL, 'use_mt_scan_node', None, None, ),  # 6
    (7, TType.LIST, 'min_max_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    (8, TType.I32, 'min_max_tuple_id', None, None, ),  # 8
    (9, TType.MAP, 'dictionary_filter_conjuncts', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 9
    (10, TType.I32, 'parquet_count_star_slot_offset', None, None, ),  # 10
)
all_structs.append(TDataSourceScanNode)
TDataSourceScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.STRUCT, 'data_source', [CatalogObjects.ttypes.TDataSource, None], None, ),  # 2
    (3, TType.STRING, 'init_string', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'accepted_predicates', (TType.LIST, (TType.STRUCT, [ExternalDataSource.ttypes.TBinaryPredicate, None], False), False), None, ),  # 4
)
all_structs.append(THBaseFilter)
THBaseFilter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'family', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'qualifier', 'UTF8', None, ),  # 2
    (3, TType.I32, 'op_ordinal', None, None, ),  # 3
    (4, TType.STRING, 'filter_constant', 'UTF8', None, ),  # 4
)
all_structs.append(THBaseScanNode)
THBaseScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'filters', (TType.STRUCT, [THBaseFilter, None], False), None, ),  # 3
    (4, TType.I32, 'suggested_max_caching', None, None, ),  # 4
)
all_structs.append(TKuduScanNode)
TKuduScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.BOOL, 'use_mt_scan_node', None, None, ),  # 2
    (3, TType.I32, 'count_star_slot_offset', None, None, ),  # 3
)
all_structs.append(TEqJoinCondition)
TEqJoinCondition.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'left', [Exprs.ttypes.TExpr, None], None, ),  # 1
    (2, TType.STRUCT, 'right', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.BOOL, 'is_not_distinct_from', None, None, ),  # 3
)
all_structs.append(THashJoinNode)
THashJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT, [TEqJoinCondition, None], False), None, ),  # 1
    (2, TType.LIST, 'other_join_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.I32, 'hash_seed', None, None, ),  # 3
)
all_structs.append(TNestedLoopJoinNode)
TNestedLoopJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'join_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
)
all_structs.append(TJoinNode)
TJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'join_op', None, None, ),  # 1
    (2, TType.LIST, 'build_tuples', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'nullable_build_tuples', (TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRUCT, 'hash_join_node', [THashJoinNode, None], None, ),  # 4
    (5, TType.STRUCT, 'nested_loop_join_node', [TNestedLoopJoinNode, None], None, ),  # 5
)
all_structs.append(TAggregator)
TAggregator.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'grouping_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'aggregate_functions', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.I32, 'intermediate_tuple_id', None, None, ),  # 3
    (4, TType.I32, 'output_tuple_id', None, None, ),  # 4
    (5, TType.BOOL, 'need_finalize', None, None, ),  # 5
    (6, TType.BOOL, 'use_streaming_preaggregation', None, None, ),  # 6
    (7, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 7
)
all_structs.append(TAggregationNode)
TAggregationNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'aggregators', (TType.STRUCT, [TAggregator, None], False), None, ),  # 1
    (2, TType.I64, 'estimated_input_cardinality', None, None, ),  # 2
    (3, TType.BOOL, 'replicate_input', None, None, ),  # 3
)
all_structs.append(TSortInfo)
TSortInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ordering_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'is_asc_order', (TType.BOOL, None, False), None, ),  # 2
    (3, TType.LIST, 'nulls_first', (TType.BOOL, None, False), None, ),  # 3
    (4, TType.LIST, 'sort_tuple_slot_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 4
    (5, TType.I32, 'sorting_order', None, None, ),  # 5
)
all_structs.append(TSortNode)
TSortNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sort_info', [TSortInfo, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
)
all_structs.append(TAnalyticWindowBoundary)
TAnalyticWindowBoundary.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'range_offset_predicate', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.I64, 'rows_offset_value', None, None, ),  # 3
)
all_structs.append(TAnalyticWindow)
TAnalyticWindow.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'window_start', [TAnalyticWindowBoundary, None], None, ),  # 2
    (3, TType.STRUCT, 'window_end', [TAnalyticWindowBoundary, None], None, ),  # 3
)
all_structs.append(TAnalyticNode)
TAnalyticNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'order_by_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.LIST, 'analytic_functions', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 3
    (4, TType.STRUCT, 'window', [TAnalyticWindow, None], None, ),  # 4
    (5, TType.I32, 'intermediate_tuple_id', None, None, ),  # 5
    (6, TType.I32, 'output_tuple_id', None, None, ),  # 6
    (7, TType.I32, 'buffered_tuple_id', None, None, ),  # 7
    (8, TType.STRUCT, 'partition_by_eq', [Exprs.ttypes.TExpr, None], None, ),  # 8
    (9, TType.STRUCT, 'order_by_eq', [Exprs.ttypes.TExpr, None], None, ),  # 9
)
all_structs.append(TUnionNode)
TUnionNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.LIST, 'result_expr_lists', (TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 2
    (3, TType.LIST, 'const_expr_lists', (TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 3
    (4, TType.I64, 'first_materialized_child_idx', None, None, ),  # 4
)
all_structs.append(TExchangeNode)
TExchangeNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'input_row_tuples', (TType.I32, None, False), None, ),  # 1
    (2, TType.STRUCT, 'sort_info', [TSortInfo, None], None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
)
all_structs.append(TUnnestNode)
TUnnestNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'collection_expr', [Exprs.ttypes.TExpr, None], None, ),  # 1
)
all_structs.append(TCardinalityCheckNode)
TCardinalityCheckNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'display_statement', 'UTF8', None, ),  # 1
)
all_structs.append(TPipelineMembership)
TPipelineMembership.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'pipe_id', None, None, ),  # 1
    (2, TType.I32, 'height', None, None, ),  # 2
    (3, TType.I32, 'phase', None, None, ),  # 3
)
all_structs.append(TPlanNode)
TPlanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'node_type', None, None, ),  # 2
    (3, TType.I32, 'num_children', None, None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.LIST, 'row_tuples', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'nullable_tuples', (TType.BOOL, None, False), None, ),  # 6
    (7, TType.LIST, 'conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    (8, TType.BOOL, 'disable_codegen', None, None, ),  # 8
    (9, TType.STRUCT, 'hdfs_scan_node', [THdfsScanNode, None], None, ),  # 9
    (10, TType.STRUCT, 'hbase_scan_node', [THBaseScanNode, None], None, ),  # 10
    (11, TType.STRUCT, 'kudu_scan_node', [TKuduScanNode, None], None, ),  # 11
    (12, TType.STRUCT, 'data_source_node', [TDataSourceScanNode, None], None, ),  # 12
    (13, TType.STRUCT, 'join_node', [TJoinNode, None], None, ),  # 13
    None,  # 14
    (15, TType.STRUCT, 'agg_node', [TAggregationNode, None], None, ),  # 15
    (16, TType.STRUCT, 'sort_node', [TSortNode, None], None, ),  # 16
    (17, TType.STRUCT, 'union_node', [TUnionNode, None], None, ),  # 17
    (18, TType.STRUCT, 'exchange_node', [TExchangeNode, None], None, ),  # 18
    (19, TType.STRUCT, 'analytic_node', [TAnalyticNode, None], None, ),  # 19
    (20, TType.STRUCT, 'unnest_node', [TUnnestNode, None], None, ),  # 20
    (21, TType.STRING, 'label', 'UTF8', None, ),  # 21
    (22, TType.STRING, 'label_detail', 'UTF8', None, ),  # 22
    (23, TType.STRUCT, 'estimated_stats', [ExecStats.ttypes.TExecStats, None], None, ),  # 23
    (24, TType.LIST, 'runtime_filters', (TType.STRUCT, [TRuntimeFilterDesc, None], False), None, ),  # 24
    (25, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 25
    (26, TType.STRUCT, 'cardinality_check_node', [TCardinalityCheckNode, None], None, ),  # 26
    (27, TType.LIST, 'pipelines', (TType.STRUCT, [TPipelineMembership, None], False), None, ),  # 27
)
all_structs.append(TPlan)
TPlan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT, [TPlanNode, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
