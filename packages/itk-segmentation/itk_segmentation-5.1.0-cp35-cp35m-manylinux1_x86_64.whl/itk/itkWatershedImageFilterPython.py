# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkWatershedImageFilterPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkWatershedImageFilterPython', [dirname(__file__)])
        except ImportError:
            import _itkWatershedImageFilterPython
            return _itkWatershedImageFilterPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkWatershedImageFilterPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkWatershedImageFilterPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkWatershedImageFilterPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkImageToImageFilterAPython
import itkImageSourcePython
import ITKCommonBasePython
import pyBasePython
import itkImagePython
import itkImageRegionPython
import itkSizePython
import itkIndexPython
import itkOffsetPython
import itkRGBPixelPython
import itkFixedArrayPython
import stdcomplexPython
import itkSymmetricSecondRankTensorPython
import itkMatrixPython
import vnl_vectorPython
import vnl_matrixPython
import itkPointPython
import vnl_vector_refPython
import itkVectorPython
import vnl_matrix_fixedPython
import itkCovariantVectorPython
import itkRGBAPixelPython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageSourceCommonPython
import itkImageToImageFilterCommonPython

def itkWatershedImageFilterID3_New():
  return itkWatershedImageFilterID3.New()


def itkWatershedImageFilterID2_New():
  return itkWatershedImageFilterID2.New()


def itkWatershedImageFilterIF3_New():
  return itkWatershedImageFilterIF3.New()


def itkWatershedImageFilterIF2_New():
  return itkWatershedImageFilterIF2.New()


def itkWatershedImageFilterIUS3_New():
  return itkWatershedImageFilterIUS3.New()


def itkWatershedImageFilterIUS2_New():
  return itkWatershedImageFilterIUS2.New()


def itkWatershedImageFilterIUC3_New():
  return itkWatershedImageFilterIUC3.New()


def itkWatershedImageFilterIUC2_New():
  return itkWatershedImageFilterIUC2.New()


def itkWatershedImageFilterISS3_New():
  return itkWatershedImageFilterISS3.New()


def itkWatershedImageFilterISS2_New():
  return itkWatershedImageFilterISS2.New()

class itkWatershedImageFilterID2(itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterID2_Pointer":
        """__New_orig__() -> itkWatershedImageFilterID2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterID2_Pointer":
        """Clone(itkWatershedImageFilterID2 self) -> itkWatershedImageFilterID2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterID2 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterID2 self, itkImageD2 input)
        SetInput(itkWatershedImageFilterID2 self, unsigned int i, itkImageD2 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterID2 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterID2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterID2 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterID2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL2 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterID2 self) -> itkImageUL2

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< double > *":
        """
        GetSegmentTree(itkWatershedImageFilterID2 self) -> itk::watershed::SegmentTree< double > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID2_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID2_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID2_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID2_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterID2

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterID2 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterID2"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterID2

        Create a new object of the class itkWatershedImageFilterID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterID2.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_Clone, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_GenerateData, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetInput, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetThreshold, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetThreshold, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_SetLevel, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetLevel, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetBasicSegmentation, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID2_GetSegmentTree, None, itkWatershedImageFilterID2)
itkWatershedImageFilterID2_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterID2_swigregister
itkWatershedImageFilterID2_swigregister(itkWatershedImageFilterID2)

def itkWatershedImageFilterID2___New_orig__() -> "itkWatershedImageFilterID2_Pointer":
    """itkWatershedImageFilterID2___New_orig__() -> itkWatershedImageFilterID2_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterID2___New_orig__()

def itkWatershedImageFilterID2_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterID2 *":
    """itkWatershedImageFilterID2_cast(itkLightObject obj) -> itkWatershedImageFilterID2"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterID2_cast(obj)

class itkWatershedImageFilterID3(itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterID3_Pointer":
        """__New_orig__() -> itkWatershedImageFilterID3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterID3_Pointer":
        """Clone(itkWatershedImageFilterID3 self) -> itkWatershedImageFilterID3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterID3 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterID3 self, itkImageD3 input)
        SetInput(itkWatershedImageFilterID3 self, unsigned int i, itkImageD3 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterID3 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterID3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterID3 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterID3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL3 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterID3 self) -> itkImageUL3

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< double > *":
        """
        GetSegmentTree(itkWatershedImageFilterID3 self) -> itk::watershed::SegmentTree< double > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID3_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID3_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID3_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterID3_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterID3

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterID3 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterID3"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterID3

        Create a new object of the class itkWatershedImageFilterID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterID3.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_Clone, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_GenerateData, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetInput, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetThreshold, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetThreshold, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_SetLevel, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetLevel, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetBasicSegmentation, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterID3_GetSegmentTree, None, itkWatershedImageFilterID3)
itkWatershedImageFilterID3_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterID3_swigregister
itkWatershedImageFilterID3_swigregister(itkWatershedImageFilterID3)

def itkWatershedImageFilterID3___New_orig__() -> "itkWatershedImageFilterID3_Pointer":
    """itkWatershedImageFilterID3___New_orig__() -> itkWatershedImageFilterID3_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterID3___New_orig__()

def itkWatershedImageFilterID3_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterID3 *":
    """itkWatershedImageFilterID3_cast(itkLightObject obj) -> itkWatershedImageFilterID3"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterID3_cast(obj)

class itkWatershedImageFilterIF2(itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIF2_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIF2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIF2_Pointer":
        """Clone(itkWatershedImageFilterIF2 self) -> itkWatershedImageFilterIF2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIF2 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIF2 self, itkImageF2 input)
        SetInput(itkWatershedImageFilterIF2 self, unsigned int i, itkImageF2 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIF2 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIF2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIF2 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIF2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL2 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIF2 self) -> itkImageUL2

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< float > *":
        """
        GetSegmentTree(itkWatershedImageFilterIF2 self) -> itk::watershed::SegmentTree< float > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIF2

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIF2 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIF2"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIF2

        Create a new object of the class itkWatershedImageFilterIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIF2.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_Clone, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GenerateData, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetInput, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetThreshold, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetThreshold, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_SetLevel, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetLevel, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetBasicSegmentation, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF2_GetSegmentTree, None, itkWatershedImageFilterIF2)
itkWatershedImageFilterIF2_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_swigregister
itkWatershedImageFilterIF2_swigregister(itkWatershedImageFilterIF2)

def itkWatershedImageFilterIF2___New_orig__() -> "itkWatershedImageFilterIF2_Pointer":
    """itkWatershedImageFilterIF2___New_orig__() -> itkWatershedImageFilterIF2_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2___New_orig__()

def itkWatershedImageFilterIF2_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIF2 *":
    """itkWatershedImageFilterIF2_cast(itkLightObject obj) -> itkWatershedImageFilterIF2"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIF2_cast(obj)

class itkWatershedImageFilterIF3(itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIF3_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIF3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIF3_Pointer":
        """Clone(itkWatershedImageFilterIF3 self) -> itkWatershedImageFilterIF3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIF3 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIF3 self, itkImageF3 input)
        SetInput(itkWatershedImageFilterIF3 self, unsigned int i, itkImageF3 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIF3 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIF3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIF3 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIF3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL3 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIF3 self) -> itkImageUL3

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< float > *":
        """
        GetSegmentTree(itkWatershedImageFilterIF3 self) -> itk::watershed::SegmentTree< float > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIF3

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIF3 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIF3"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIF3

        Create a new object of the class itkWatershedImageFilterIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIF3.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_Clone, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GenerateData, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetInput, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetThreshold, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetThreshold, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_SetLevel, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetLevel, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetBasicSegmentation, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIF3_GetSegmentTree, None, itkWatershedImageFilterIF3)
itkWatershedImageFilterIF3_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_swigregister
itkWatershedImageFilterIF3_swigregister(itkWatershedImageFilterIF3)

def itkWatershedImageFilterIF3___New_orig__() -> "itkWatershedImageFilterIF3_Pointer":
    """itkWatershedImageFilterIF3___New_orig__() -> itkWatershedImageFilterIF3_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3___New_orig__()

def itkWatershedImageFilterIF3_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIF3 *":
    """itkWatershedImageFilterIF3_cast(itkLightObject obj) -> itkWatershedImageFilterIF3"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIF3_cast(obj)

class itkWatershedImageFilterISS2(itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterISS2_Pointer":
        """__New_orig__() -> itkWatershedImageFilterISS2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterISS2_Pointer":
        """Clone(itkWatershedImageFilterISS2 self) -> itkWatershedImageFilterISS2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterISS2 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterISS2 self, itkImageSS2 input)
        SetInput(itkWatershedImageFilterISS2 self, unsigned int i, itkImageSS2 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterISS2 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterISS2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterISS2 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterISS2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL2 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterISS2 self) -> itkImageUL2

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< short > *":
        """
        GetSegmentTree(itkWatershedImageFilterISS2 self) -> itk::watershed::SegmentTree< short > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterISS2

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterISS2 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterISS2"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterISS2

        Create a new object of the class itkWatershedImageFilterISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterISS2.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_Clone, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GenerateData, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetInput, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetThreshold, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetThreshold, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_SetLevel, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetLevel, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetBasicSegmentation, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS2_GetSegmentTree, None, itkWatershedImageFilterISS2)
itkWatershedImageFilterISS2_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_swigregister
itkWatershedImageFilterISS2_swigregister(itkWatershedImageFilterISS2)

def itkWatershedImageFilterISS2___New_orig__() -> "itkWatershedImageFilterISS2_Pointer":
    """itkWatershedImageFilterISS2___New_orig__() -> itkWatershedImageFilterISS2_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2___New_orig__()

def itkWatershedImageFilterISS2_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterISS2 *":
    """itkWatershedImageFilterISS2_cast(itkLightObject obj) -> itkWatershedImageFilterISS2"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterISS2_cast(obj)

class itkWatershedImageFilterISS3(itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterISS3_Pointer":
        """__New_orig__() -> itkWatershedImageFilterISS3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterISS3_Pointer":
        """Clone(itkWatershedImageFilterISS3 self) -> itkWatershedImageFilterISS3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterISS3 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterISS3 self, itkImageSS3 input)
        SetInput(itkWatershedImageFilterISS3 self, unsigned int i, itkImageSS3 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterISS3 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterISS3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterISS3 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterISS3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL3 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterISS3 self) -> itkImageUL3

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< short > *":
        """
        GetSegmentTree(itkWatershedImageFilterISS3 self) -> itk::watershed::SegmentTree< short > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterISS3

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterISS3 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterISS3"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterISS3

        Create a new object of the class itkWatershedImageFilterISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterISS3.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_Clone, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GenerateData, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetInput, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetThreshold, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetThreshold, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_SetLevel, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetLevel, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetBasicSegmentation, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterISS3_GetSegmentTree, None, itkWatershedImageFilterISS3)
itkWatershedImageFilterISS3_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_swigregister
itkWatershedImageFilterISS3_swigregister(itkWatershedImageFilterISS3)

def itkWatershedImageFilterISS3___New_orig__() -> "itkWatershedImageFilterISS3_Pointer":
    """itkWatershedImageFilterISS3___New_orig__() -> itkWatershedImageFilterISS3_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3___New_orig__()

def itkWatershedImageFilterISS3_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterISS3 *":
    """itkWatershedImageFilterISS3_cast(itkLightObject obj) -> itkWatershedImageFilterISS3"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterISS3_cast(obj)

class itkWatershedImageFilterIUC2(itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIUC2_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIUC2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIUC2_Pointer":
        """Clone(itkWatershedImageFilterIUC2 self) -> itkWatershedImageFilterIUC2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIUC2 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIUC2 self, itkImageUC2 input)
        SetInput(itkWatershedImageFilterIUC2 self, unsigned int i, itkImageUC2 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIUC2 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIUC2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIUC2 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIUC2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL2 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIUC2 self) -> itkImageUL2

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< unsigned char > *":
        """
        GetSegmentTree(itkWatershedImageFilterIUC2 self) -> itk::watershed::SegmentTree< unsigned char > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIUC2

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUC2 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIUC2"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIUC2

        Create a new object of the class itkWatershedImageFilterIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIUC2.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_Clone, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GenerateData, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetInput, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetThreshold, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetThreshold, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_SetLevel, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetLevel, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetBasicSegmentation, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_GetSegmentTree, None, itkWatershedImageFilterIUC2)
itkWatershedImageFilterIUC2_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_swigregister
itkWatershedImageFilterIUC2_swigregister(itkWatershedImageFilterIUC2)

def itkWatershedImageFilterIUC2___New_orig__() -> "itkWatershedImageFilterIUC2_Pointer":
    """itkWatershedImageFilterIUC2___New_orig__() -> itkWatershedImageFilterIUC2_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2___New_orig__()

def itkWatershedImageFilterIUC2_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUC2 *":
    """itkWatershedImageFilterIUC2_cast(itkLightObject obj) -> itkWatershedImageFilterIUC2"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC2_cast(obj)

class itkWatershedImageFilterIUC3(itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIUC3_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIUC3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIUC3_Pointer":
        """Clone(itkWatershedImageFilterIUC3 self) -> itkWatershedImageFilterIUC3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIUC3 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIUC3 self, itkImageUC3 input)
        SetInput(itkWatershedImageFilterIUC3 self, unsigned int i, itkImageUC3 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIUC3 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIUC3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIUC3 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIUC3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL3 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIUC3 self) -> itkImageUL3

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< unsigned char > *":
        """
        GetSegmentTree(itkWatershedImageFilterIUC3 self) -> itk::watershed::SegmentTree< unsigned char > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIUC3

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUC3 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIUC3"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIUC3

        Create a new object of the class itkWatershedImageFilterIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIUC3.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_Clone, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GenerateData, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetInput, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetThreshold, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetThreshold, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_SetLevel, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetLevel, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetBasicSegmentation, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_GetSegmentTree, None, itkWatershedImageFilterIUC3)
itkWatershedImageFilterIUC3_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_swigregister
itkWatershedImageFilterIUC3_swigregister(itkWatershedImageFilterIUC3)

def itkWatershedImageFilterIUC3___New_orig__() -> "itkWatershedImageFilterIUC3_Pointer":
    """itkWatershedImageFilterIUC3___New_orig__() -> itkWatershedImageFilterIUC3_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3___New_orig__()

def itkWatershedImageFilterIUC3_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUC3 *":
    """itkWatershedImageFilterIUC3_cast(itkLightObject obj) -> itkWatershedImageFilterIUC3"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUC3_cast(obj)

class itkWatershedImageFilterIUS2(itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIUS2_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIUS2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIUS2_Pointer":
        """Clone(itkWatershedImageFilterIUS2 self) -> itkWatershedImageFilterIUS2_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIUS2 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIUS2 self, itkImageUS2 input)
        SetInput(itkWatershedImageFilterIUS2 self, unsigned int i, itkImageUS2 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIUS2 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIUS2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIUS2 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIUS2 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL2 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIUS2 self) -> itkImageUL2

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< unsigned short > *":
        """
        GetSegmentTree(itkWatershedImageFilterIUS2 self) -> itk::watershed::SegmentTree< unsigned short > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIUS2

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUS2 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIUS2"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIUS2

        Create a new object of the class itkWatershedImageFilterIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIUS2.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_Clone, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GenerateData, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetInput, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetThreshold, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetThreshold, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_SetLevel, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetLevel, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetBasicSegmentation, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_GetSegmentTree, None, itkWatershedImageFilterIUS2)
itkWatershedImageFilterIUS2_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_swigregister
itkWatershedImageFilterIUS2_swigregister(itkWatershedImageFilterIUS2)

def itkWatershedImageFilterIUS2___New_orig__() -> "itkWatershedImageFilterIUS2_Pointer":
    """itkWatershedImageFilterIUS2___New_orig__() -> itkWatershedImageFilterIUS2_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2___New_orig__()

def itkWatershedImageFilterIUS2_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUS2 *":
    """itkWatershedImageFilterIUS2_cast(itkLightObject obj) -> itkWatershedImageFilterIUS2"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS2_cast(obj)

class itkWatershedImageFilterIUS3(itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3):
    """


    A low-level image analysis algorithm that automatically produces a
    hierarchy of segmented, labeled images from a scalar-valued image
    input.

    Overview and terminology

    This filter implements a non-streaming version of an image
    segmentation algorithm commonly known as "watershed segmentation".
    Watershed segmentation gets its name from the manner in which the
    algorithm segments regions into catchment basins. If a function $ f $
    is a continuous height function defined over an image domain, then a
    catchment basin is defined as the set of points whose paths of
    steepest descent terminate at the same local minimum of $ f $.

    The choice of height function (input) depends on the application, and
    the basic watershed algorithm operates independently of that choice.
    For intensity-based image data, you might typically use some sort of
    gradient magnitude calculation as input. (see
    itk::GradientMagnitudeImageFilter)

    The watershed algorithm proceeds in several steps. First, an initial
    classification of all points into catchment basin regions is done by
    tracing each point down its path of steepest descent to a local
    minima. Next, neighboring regions and the boundaries between them are
    analyzed according to some saliency measure (such as minimum boundary
    height) to produce a tree of merges among adjacent regions. These
    merges occur at different maximum saliency values. The collective set
    of all possible merges up to a specified saliency "flood level" is
    referred to in this documentation as a "merge tree". Metaphorically,
    the flood level is a value that reflects the amount of precipitation
    that is rained into the catchment basins. As the flood level rises,
    boundaries between adjacent segments erode and those segments merge.
    The minimum value of the flood level is zero and the maximum value is
    the difference between the highest and lowest values in the input
    image.

    Note that once the initial analysis and segmentation is done to
    produce the merge tree, it is trivial to produce a hierarchy of
    labeled images in constant time. The complexity of the algorithm is in
    the computation of the merge tree. Once that tree has been created,
    the initial segmented image can be relabeled to reflect any maximum
    saliency value found in the tree by simply identifying a subset of
    segment merges from the tree. Implementational details This filter is
    a wrapper for several lower level process objects (watershed algorithm
    components in the namespace "watershed"). For a more complete
    picture of the implementation, refer to the documentation of those
    components. The component classes were designed to operate in either a
    data-streaming or a non-data-streaming mode. The pipeline constructed
    in this class' GenerateData() method does not support streaming, but
    is the common use case for the components. Description of the input to
    this filter The input to this filter is a scalar itk::Image of any
    dimensionality. This input image is assumed to represent some sort of
    height function or edge map based on the original image that you want
    to segment (such as would be produced by
    itk::GradientMagnitudeImageFilter). This filter does not do any pre-
    processing on its input other than a thresholding step. The algorithm
    does not explicitly require that the input be of any particular data
    type, but floating point or double precision data is recommended.

    The recommended pre-processing for scalar image input to this
    algorithm is to use one of the itk::AnisotropicDiffusionImageFilter
    subclasses to smooth the original image and then perform some sort of
    edge calculation based on gradients or curvature. Description of the
    output of this filter This filter will produce an itk::Image of
    IdentifierType integer type and of the same dimensionality as the
    input image. The IdentifierType output image is referred to as the
    "labeled image" in this documentation. Each pixel in the image is
    assigned an IdentifierType integer label that groups it within a
    connected region. Some notes on filter parameters Two parameters
    control the output of this filter, Threshold and Level. The units of
    both parameters are percentage points of the maximum height value in
    the input.

    Threshold is used to set the absolute minimum height value used during
    processing. Raising this threshold percentage effectively decreases
    the number of local minima in the input, resulting in an initial
    segmentation with fewer regions. The assumption is that the shallow
    regions that thresholding removes are of of less interest.

    The Level parameter controls the depth of metaphorical flooding of the
    image. That is, it sets the maximum saliency value of interest in the
    result. Raising and lowering the Level influences the number of
    segments in the basic segmentation that are merged to produce the
    final output. A level of 1.0 is analogous to flooding the image up to
    a depth that is 100 percent of the maximum value in the image. A level
    of 0.0 produces the basic segmentation, which will typically be very
    oversegmented. Level values of interest are typically low (i.e. less
    than about 0.40 or 40% ), since higher values quickly start to
    undersegment the image.

    The Level parameter can be used to create a hierarchy of output images
    in constant time once an initial segmentation is done. A typical
    scenario might go like this: For the initial execution of the filter,
    set the Level to the maximum saliency value that you anticipate might
    be of interest. Once the initial Update() of this process object has
    finished, the Level can be manipulated anywhere below the initial
    setting without triggering a full update of the segmentation mini-
    pipeline. All that is now be required to produce the new output is a
    simple relabeling of the output image.

    Threshold and Level parameters are controlled through the class'
    Get/SetThreshold() and Get/SetLevel() methods.

    C++ includes: itkWatershedImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWatershedImageFilterIUS3_Pointer":
        """__New_orig__() -> itkWatershedImageFilterIUS3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWatershedImageFilterIUS3_Pointer":
        """Clone(itkWatershedImageFilterIUS3 self) -> itkWatershedImageFilterIUS3_Pointer"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_Clone(self)


    def GenerateData(self) -> "void":
        """
        GenerateData(itkWatershedImageFilterIUS3 self)

        Standard process
        object method. This filter is not multithreaded. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GenerateData(self)


    def SetInput(self, *args) -> "void":
        """
        SetInput(itkWatershedImageFilterIUS3 self, itkImageUS3 input)
        SetInput(itkWatershedImageFilterIUS3 self, unsigned int i, itkImageUS3 image)
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetInput(self, *args)


    def SetThreshold(self, arg0: 'double') -> "void":
        """
        SetThreshold(itkWatershedImageFilterIUS3 self, double arg0)

        Set/Get the input
        thresholding parameter. Units are a percentage of the maximum depth in
        the image. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetThreshold(self, arg0)


    def GetThreshold(self) -> "double":
        """GetThreshold(itkWatershedImageFilterIUS3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetThreshold(self)


    def SetLevel(self, arg0: 'double') -> "void":
        """
        SetLevel(itkWatershedImageFilterIUS3 self, double arg0)

        Set/Get the flood level
        for generating the merge tree from the initial segmentation 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetLevel(self, arg0)


    def GetLevel(self) -> "double":
        """GetLevel(itkWatershedImageFilterIUS3 self) -> double"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetLevel(self)


    def GetBasicSegmentation(self) -> "itkImageUL3 *":
        """
        GetBasicSegmentation(itkWatershedImageFilterIUS3 self) -> itkImageUL3

        Get the basic
        segmentation from the Segmenter member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetBasicSegmentation(self)


    def GetSegmentTree(self) -> "itk::watershed::SegmentTree< unsigned short > *":
        """
        GetSegmentTree(itkWatershedImageFilterIUS3 self) -> itk::watershed::SegmentTree< unsigned short > *

        Get the segmentation
        tree from from the TreeGenerator member filter. 
        """
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetSegmentTree(self)

    InputEqualityComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_InputEqualityComparableCheck
    InputAdditiveOperatorsCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_InputAdditiveOperatorsCheck
    DoubleInputMultiplyOperatorCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_DoubleInputMultiplyOperatorCheck
    InputLessThanComparableCheck = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_InputLessThanComparableCheck
    __swig_destroy__ = _itkWatershedImageFilterPython.delete_itkWatershedImageFilterIUS3

    def cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUS3 *":
        """cast(itkLightObject obj) -> itkWatershedImageFilterIUS3"""
        return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWatershedImageFilterIUS3

        Create a new object of the class itkWatershedImageFilterIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWatershedImageFilterIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWatershedImageFilterIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWatershedImageFilterIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWatershedImageFilterIUS3.Clone = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_Clone, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.GenerateData = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GenerateData, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.SetInput = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetInput, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.SetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetThreshold, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.GetThreshold = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetThreshold, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.SetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_SetLevel, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.GetLevel = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetLevel, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.GetBasicSegmentation = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetBasicSegmentation, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3.GetSegmentTree = new_instancemethod(_itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_GetSegmentTree, None, itkWatershedImageFilterIUS3)
itkWatershedImageFilterIUS3_swigregister = _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_swigregister
itkWatershedImageFilterIUS3_swigregister(itkWatershedImageFilterIUS3)

def itkWatershedImageFilterIUS3___New_orig__() -> "itkWatershedImageFilterIUS3_Pointer":
    """itkWatershedImageFilterIUS3___New_orig__() -> itkWatershedImageFilterIUS3_Pointer"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3___New_orig__()

def itkWatershedImageFilterIUS3_cast(obj: 'itkLightObject') -> "itkWatershedImageFilterIUS3 *":
    """itkWatershedImageFilterIUS3_cast(itkLightObject obj) -> itkWatershedImageFilterIUS3"""
    return _itkWatershedImageFilterPython.itkWatershedImageFilterIUS3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def watershed_image_filter(*args, **kwargs):
    """Procedural interface for WatershedImageFilter"""
    import itk
    instance = itk.WatershedImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def watershed_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.WatershedImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.WatershedImageFilter.values()[0]
    else:
        filter_object = itk.WatershedImageFilter

    watershed_image_filter.__doc__ = filter_object.__doc__
    watershed_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    watershed_image_filter.__doc__ += "Available Keyword Arguments:\n"
    watershed_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



